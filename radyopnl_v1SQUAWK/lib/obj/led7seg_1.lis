 0000           ;;*****************************************************************************
 0000           ;;*****************************************************************************
 0000           ;;  FILENAME:   LED7SEG_1.asm
 0000           ;;  Version: 1.0, Updated on 2006/06/14 at 07:47:37
 0000           ;;  Generated by PSoC Designer ver 4.4  b1884 : 14 Jan, 2007
 0000           ;;
 0000           ;;  DESCRIPTION: Seven Segment LCD user module for 22/24/27/29xxx PSoC family of devices.
 0000           ;;
 0000           ;; This set of functions is written to dirve from 1 to 8 seven segment displays.
 0000           ;;
 0000           ;;  LCD connections to PSoC port
 0000           ;;
 0000           ;;    PX.0 ==> LED a                      a
 0000           ;;    PX.1 ==> LED b                    =====
 0000           ;;    PX.2 ==> LED c                   ||   || b
 0000           ;;    PX.3 ==> LED d                 f || g ||
 0000           ;;    PX.4 ==> LED e                    =====
 0000           ;;    PX.5 ==> LED f                   ||   || c
 0000           ;;    PX.6 ==> LED g                 e ||   ||
 0000           ;;    PX.7 ==> LED dp                   =====  # dp
 0000           ;;                                        d     
 0000           ;;    PY.0 ==> Digit 1
 0000           ;;    PY.1 ==> Digit 2
 0000           ;;    PY.2 ==> Digit 3         Digit Number
 0000           ;;    PY.3 ==> Digit 4        +---+---+---+---+---+---+---+---+
 0000           ;;    PY.4 ==> Digit 5        | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
 0000           ;;    PY.5 ==> Digit 6        +---+---+---+---+---+---+---+---+
 0000           ;;    PY.6 ==> Digit 7
 0000           ;;    PY.7 ==> Digit 8
 0000           ;;
 0000           ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
 0000           ;;        arguments and observe the associated "Registers are volatile" policy.
 0000           ;;        This means it is the caller's responsibility to preserve any values
 0000           ;;        in the X and A registers that are still needed after the API functions
 0000           ;;        returns. For Large Memory Model devices it is also the caller's 
 0000           ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
 0000           ;;        MVW_PP registers. Even though some of these registers may not be modified
 0000           ;;        now, there is no guarantee that will remain the case in future releases.
 0000           ;;-----------------------------------------------------------------------------
 0000           ;;  Copyright (c) Cypress MicroSystems 2001-2004. All Rights Reserved.
 0000           ;;*****************************************************************************
 0000           ;;*****************************************************************************
 0000           
 00C0           FLAG_PGMODE_MASK:  equ C0h     ; Paging control for > 256 bytes of RAM
 0000           FLAG_PGMODE_0:     equ 00h       ; Direct to Page 0,      indexed to Page 0
 0040           FLAG_PGMODE_1:     equ 40h       ; Direct to Page 0,      indexed to STK_PP page
 0080           FLAG_PGMODE_2:     equ 80h       ; Direct to CUR_PP page, indexed to IDX_PP page
 00C0           FLAG_PGMODE_3:     equ C0h       ; Direct to CUR_PP page, indexed to STK_PP page
 0000           FLAG_PGMODE_00b:   equ 00h       ; Same as PGMODE_0
 0040           FLAG_PGMODE_01b:   equ 40h       ; Same as PGMODE_1
 0080           FLAG_PGMODE_10b:   equ 80h       ; Same as PGMODE_2
 00C0           FLAG_PGMODE_11b:   equ C0h       ; Same as PGMODE_3
 0010           FLAG_XIO_MASK:     equ 10h     ; I/O Bank select for register space
 0008           FLAG_SUPER:        equ 08h     ; Supervisor Mode
 0004           FLAG_CARRY:        equ 04h     ; Carry Condition Flag
 0002           FLAG_ZERO:         equ 02h     ; Zero  Condition Flag
 0001           FLAG_GLOBAL_IE:    equ 01h     ; Glogal Interrupt Enable
 0000           
 0000           
 0000           ;;=============================================================================
 0000           ;;      Register Space, Bank 0
 0000           ;;=============================================================================
 0000           
 0000           ;------------------------------------------------
 0000           ;  Port Registers
 0000           ;  Note: Also see this address range in Bank 1.
 0000           ;------------------------------------------------
 0000           ; Port 0
 0000           PRT0DR:       equ 00h          ; Port 0 Data Register                     (RW)
 0001           PRT0IE:       equ 01h          ; Port 0 Interrupt Enable Register         (RW)
 0002           PRT0GS:       equ 02h          ; Port 0 Global Select Register            (RW)
 0003           PRT0DM2:      equ 03h          ; Port 0 Drive Mode 2                      (RW)
 0000           ; Port 1
 0004           PRT1DR:       equ 04h          ; Port 1 Data Register                     (RW)
 0005           PRT1IE:       equ 05h          ; Port 1 Interrupt Enable Register         (RW)
 0006           PRT1GS:       equ 06h          ; Port 1 Global Select Register            (RW)
 0007           PRT1DM2:      equ 07h          ; Port 1 Drive Mode 2                      (RW)
 0000           ; Port 2
 0008           PRT2DR:       equ 08h          ; Port 2 Data Register                     (RW)
 0009           PRT2IE:       equ 09h          ; Port 2 Interrupt Enable Register         (RW)
 000A           PRT2GS:       equ 0Ah          ; Port 2 Global Select Register            (RW)
 000B           PRT2DM2:      equ 0Bh          ; Port 2 Drive Mode 2                      (RW)
 0000           ; Port 3
 000C           PRT3DR:       equ 0Ch          ; Port 3 Data Register                     (RW)
 000D           PRT3IE:       equ 0Dh          ; Port 3 Interrupt Enable Register         (RW)
 000E           PRT3GS:       equ 0Eh          ; Port 3 Global Select Register            (RW)
 000F           PRT3DM2:      equ 0Fh          ; Port 3 Drive Mode 2                      (RW)
 0000           ; Port 4
 0010           PRT4DR:       equ 10h          ; Port 4 Data Register                     (RW)
 0011           PRT4IE:       equ 11h          ; Port 4 Interrupt Enable Register         (RW)
 0012           PRT4GS:       equ 12h          ; Port 4 Global Select Register            (RW)
 0013           PRT4DM2:      equ 13h          ; Port 4 Drive Mode 2                      (RW)
 0000           ; Port 5
 0014           PRT5DR:       equ 14h          ; Port 5 Data Register                     (RW)
 0015           PRT5IE:       equ 15h          ; Port 5 Interrupt Enable Register         (RW)
 0016           PRT5GS:       equ 16h          ; Port 5 Global Select Register            (RW)
 0017           PRT5DM2:      equ 17h          ; Port 5 Drive Mode 2                      (RW)
 0000           ; Port 7
 001C           PRT7DR:       equ 1Ch          ; Port 7 Data Register                     (RW)
 001D           PRT7IE:       equ 1Dh          ; Port 7 Interrupt Enable Register         (RW)
 001E           PRT7GS:       equ 1Eh          ; Port 7 Global Select Register            (RW)
 001F           PRT7DM2:      equ 1Fh          ; Port 7 Drive Mode 2                      (RW)
 0000           
 0000           
 0000           ;------------------------------------------------
 0000           ;  Digital PSoC(tm) block Registers
 0000           ;  Note: Also see this address range in Bank 1.
 0000           ;------------------------------------------------
 0000           ; Digital PSoC block 00, Basic Type B
 0020           DBB00DR0:     equ 20h          ; data register 0                          (#)
 0021           DBB00DR1:     equ 21h          ; data register 1                          (W)
 0022           DBB00DR2:     equ 22h          ; data register 2                          (RW)
 0023           DBB00CR0:     equ 23h          ; control & status register 0              (#)
 0000           
 0000           ; Digital PSoC block 01, Basic Type B
 0024           DBB01DR0:     equ 24h          ; data register 0                          (#)
 0025           DBB01DR1:     equ 25h          ; data register 1                          (W)
 0026           DBB01DR2:     equ 26h          ; data register 2                          (RW)
 0027           DBB01CR0:     equ 27h          ; control & status register 0              (#)
 0000           
 0000           ; Digital PSoC block 02, Communications Type B
 0028           DCB02DR0:     equ 28h          ; data register 0                          (#)
 0029           DCB02DR1:     equ 29h          ; data register 1                          (W)
 002A           DCB02DR2:     equ 2Ah          ; data register 2                          (RW)
 002B           DCB02CR0:     equ 2Bh          ; control & status register 0              (#)
 0000           
 0000           ; Digital PSoC block 03, Communications Type B
 002C           DCB03DR0:     equ 2Ch          ; data register 0                          (#)
 002D           DCB03DR1:     equ 2Dh          ; data register 1                          (W)
 002E           DCB03DR2:     equ 2Eh          ; data register 2                          (RW)
 002F           DCB03CR0:     equ 2Fh          ; control & status register 0              (#)
 0000           
 0000           ;------------------------------------------------
 0000           ;  PMA Data Registers
 0000           ;------------------------------------------------
 0000           
 0040           PMA0_DR:   	  equ 40h		   ; PMA Data Register                        (RW)
 0041           PMA1_DR:   	  equ 41h		   ; PMA Data Register                        (RW)
 0042           PMA2_DR:   	  equ 42h		   ; PMA Data Register                        (RW)
 0043           PMA3_DR:   	  equ 43h		   ; PMA Data Register                        (RW)
 0044           PMA4_DR:   	  equ 44h		   ; PMA Data Register                        (RW)
 0045           PMA5_DR:   	  equ 45h		   ; PMA Data Register                        (RW)
 0046           PMA6_DR:   	  equ 46h		   ; PMA Data Register                        (RW)
 0047           PMA7_DR:   	  equ 47h		   ; PMA Data Register                        (RW)
 0000           
 0000           ;------------------------------------------------
 0000           ;  USB Registers
 0000           ;------------------------------------------------
 0000           
 0048           USB_SOF0:     equ 48h		   ; SOF Frame Number LSB(7:0)                (R)
 0049           USB_SOF1:     equ 49h		   ; SOF Frame Number MSB(10:8)               (R)
 0000           
 004A           USB_CR0:      equ 4Ah		   ; USB Control Register 0                   (RW)
 0080           USB_CR0_ENABLE:       equ 80h    ; MASK: enable/disable USB SIE	          (RW)
 007F           USB_CR0_DEVICE_ADDR:  equ 7Fh    ; MASK: USB Device Address               (RW)
 0000           
 004B           USBIO_CR0:    equ 4Bh		   ; USB IO Control Register 0                (#)
 0080           USBIO_CR0_TEN:        equ 80h    ; MASK: enable/disable manual tx on D+ D-(RW)
 0040           USBIO_CR0_TSE0:       equ 40h    ; MASK: transmit a single ended 0        (RW)
 0020           USBIO_CR0_TD:         equ 20h    ; MASK: transmit J or K state on Bus     (RW)
 0001           USBIO_CR0_RD:         equ 01h    ; MASK: read state of differential rx    (R)
 0000           
 004C           USBIO_CR1:    equ 4Ch		   ; USB IO Control Register 0                (RW)
 0080           USBIO_CR1_IOMODE:     equ 80h    ; MASK: select Bit Bang Mode/USB Mode    (RW)
 0040           USBIO_CR1_DRIVE_MODE: equ 40h    ; MASK: select CMOS mode/Open Drain mode (RW)
 0020           USBIO_CR1_DPI:        equ 20h    ; MASK: drive D+ high/low                (RW)
 0010           USBIO_CR1_DMI:        equ 10h    ; MASK: drive D- high/low                (RW)
 0008           USBIO_CR1_PS2PUEN:    equ 08h    ; MASK: enable/disable 5K Pullup on D+/D-(RW)
 0004           USBIO_CR1_USBPUEN:    equ 04h    ; MASK: enable/disable USB Pullup on D+  (RW)
 0002           USBIO_CR1_DPO:        equ 02h    ; MASK: read D+ pin                      (R)
 0001           USBIO_CR1_DMO:        equ 01h    ; MASK: read D- pin                      (R)
 0000           
 0000           
 0000           ;------------------------------------------------
 0000           ;  USB Endpoint Registers
 0000           ;------------------------------------------------
 0000           
 004E           EP1_CNT1:     equ 4Eh		   ; Endpoint 1 Count Register 1              (#)
 0080           EP1_CNT1_DATA_TOGGLE: equ 80h    ; MASK: select data toggle 1/0           (RW)
 0040           EP1_CNT1_DATA_VALID:  equ 40h    ; MASK: read error status on rx data     (R)
 0001           EP1_CNT1_CNT_MSB:     equ 01h    ; MASK: MSB of 9-bit count value         (RW)
 0000           
 004F           EP1_CNT:      equ 4Fh		   ; Endpoint 1 Count Register 0              (RW)
 0000           
 0050           EP2_CNT1:     equ 50h		   ; Endpoint 2 Count Register 1              (#)
 0080           EP2_CNT1_DATA_TOGGLE: equ 80h    ; MASK: select data toggle 1/0           (RW)
 0040           EP2_CNT1_DATA_VALID:  equ 40h    ; MASK: read error status on rx data     (R)
 0001           EP2_CNT1_CNT_MSB:     equ 01h    ; MASK: MSB of 9-bit count value         (RW)
 0000           
 0051           EP2_CNT:      equ 51h		   ; Endpoint 2 Count Register 0              (RW)
 0000           
 0052           EP3_CNT1:     equ 52h		   ; Endpoint 3 Count Register 1              (#)
 0080           EP3_CNT1_DATA_TOGGLE: equ 80h    ; MASK: select data toggle 1/0           (RW)
 0040           EP3_CNT1_DATA_VALID:  equ 40h    ; MASK: read error status on rx data     (R)
 0001           EP3_CNT1_CNT_MSB:     equ 01h    ; MASK: MSB of 9-bit count value         (RW)
 0000           
 0053           EP3_CNT:      equ 53h		   ; Endpoint 3 Count Register 0              (RW)
 0000           
 0054           EP4_CNT1:     equ 54h		   ; Endpoint 4 Count Register 1              (#)
 0080           EP4_CNT1_DATA_TOGGLE: equ 80h    ; MASK: select data toggle 1/0           (RW)
 0040           EP4_CNT1_DATA_VALID:  equ 40h    ; MASK: read error status on rx data     (R)
 0001           EP4_CNT1_CNT_MSB:     equ 01h    ; MASK: MSB of 9-bit count value         (RW)
 0000           
 0055           EP4_CNT:      equ 55h		   ; Endpoint 4 Count Register 0              (RW)
 0000           
 0056           EP0_CR:      equ 56h          ; Endpoint 0 Control Register 0            (#)
 0080           EP0_CR_SETUP_RCVD:   equ 80h    ; MASK: Setup received                   (RC)
 0040           EP0_CR_IN_RCVD:      equ 40h    ; MASK: IN received                      (RC)
 0020           EP0_CR_OUT_RCVD:     equ 20h    ; MASK: OUT received                     (RC)
 0010           EP0_CR_ACKD:         equ 10h    ; MASK: Acked transaction                (RC)
 000F           EP0_CR_MODE:         equ 0Fh    ; MASK: Mode response for endpoint       (RW)
 0000           
 0000           ; ------------------------------------------------------------------------------
 0000           ; The following defines are depricated.  Left here for compatibility. 
 0056           EP0_CR0:      equ 56h          ; Endpoint 0 Control Register 0            (#)
 0080           EP0_CR0_SETUP_RCVD:   equ 80h    ; MASK: Setup received                   (RC)
 0040           EP0_CR0_IN_RCVD:      equ 40h    ; MASK: IN received                      (RC)
 0020           EP0_CR0_OUT_RCVD:     equ 20h    ; MASK: OUT received                     (RC)
 0010           EP0_CR0_ACKD:         equ 10h    ; MASK: Acked transaction                (RC)
 000F           EP0_CR0_MODE:         equ 0Fh    ; MASK: Mode response for endpoint       (RW)
 0000           ; ------------------------------------------------------------------------------
 0000           
 0057           EP0_CNT:      equ 57h          ; Endpoint 0 Count Register                (#)
 0080           EP0_CNT_DATA_TOGGLE: equ 80h    ; MASK: select data toggle 1/0           (RW)
 0040           EP0_CNT_DATA_VALID:  equ 40h    ; MASK: read error status on rx data     (RC)
 000F           EP0_CNT_BYTE_CNT:    equ 0Fh    ; MASK: MSB of 9-bit count value         (RW)
 0000           
 0058           EP0_DR0:      equ 58h          ; Endpoint 0 Data Register 0               (RW)
 0059           EP0_DR1:      equ 59h          ; Endpoint 0 Data Register 1               (RW)
 005A           EP0_DR2:      equ 5Ah          ; Endpoint 0 Data Register 2               (RW)
 005B           EP0_DR3:      equ 5Bh          ; Endpoint 0 Data Register 3               (RW)
 005C           EP0_DR4:      equ 5Ch          ; Endpoint 0 Data Register 4               (RW)
 005D           EP0_DR5:      equ 5Dh          ; Endpoint 0 Data Register 5               (RW)
 005E           EP0_DR6:      equ 5Eh          ; Endpoint 0 Data Register 6               (RW)
 005F           EP0_DR7:      equ 5Fh          ; Endpoint 0 Data Register 7               (RW)
 0000           
 0000           ;-------------------------------------
 0000           ;  Analog Control Registers
 0000           ;-------------------------------------
 0060           AMX_IN:       equ 60h          ; Analog Input Multiplexor Control         (RW)
 000C           AMX_IN_ACI1:          equ 0Ch    ; MASK: column 1 input mux
 0003           AMX_IN_ACI0:          equ 03h    ; MASK: column 0 input mux
 0000           
 0061           AMUXCFG:      equ 61h          ; Analog Mux Bus Configuration Register    (RW)
 0080           AMUXCFG_BCOL0_MUX:    equ 80h    ; MASK: select AMuxBusB for Col1 input   (RW)
 0040           AMUXCFG_ACOL0_MUX:    equ 40h    ; MASK: select AMuxBusA for Col0 input   (RW)  
 0030           AMUXCFG_INTCAP:       equ 30h    ; MASK: select pins for static operation (RW)
 000E           AMUXCFG_MUXCLK:       equ 0Eh    ; MASK: select precharge clock source    (RW)
 0001           AMUXCFG_EN:           equ 01h    ; MASK: enable/disable MUXCLK            (RW)
 0000           
 0063           ARF_CR:       equ 63h          ; Analog Reference Control Register        (RW)
 0040           ARF_CR_HBE:           equ 40h    ; MASK: Bias level control
 0038           ARF_CR_REF:           equ 38h    ; MASK: Analog Reference controls
 0007           ARF_CR_REFPWR:        equ 07h    ; MASK: Analog Reference power
 0003           ARF_CR_SCPWR:         equ 03h    ; MASK: Switched Cap block power
 0000           
 0064           CMP_CR0:      equ 64h          ; Analog Comparator Bus 0 Register         (#)
 0020           CMP_CR0_COMP1:        equ 20h    ; MASK: Column 1 comparator state        (R)
 0010           CMP_CR0_COMP0:        equ 10h    ; MASK: Column 0 comparator state        (R)
 0002           CMP_CR0_AINT1:        equ 02h    ; MASK: Column 1 interrupt source        (RW)
 0001           CMP_CR0_AINT0:        equ 01h    ; MASK: Column 0 interrupt source        (RW)
 0000           
 0065           ASY_CR:       equ 65h          ; Analog Synchronizaton Control            (#)
 0070           ASY_CR_SARCOUNT:      equ 70h    ; MASK: SAR support: resolution count    (W)
 0008           ASY_CR_SARSIGN:       equ 08h    ; MASK: SAR support: sign                (RW)
 0006           ASY_CR_SARCOL:        equ 06h    ; MASK: SAR support: column spec         (RW)
 0001           ASY_CR_SYNCEN:        equ 01h    ; MASK: Stall bit                        (RW)
 0000           
 0066           CMP_CR1:      equ 66h          ; Analog Comparator Bus 1 Register         (RW)
 0020           CMP_CR1_CLDIS1:       equ 20h    ; MASK: Column 1 comparator bus synch
 0010           CMP_CR1_CLDIS0:       equ 10h    ; MASK: Column 0 comparator bus synch
 0002           CMP_CR1_CLDIX1:       equ 02h    ; MASK: Column 1 comparator bus synch
 0001           CMP_CR1_CLDIX0:       equ 01h    ; MASK: Column 0 comparator bus synch
 0000           
 0000           ;-----------------------------------------------
 0000           ;  Global General Purpose Data Registers
 0000           ;-----------------------------------------------
 006C           TMP_DR0:      equ 6Ch          ; Temporary Data Register 0                (RW)
 006D           TMP_DR1:      equ 6Dh          ; Temporary Data Register 1                (RW)
 006E           TMP_DR2:      equ 6Eh          ; Temporary Data Register 2                (RW)
 006F           TMP_DR3:      equ 6Fh          ; Temporary Data Register 3                (RW)
 0000           
 0000           ;---------------------------------------------------
 0000           ;  Analog PSoC block Registers
 0000           ;
 0000           ;  Note: the following registers are mapped into
 0000           ;  both register bank 0 AND register bank 1.
 0000           ;---------------------------------------------------
 0000           
 0000           ; Continuous Time PSoC block Type B Row 0 Col 0
 0070           ACB00CR3:     equ 70h          ; Control register 3                       (RW)
 0071           ACB00CR0:     equ 71h          ; Control register 0                       (RW)
 0072           ACB00CR1:     equ 72h          ; Control register 1                       (RW)
 0073           ACB00CR2:     equ 73h          ; Control register 2                       (RW)
 0000           
 0000           ; Continuous Time PSoC block Type B Row 0 Col 1
 0074           ACB01CR3:     equ 74h          ; Control register 3                       (RW)
 0075           ACB01CR0:     equ 75h          ; Control register 0                       (RW)
 0076           ACB01CR1:     equ 76h          ; Control register 1                       (RW)
 0077           ACB01CR2:     equ 77h          ; Control register 2                       (RW)
 0000           
 0000           ; Switched Cap PSoC blockType C Row 1 Col 0
 0080           ASC10CR0:     equ 80h          ; Control register 0                       (RW)
 0081           ASC10CR1:     equ 81h          ; Control register 1                       (RW)
 0082           ASC10CR2:     equ 82h          ; Control register 2                       (RW)
 0083           ASC10CR3:     equ 83h          ; Control register 3                       (RW)
 0000           
 0000           ; Switched Cap PSoC blockType D Row 1 Col 1
 0084           ASD11CR0:     equ 84h          ; Control register 0                       (RW)
 0085           ASD11CR1:     equ 85h          ; Control register 1                       (RW)
 0086           ASD11CR2:     equ 86h          ; Control register 2                       (RW)
 0087           ASD11CR3:     equ 87h          ; Control register 3                       (RW)
 0000           
 0000           ; Switched Cap PSoC blockType D Row 2 Col 0
 0090           ASD20CR0:     equ 90h          ; Control register 0                       (RW)
 0091           ASD20CR1:     equ 91h          ; Control register 1                       (RW)
 0092           ASD20CR2:     equ 92h          ; Control register 2                       (RW)
 0093           ASD20CR3:     equ 93h          ; Control register 3                       (RW)
 0000           
 0000           ; Switched Cap PSoC blockType C Row 2 Col 1
 0094           ASC21CR0:     equ 94h          ; Control register 0                       (RW)
 0095           ASC21CR1:     equ 95h          ; Control register 1                       (RW)
 0096           ASC21CR2:     equ 96h          ; Control register 2                       (RW)
 0097           ASC21CR3:     equ 97h          ; Control register 3                       (RW)
 0000           
 0000           ;------------------------------------------------
 0000           ;  Row Digital Interconnects
 0000           ;
 0000           ;  Note: the following registers are mapped into
 0000           ;  both register bank 0 AND register bank 1.
 0000           ;------------------------------------------------
 0000           
 00B0           RDI0RI:       equ B0h          ; Row Digital Interconnect Row 0 Input Reg (RW)
 00B1           RDI0SYN:      equ B1h          ; Row Digital Interconnect Row 0 Sync Reg  (RW)
 00B2           RDI0IS:       equ B2h          ; Row 0 Input Select Register              (RW)
 00B3           RDI0LT0:      equ B3h          ; Row 0 Look Up Table Register 0           (RW)
 00B4           RDI0LT1:      equ B4h          ; Row 0 Look Up Table Register 1           (RW)
 00B5           RDI0RO0:      equ B5h          ; Row 0 Output Register 0                  (RW)
 00B6           RDI0RO1:      equ B6h          ; Row 0 Output Register 1                  (RW)
 0000           
 0000           ;-----------------------------------------------
 0000           ;  Ram Page Pointers
 0000           ;-----------------------------------------------
 00D0           CUR_PP:      equ D0h           ; Current   Page Pointer
 00D1           STK_PP:      equ D1h           ; Stack     Page Pointer
 00D3           IDX_PP:      equ D3h           ; Index     Page Pointer
 00D4           MVR_PP:      equ D4h           ; MVI Read  Page Pointer
 00D5           MVW_PP:      equ D5h           ; MVI Write Page Pointer
 0000           
 0000           ;------------------------------------------------
 0000           ;  I2C Configuration Registers
 0000           ;------------------------------------------------
 00D6           I2C_CFG:      equ D6h          ; I2C Configuration Register               (RW)
 0040           I2C_CFG_PINSEL:         equ 40h  ; MASK: Select P1[0] and P1[1] for I2C
 0020           I2C_CFG_BUSERR_IE:      equ 20h  ; MASK: Enable interrupt on Bus Error
 0010           I2C_CFG_STOP_IE:        equ 10h  ; MASK: Enable interrupt on Stop
 0000           I2C_CFG_CLK_RATE_100K:  equ 00h  ; MASK: I2C clock set at 100K
 0004           I2C_CFG_CLK_RATE_400K:  equ 04h  ; MASK: I2C clock set at 400K
 0008           I2C_CFG_CLK_RATE_50K:   equ 08h  ; MASK: I2C clock set at 50K
 000C           I2C_CFG_CLK_RATE_1M6:   equ 0Ch  ; MASK: I2C clock set at 1.6M
 000C           I2C_CFG_CLK_RATE:       equ 0Ch  ; MASK: I2C clock rate setting mask
 0002           I2C_CFG_PSELECT_MASTER: equ 02h  ; MASK: Enable I2C Master
 0001           I2C_CFG_PSELECT_SLAVE:  equ 01h  ; MASK: Enable I2C Slave
 0000           
 00D7           I2C_SCR:      equ D7h          ; I2C Status and Control Register          (#)
 0080           I2C_SCR_BUSERR:        equ 80h   ; MASK: I2C Bus Error detected           (RC)
 0040           I2C_SCR_LOSTARB:       equ 40h   ; MASK: I2C Arbitration lost             (RC)
 0020           I2C_SCR_STOP:          equ 20h   ; MASK: I2C Stop detected                (RC)
 0010           I2C_SCR_ACK:           equ 10h   ; MASK: ACK the last byte                (RW)
 0008           I2C_SCR_ADDR:          equ 08h   ; MASK: Address rcv'd is Slave address   (RC)
 0004           I2C_SCR_XMIT:          equ 04h   ; MASK: Set transfer to tranmit mode     (RW)
 0002           I2C_SCR_LRB:           equ 02h   ; MASK: Last recieved bit                (RC)
 0001           I2C_SCR_BYTECOMPLETE:  equ 01h   ; MASK: Transfer of byte complete        (RC)
 0000           
 00D8           I2C_DR:       equ D8h          ; I2C Data Register                        (RW)
 0000           
 00D9           I2C_MSCR:     equ D9h          ; I2C Master Status and Control Register   (#)
 0008           I2C_MSCR_BUSY:         equ 08h   ; MASK: I2C Busy (Start detected)        (R)
 0004           I2C_MSCR_MODE:         equ 04h   ; MASK: Start has been generated         (R)
 0002           I2C_MSCR_RESTART:      equ 02h   ; MASK: Generate a Restart condition     (RW)
 0001           I2C_MSCR_START:        equ 01h   ; MASK: Generate a Start condition       (RW)
 0000           
 0000           ;------------------------------------------------
 0000           ;  System and Global Resource Registers
 0000           ;------------------------------------------------
 00DA           INT_CLR0:     equ DAh          ; Interrupt Clear Register 0               (RW)
 0000                                          ; Use INT_MSK0 bit field masks
 00DB           INT_CLR1:     equ DBh          ; Interrupt Clear Register 1               (RW)
 0000                                          ; Use INT_MSK1 bit field masks
 00DC           INT_CLR2:     equ DCh          ; Interrupt Clear Register 2               (RW)
 0000                                          ; Use INT_MSK2 bit field masks
 00DD           INT_CLR3:     equ DDh          ; Interrupt Clear Register 3               (RW)
 0000                                          ; Use INT_MSK3 bit field masks
 0000           
 00DE           INT_MSK3:     equ DEh          ; I2C and Software Mask Register           (RW)
 0080           INT_MSK3_ENSWINT:          equ 80h ; MASK: enable/disable SW interrupt
 0001           INT_MSK3_I2C:              equ 01h ; MASK: enable/disable I2C interrupt
 0000           
 00DF           INT_MSK2:     equ DFh          ; USB Mask Register           (RW)
 0080           INT_MSK2_WAKEUP:           equ 80h ; MASK: enable/disable I2C interrupt
 0040           INT_MSK2_EP4:              equ 40h ; MASK: enable/disable SW interrupt
 0020           INT_MSK2_EP3:              equ 20h ; MASK: enable/disable I2C interrupt
 0010           INT_MSK2_EP2:              equ 10h ; MASK: enable/disable SW interrupt
 0008           INT_MSK2_EP1:              equ 08h ; MASK: enable/disable I2C interrupt
 0004           INT_MSK2_EP0:              equ 04h ; MASK: enable/disable SW interrupt
 0002           INT_MSK2_SOF:              equ 02h ; MASK: enable/disable I2C interrupt
 0001           INT_MSK2_BUS_RESET:        equ 01h ; MASK: enable/disable SW interrupt
 0000           
 00E0           INT_MSK0:     equ E0h          ; General Interrupt Mask Register          (RW)
 0080           INT_MSK0_VC3:              equ 80h ; MASK: enable/disable VC3 interrupt
 0040           INT_MSK0_SLEEP:            equ 40h ; MASK: enable/disable sleep interrupt
 0020           INT_MSK0_GPIO:             equ 20h ; MASK: enable/disable GPIO  interrupt
 0004           INT_MSK0_ACOLUMN_1:        equ 04h ; MASK: enable/disable Analog col 1 interrupt
 0002           INT_MSK0_ACOLUMN_0:        equ 02h ; MASK: enable/disable Analog col 0 interrupt
 0001           INT_MSK0_VOLTAGE_MONITOR:  equ 01h ; MASK: enable/disable Volts interrupt
 0000           
 00E1           INT_MSK1:     equ E1h          ; Digital PSoC block Mask Register         (RW)
 0008           INT_MSK1_DCB03:            equ 08h ; MASK: enable/disable DCB03 block interrupt
 0004           INT_MSK1_DCB02:            equ 04h ; MASK: enable/disable DCB02 block interrupt
 0002           INT_MSK1_DBB01:            equ 02h ; MASK: enable/disable DBB01 block interrupt
 0001           INT_MSK1_DBB00:            equ 01h ; MASK: enable/disable DBB00 block interrupt
 0000           
 00E2           INT_VC:       equ E2h          ; Interrupt vector register                (RC)
 00E3           RES_WDT:      equ E3h          ; Watch Dog Timer Register                 (W)
 0000           
 0000           ; DECIMATOR Control Registers
 00E4           DEC_DH:       equ E4h          ; Data High Register                       (RW)
 00E5           DEC_DL:       equ E5h          ; Data Low Register                        (RW)
 00E6           DEC_CR0:      equ E6h          ; Data Control Register 0                  (RW)
 00E7           DEC_CR1:      equ E7h          ; Data Control Register 1                  (RW)
 0000           
 0000           ;------------------------------------------------------
 0000           ;  MAC Registers
 0000           ;------------------------------------------------------
 0000           
 00E8           MUL0_X:       equ E8h          ; Multiply Input X Register                (W)
 00E9           MUL0_Y:       equ E9h          ; Multiply Input Y Register                (W)
 00EA           MUL0_DH:      equ EAh          ; Multiply Result High Byte Register       (R)
 00EB           MUL0_DL:      equ EBh          ; Multiply Result Low Byte Register        (R)
 0000           
 00EC           ACC0_DR1:     equ ECh          ; Accumulator Data Register 1              (RW)
 00ED           ACC0_DR0:     equ EDh          ; Accumulator Data Register 0              (RW)
 00EE           ACC0_DR3:     equ EEh          ; Accumulator Data Register 3              (RW)
 00EF           ACC0_DR2:     equ EFh          ; Accumulator Data Register 2              (RW)
 0000           
 0000           ;------------------------------------------------------
 0000           ;  System Status and Control Registers
 0000           ;
 0000           ;  Note: The following registers are mapped into both
 0000           ;        register bank 0 AND register bank 1.
 0000           ;------------------------------------------------------
 00F7           CPU_F:        equ F7h          ; CPU Flag Register Access                 (RO)
 0000                                              ; Use FLAG_ masks defined at top of file
 0000           
 00FD           DAC_D:        equ FDh		   ; DAC Data Register                        (RW)
 0000           
 00FE           CPU_SCR1:     equ FEh          ; CPU Status and Control Register #1       (#)
 0080           CPU_SCR1_IRESS:         equ 80h    ; MASK: flag, Internal Reset Status bit
 0010           CPU_SCR1_SLIMO:         equ 10h	   ; MASK: Slow IMO (internal main osc) enable
 0008           CPU_SCR1_ECO_ALWD_WR:   equ 08h    ; MASK: flag, ECO allowed has been written
 0004           CPU_SCR1_ECO_ALLOWED:   equ 04h    ; MASK: ECO allowed to be enabled
 0001           CPU_SCR1_IRAMDIS:       equ 01h    ; MASK: Disable RAM initialization on WDR
 0000           
 00FF           CPU_SCR0:     equ FFh          ; CPU Status and Control Register #2       (#)
 0080           CPU_SCR0_GIE_MASK:      equ 80h    ; MASK: Global Interrupt Enable shadow
 0020           CPU_SCR0_WDRS_MASK:     equ 20h    ; MASK: Watch Dog Timer Reset
 0010           CPU_SCR0_PORS_MASK:     equ 10h    ; MASK: power-on reset bit PORS
 0008           CPU_SCR0_SLEEP_MASK:    equ 08h    ; MASK: Enable Sleep
 0001           CPU_SCR0_STOP_MASK:     equ 01h    ; MASK: Halt CPU bit
 0000           
 0000           
 0000           ;;=============================================================================
 0000           ;;      Register Space, Bank 1
 0000           ;;=============================================================================
 0000           
 0000           ;------------------------------------------------
 0000           ;  Port Registers
 0000           ;  Note: Also see this address range in Bank 0.
 0000           ;------------------------------------------------
 0000           ; Port 0
 0000           PRT0DM0:      equ 00h          ; Port 0 Drive Mode 0                      (RW)
 0001           PRT0DM1:      equ 01h          ; Port 0 Drive Mode 1                      (RW)
 0002           PRT0IC0:      equ 02h          ; Port 0 Interrupt Control 0               (RW)
 0003           PRT0IC1:      equ 03h          ; Port 0 Interrupt Control 1               (RW)
 0000           
 0000           ; Port 1
 0004           PRT1DM0:      equ 04h          ; Port 1 Drive Mode 0                      (RW)
 0005           PRT1DM1:      equ 05h          ; Port 1 Drive Mode 1                      (RW)
 0006           PRT1IC0:      equ 06h          ; Port 1 Interrupt Control 0               (RW)
 0007           PRT1IC1:      equ 07h          ; Port 1 Interrupt Control 1               (RW)
 0000           
 0000           ; Port 2
 0008           PRT2DM0:      equ 08h          ; Port 2 Drive Mode 0                      (RW)
 0009           PRT2DM1:      equ 09h          ; Port 2 Drive Mode 1                      (RW)
 000A           PRT2IC0:      equ 0Ah          ; Port 2 Interrupt Control 0               (RW)
 000B           PRT2IC1:      equ 0Bh          ; Port 2 Interrupt Control 1               (RW)
 0000           
 0000           ; Port 3
 000C           PRT3DM0:      equ 0Ch          ; Port 3 Drive Mode 0                      (RW)
 000D           PRT3DM1:      equ 0Dh          ; Port 3 Drive Mode 1                      (RW)
 000E           PRT3IC0:      equ 0Eh          ; Port 3 Interrupt Control 0               (RW)
 000F           PRT3IC1:      equ 0Fh          ; Port 3 Interrupt Control 1               (RW)
 0000           
 0000           ; Port 4
 0010           PRT4DM0:      equ 10h          ; Port 4 Drive Mode 0                      (RW)
 0011           PRT4DM1:      equ 11h          ; Port 4 Drive Mode 1                      (RW)
 0012           PRT4IC0:      equ 12h          ; Port 4 Interrupt Control 0               (RW)
 0013           PRT4IC1:      equ 13h          ; Port 4 Interrupt Control 1               (RW)
 0000           
 0000           ; Port 5
 0014           PRT5DM0:      equ 14h          ; Port 5 Drive Mode 0                      (RW)
 0015           PRT5DM1:      equ 15h          ; Port 5 Drive Mode 1                      (RW)
 0016           PRT5IC0:      equ 16h          ; Port 5 Interrupt Control 0               (RW)
 0017           PRT5IC1:      equ 17h          ; Port 5 Interrupt Control 1               (RW)
 0000           
 0000           ; Port 7
 001C           PRT7DM0:      equ 1Ch          ; Port 7 Drive Mode 0                      (RW)
 001D           PRT7DM1:      equ 1Dh          ; Port 7 Drive Mode 1                      (RW)
 001E           PRT7IC0:      equ 1Eh          ; Port 7 Interrupt Control 0               (RW)
 001F           PRT7IC1:      equ 1Fh          ; Port 7 Interrupt Control 1               (RW)
 0000           
 0000           ;------------------------------------------------
 0000           ;  Digital PSoC(tm) block Registers
 0000           ;  Note: Also see this address range in Bank 0.
 0000           ;------------------------------------------------
 0000           
 0000           ; Digital PSoC block 00, Basic Type B
 0020           DBB00FN:      equ 20h          ; Function Register                        (RW)
 0021           DBB00IN:      equ 21h          ;    Input Register                        (RW)
 0022           DBB00OU:      equ 22h          ;   Output Register                        (RW)
 0000           
 0000           ; Digital PSoC block 01, Basic Type B
 0024           DBB01FN:      equ 24h          ; Function Register                        (RW)
 0025           DBB01IN:      equ 25h          ;    Input Register                        (RW)
 0026           DBB01OU:      equ 26h          ;   Output Register                        (RW)
 0000           
 0000           ; Digital PSoC block 02, Communications Type B
 0028           DCB02FN:      equ 28h          ; Function Register                        (RW)
 0029           DCB02IN:      equ 29h          ;    Input Register                        (RW)
 002A           DCB02OU:      equ 2Ah          ;   Output Register                        (RW)
 0000           
 0000           ; Digital PSoC block 03, Communications Type B
 002C           DCB03FN:      equ 2Ch          ; Function Register                        (RW)
 002D           DCB03IN:      equ 2Dh          ;    Input Register                        (RW)
 002E           DCB03OU:      equ 2Eh          ;   Output Register                        (RW)
 0000           
 0000           ;------------------------------------------------
 0000           ;  PMA Write and Read Registers
 0000           ;------------------------------------------------
 0000           
 0040           PMA0_WA:   	  equ 40h		   ; PMA Write Pointer Register               (RW)
 0041           PMA1_WA:   	  equ 41h		   ; PMA Write Pointer Register               (RW)
 0042           PMA2_WA:   	  equ 42h		   ; PMA Write Pointer Register               (RW)
 0043           PMA3_WA:   	  equ 43h		   ; PMA Write Pointer Register               (RW)
 0044           PMA4_WA:   	  equ 44h		   ; PMA Write Pointer Register               (RW)
 0045           PMA5_WA:   	  equ 45h		   ; PMA Write Pointer Register               (RW)
 0046           PMA6_WA:   	  equ 46h		   ; PMA Write Pointer Register               (RW)
 0047           PMA7_WA:   	  equ 47h		   ; PMA Write Pointer Register               (RW)
 0000           
 0050           PMA0_RA:   	  equ 50h		   ;  PMA Read Pointer Register               (RW)
 0051           PMA1_RA:   	  equ 51h		   ;  PMA Read Pointer Register               (RW)
 0052           PMA2_RA:   	  equ 52h		   ;  PMA Read Pointer Register               (RW)
 0053           PMA3_RA:   	  equ 53h		   ;  PMA Read Pointer Register               (RW)
 0054           PMA4_RA:   	  equ 54h		   ;  PMA Read Pointer Register               (RW)
 0055           PMA5_RA:   	  equ 55h		   ;  PMA Read Pointer Register               (RW)
 0056           PMA6_RA:   	  equ 56h		   ;  PMA Read Pointer Register               (RW)
 0057           PMA7_RA:   	  equ 57h		   ;  PMA Read Pointer Register               (RW)
 0000           
 0000           
 0000           
 0000           ;------------------------------------------------
 0000           ;  System and Global Resource Registers
 0000           ;  Note: Also see this address range in Bank 0.
 0000           ;------------------------------------------------
 0000           
 0060           CLK_CR0:      equ 60h          ; Analog Column Clock Select Register 0    (RW)
 000C           CLK_CR0_ACOLUMN_1:    equ 0Ch    ; MASK: Specify clock for analog cloumn
 0003           CLK_CR0_ACOLUMN_0:    equ 03h    ; MASK: Specify clock for analog cloumn
 0000           
 0061           CLK_CR1:      equ 61h          ; Analog Clock Source Select Register 1    (RW)
 0040           CLK_CR1_SHDIS:        equ 40h    ; MASK: Sample and Hold Disable (all Columns)
 0038           CLK_CR1_ACLK1:        equ 38h    ; MASK: Digital PSoC block for analog source
 0007           CLK_CR1_ACLK2:        equ 07h    ; MASK: Digital PSoC block for analog source
 0000           
 0062           ABF_CR0:      equ 62h          ; Analog Output Buffer Control Register 0  (RW)
 0080           ABF_CR0_ACOL1MUX:     equ 80h    ; MASK: Analog Column 1 Mux control
 0020           ABF_CR0_ABUF1EN:      equ 20h    ; MASK: Enable ACol 1 analog buffer (P0[5])
 0008           ABF_CR0_ABUF0EN:      equ 08h    ; MASK: Enable ACol 0 analog buffer (P0[3])
 0002           ABF_CR0_BYPASS:       equ 02h    ; MASK: Bypass the analog buffers
 0001           ABF_CR0_PWR:          equ 01h    ; MASK: High power mode on all analog buffers
 0000           
 0063           AMD_CR0:      equ 63h          ; Analog Modulator Control Register 0      (RW)
 0007           AMD_CR0_AMOD0:        equ 07h    ; MASK: Modulation source for analog column 1
 0000           
 0064           CMP_GO_EN:    equ 64h          ; Comparator Bus 0/1 To Global Out Enable  (RW)
 0080           CMP_GO_EN_GOO5:       equ 80h    ; MASK: Selected Col 1 signal to GOO5
 0040           CMP_GO_EN_GOO1:       equ 40h    ; MASK: Selected Col 1 signal to GOO1
 0030           CMP_GO_EN_SEL1:       equ 30h    ; MASK: Column 1 Signal Select
 0008           CMP_GO_EN_GOO4:       equ 08h    ; MASK: Selected Col 0 signal to GOO4
 0004           CMP_GO_EN_GOO0:       equ 04h    ; MASK: Selected Col 0 signal to GOO0
 0003           CMP_GO_EN_SEL0:       equ 03h    ; MASK: Column 0 Signal Select
 0000           
 0065           CMP_GO_EN1:   equ 65h          ; Comparator Bus 2/3 To Global Out Enable  (RW)
 0080           CMP_GO_EN1_GOO7:      equ 80h    ; MASK: Selected Col 3 signal to GOO5
 0040           CMP_GO_EN1_GOO3:      equ 40h    ; MASK: Selected Col 3 signal to GOO1
 0030           CMP_GO_EN1_SEL3:      equ 30h    ; MASK: Column 3 Signal Select
 0008           CMP_GO_EN1_GOO6:      equ 08h    ; MASK: Selected Col 2 signal to GOO4
 0004           CMP_GO_EN1_GOO2:      equ 04h    ; MASK: Selected Col 2 signal to GOO0
 0003           CMP_GO_EN1_SEL2:      equ 03h    ; MASK: Column 2 Signal Select
 0000           
 0066           AMD_CR1:      equ 66h          ; Analog Modulator Control Register 1      (RW)
 0007           AMD_CR1_AMOD1:        equ 07h    ; MASK: Modulation ctrl for analog column 1
 0000           
 0067           ALT_CR0:      equ 67h          ; Analog Look Up Table (LUT) Register 0    (RW)
 00F0           ALT_CR0_LUT1:         equ F0h    ; MASK: Look up table 1 selection
 000F           ALT_CR0_LUT0:         equ 0Fh    ; MASK: Look up table 0 selection
 0000           
 0000           
 0000           ;------------------------------------------------
 0000           ;  USB Registers
 0000           ;------------------------------------------------
 0000           
 00C1           USB_CR1:      equ C1h          ; USB Control Register 1                   (#)
 0004           USB_CR1_BUS_ACTIVITY: equ 04h    ; MASK: monitors activity on USB bus     (RC)
 0002           USB_CR1_ENABLE_LOCK:  equ 02h    ; MASK: enable/disable auto lock of osc  (RW)
 0001           USB_CR1_REG_ENABLE:   equ 01h    ; MASK: set mode to reg. on/pass thru    (RW)
 0000           
 00C4           EP1_CR0:      equ C4h          ; EP1 Control Register 0                   (#)
 0080           EP1_CR0_STALL:        equ 80h    ; MASK: enable/disable stall             (RW)
 0020           EP1_CR0_NAK_INT_EN:   equ 20h    ; MASK: enable/disable NAK interrupts    (RW)
 0010           EP1_CR0_ACKD:         equ 10h    ; MASK: set when acked transaction occurs(RC)
 000F           EP1_CR0_MODE:         equ 0Fh    ; MASK: mode control for endpoint        (RW)
 0000           
 00C5           EP2_CR0:      equ C5h          ; EP2 Control Register 0                   (#)
 0080           EP2_CR0_STALL:        equ 80h    ; MASK: enable/disable stall             (RW)
 0020           EP2_CR0_NAK_INT_EN:   equ 20h    ; MASK: enable/disable NAK interrupts    (RW)
 0010           EP2_CR0_ACKD:         equ 10h    ; MASK: set when acked transaction occurs(RC)
 000F           EP2_CR0_MODE:         equ 0Fh    ; MASK: mode control for endpoint        (RW)
 0000           
 00C6           EP3_CR0:      equ C6h          ; EP3 Control Register 0                   (#)
 0080           EP3_CR0_STALL:        equ 80h    ; MASK: enable/disable stall             (RW)
 0020           EP3_CR0_NAK_INT_EN:   equ 20h    ; MASK: enable/disable NAK interrupts    (RW)
 0010           EP3_CR0_ACKD:         equ 10h    ; MASK: set when acked transaction occurs(RC)
 000F           EP3_CR0_MODE:         equ 0Fh    ; MASK: mode control for endpoint        (RW)
 0000           
 00C7           EP4_CR0:      equ C7h          ; EP4 Control Register 0                   (#)
 0080           EP4_CR0_STALL:        equ 80h    ; MASK: enable/disable stall             (RW)
 0020           EP4_CR0_NAK_INT_EN:   equ 20h    ; MASK: enable/disable NAK interrupts    (RW)
 0010           EP4_CR0_ACKD:         equ 10h    ; MASK: set when acked transaction occurs(RC)
 000F           EP4_CR0_MODE:         equ 0Fh    ; MASK: mode control for endpoint        (RW)
 0000           
 0000           ;------------------------------------------------
 0000           ;  Global Digital Interconnects
 0000           ;------------------------------------------------
 0000           
 00D0           GDI_O_IN:     equ D0h          ; Global Dig Interconnect Odd Inputs Reg   (RW)
 00D1           GDI_E_IN:     equ D1h          ; Global Dig Interconnect Even Inputs Reg  (RW)
 00D2           GDI_O_OU:     equ D2h          ; Global Dig Interconnect Odd Outputs Reg  (RW)
 00D3           GDI_E_OU:     equ D3h          ; Global Dig Interconnect Even Outputs Reg (RW)
 0000           
 0000           ;------------------------------------------------
 0000           ;  AMuxBus Mux Control Registers
 0000           ;------------------------------------------------
 0000           
 00D8           MUX_CR0:      equ D8h          ; Analog Mux Bus Port 0 Bit Enables Reg    (RW)
 00D9           MUX_CR1:      equ D9h          ; Analog Mux Bus Port 1 Bit Enables Reg    (RW)
 00DA           MUX_CR2:      equ DAh          ; Analog Mux Bus Port 2 Bit Enables Reg    (RW)
 00DB           MUX_CR3:      equ DBh          ; Analog Mux Bus Port 3 Bit Enables Reg    (RW)
 00EC           MUX_CR4:      equ ECh          ; Analog Mux Bus Port 4 Bit Enables Reg    (RW)
 00ED           MUX_CR5:      equ EDh          ; Analog Mux Bus Port 5 Bit Enables Reg    (RW)
 0000           
 0000           ;------------------------------------------------
 0000           ;  Clock and System Control Registers
 0000           ;------------------------------------------------
 0000           
 00DD           OSC_GO_EN:    equ DDh          ; Oscillator to Global Outputs Enable Register (RW)
 0080           OSC_GOEN_SLPINT:      equ 80h	 ; Enable Sleep Timer onto GOE[7]
 0040           OSC_GOEN_VC3:         equ 40h    ; Enable VC3 onto GOE[6]
 0020           OSC_GOEN_VC2:         equ 20h    ; Enable VC2 onto GOE[5]
 0010           OSC_GOEN_VC1:         equ 10h    ; Enable VC1 onto GOE[4]
 0008           OSC_GOEN_SYSCLKX2:    equ 08h    ; Enable 2X SysClk onto GOE[3]
 0004           OSC_GOEN_SYSCLK:      equ 04h    ; Enable 1X SysClk onto GOE[2]
 0002           OSC_GOEN_CLK24M:      equ 02h    ; Enable 24 MHz clock onto GOE[1]
 0001           OSC_GOEN_CLK32K:      equ 01h    ; Enable 32 kHz clock onto GOE[0]
 0000           
 00DE           OSC_CR4:      equ DEh          ; Oscillator Control Register 4            (RW)
 0003           OSC_CR4_VC3SEL:       equ 03h    ; MASK: System VC3 Clock source
 0000           
 00DF           OSC_CR3:      equ DFh          ; Oscillator Control Register 3            (RW)
 0000           
 00E0           OSC_CR0:      equ E0h          ; System Oscillator Control Register 0     (RW)
 0080           OSC_CR0_32K_SELECT:   equ 80h    ; MASK: Enable/Disable External XTAL Osc
 0040           OSC_CR0_PLL_MODE:     equ 40h    ; MASK: Enable/Disable PLL
 0020           OSC_CR0_NO_BUZZ:      equ 20h    ; MASK: Bandgap always powered/BUZZ bandgap
 0018           OSC_CR0_SLEEP:        equ 18h    ; MASK: Set Sleep timer freq/period
 0000           OSC_CR0_SLEEP_512Hz:  equ 00h    ;     Set sleep bits for 1.95ms period
 0008           OSC_CR0_SLEEP_64Hz:   equ 08h    ;     Set sleep bits for 15.6ms period
 0010           OSC_CR0_SLEEP_8Hz:    equ 10h    ;     Set sleep bits for 125ms period
 0018           OSC_CR0_SLEEP_1Hz:    equ 18h    ;     Set sleep bits for 1 sec period
 0007           OSC_CR0_CPU:          equ 07h    ; MASK: Set CPU Frequency
 0000           OSC_CR0_CPU_3MHz:     equ 00h    ;     set CPU Freq bits for 3MHz Operation
 0001           OSC_CR0_CPU_6MHz:     equ 01h    ;     set CPU Freq bits for 6MHz Operation
 0002           OSC_CR0_CPU_12MHz:    equ 02h    ;     set CPU Freq bits for 12MHz Operation
 0003           OSC_CR0_CPU_24MHz:    equ 03h    ;     set CPU Freq bits for 24MHz Operation
 0004           OSC_CR0_CPU_1d5MHz:   equ 04h    ;     set CPU Freq bits for 1.5MHz Operation
 0005           OSC_CR0_CPU_750kHz:   equ 05h    ;     set CPU Freq bits for 750kHz Operation
 0006           OSC_CR0_CPU_187d5kHz: equ 06h    ;     set CPU Freq bits for 187.5kHz Operation
 0007           OSC_CR0_CPU_93d7kHz:  equ 07h    ;     set CPU Freq bits for 93.7kHz Operation
 0000           
 00E1           OSC_CR1:      equ E1h          ; System VC1/VC2 Divider Control Register  (RW)
 00F0           OSC_CR1_VC1:          equ F0h    ; MASK: System VC1 24MHz/External Clk divider
 000F           OSC_CR1_VC2:          equ 0Fh    ; MASK: System VC2 24MHz/External Clk divider
 0000           
 00E2           OSC_CR2:      equ E2h          ; Oscillator Control Register 2            (RW)
 0080           OSC_CR2_PLLGAIN:      equ 80h    ; MASK: High/Low gain
 0004           OSC_CR2_EXTCLKEN:     equ 04h    ; MASK: Enable/Disable External Clock
 0002           OSC_CR2_IMODIS:       equ 02h    ; MASK: Enable/Disable System (IMO) Clock Net
 0001           OSC_CR2_SYSCLKX2DIS:  equ 01h    ; MASK: Enable/Disable 48MHz clock source
 0000           
 00E3           VLT_CR:       equ E3h          ; Voltage Monitor Control Register         (RW)
 0080           VLT_CR_SMP:           equ 80h    ; MASK: Enable Switch Mode Pump
 0030           VLT_CR_PORLEV:        equ 30h    ; MASK: Mask for Power on Reset level control
 0000           VLT_CR_POR_LOW:       equ 00h    ;   Lowest  Precision Power-on Reset trip point
 0010           VLT_CR_POR_MID:       equ 10h    ;   Middle  Precision Power-on Reset trip point
 0020           VLT_CR_POR_HIGH:      equ 20h    ;   Highest Precision Power-on Reset trip point
 0008           VLT_CR_LVDTBEN:       equ 08h    ; MASK: Enable the CPU Throttle Back on LVD
 0007           VLT_CR_VM:            equ 07h    ; MASK: Mask for Voltage Monitor level setting
 0000           
 00E4           VLT_CMP:      equ E4h          ; Voltage Monitor Comparators Register     (R)
 0004           VLT_CMP_PUMP:         equ 04h    ; MASK: Vcc below SMP trip level
 0002           VLT_CMP_LVD:          equ 02h    ; MASK: Vcc below LVD trip level
 0001           VLT_CMP_PPOR:         equ 01h    ; MASK: Vcc below PPOR trip level
 0000           
 00E7           DEC_CR2:      equ E7h          ; Data Control Register 2                  (RW)
 0000           
 00E8           IMO_TR:               equ E8h    ; Internal Main Oscillator Trim Register   (RW)
 00E9           ILO_TR:               equ E9h    ; Internal Low-speed Oscillator Trim       (W)
 00EA           BDG_TR:               equ EAh    ; Band Gap Trim Register                   (RW)
 00EB           ECO_TR:               equ EBh    ; External Oscillator Trim Register        (W)
 00EF           IMO_TR2:              equ EFh    ; Internal Main Oscillator Gain Trim Register (RW)
 0000           
 00FD           DAC_CR:       equ FDh          ; DAC Control Register                     (RW)
 0080           DAC_CR_SPLIT_MUX:     equ 80h    ; MASK: enable/disable Splitting of AMuxBuses
 0040           DAC_CR_MUXCLK_GE:     equ 40h    ; MASK: Connect/Disconnect AMuxBus to GOO[6]
 0008           DAC_CR_RANGE:	       equ 08h    ; MASK: High Range/Low Range
 0006           DAC_CR_OSCMODE:	    equ 06h    ; MASK: Sets Reset Mode for AMuxBus
 0001           DAC_CR_ENABLE:        equ 01h    ; MASK: enable/disable AMux Bus
 0000           
 0000           
 0000           ;;=============================================================================
 0000           ;;      M8C System Macros
 0000           ;;  These macros should be used when their functions are needed.
 0000           ;;=============================================================================
 0000           
 0000           ;----------------------------------------------------
 0000           ;  Swapping Register Banks
 0000           ;----------------------------------------------------
 0000               macro M8C_SetBank0
 0000               and   F, ~FLAG_XIO_MASK
 0000               macro M8C_SetBank1
 0000               or    F, FLAG_XIO_MASK
 0000               macro M8C_EnableGInt
 0000               or    F, FLAG_GLOBAL_IE
 0000               macro M8C_DisableGInt
 0000               and   F, ~FLAG_GLOBAL_IE
 0000               macro M8C_DisableIntMask
 0000               and   reg[@0], ~@1              ; disable specified interrupt enable bit
 0000               macro M8C_EnableIntMask
 0000               or    reg[@0], @1               ; enable specified interrupt enable bit
 0000               macro M8C_ClearIntFlag
 0000               mov   reg[@0], ~@1              ; clear specified interrupt enable bit
 0000               macro M8C_EnableWatchDog
 0000               and   reg[CPU_SCR0], ~CPU_SCR0_PORS_MASK
 0000               macro M8C_ClearWDT
 0000               mov   reg[RES_WDT], 00h
 0000               macro M8C_ClearWDTAndSleep
 0000               mov   reg[RES_WDT], 38h
 0000               macro M8C_Stall
 0000               or    reg[ASY_CR], ASY_CR_SYNCEN
 0000               macro M8C_Unstall
 0000               and   reg[ASY_CR], ~ASY_CR_SYNCEN
 0000               macro M8C_Sleep
 0000               or    reg[CPU_SCR0], CPU_SCR0_SLEEP_MASK
 0000               ; The next instruction to be executed depends on the state of the
 0000               ; various interrupt enable bits. If some interrupts are enabled
 0000               ; and the global interrupts are disabled, the next instruction will
 0000               ; be the one that follows the invocation of this macro. If global
 0000               ; interrupts are also enabled then the next instruction will be
 0000               ; from the interrupt vector table. If no interrupts are enabled
 0000               ; then the CPU sleeps forever.
 0000               macro M8C_Stop
 0000               ; In general, you probably don't want to do this, but here's how:
 0000               or    reg[CPU_SCR0], CPU_SCR0_STOP_MASK
 0000               ; Next instruction to be executed is located in the interrupt
 0000               ; vector table entry for Power-On Reset.
 0000               macro M8C_Reset
 0000               ; Restore CPU to the power-on reset state.
 0000               mov A, 0
 0000               SSC
 0000               ; Next non-supervisor instruction will be at interrupt vector 0.
 0000               macro Suspend_CodeCompressor
 0000               or   F, 0
 0000               macro Resume_CodeCompressor
 0000               add  SP, 0
 0005           LED7SEG_1_SegmentPort:    equ   0x5
 0000           LED7SEG_1_DigitPort:      equ   0x0
 00FF           LED7SEG_1_DigitMask:      equ   (0x8ff & 0x00FF )
 0000           
 0000           
 0000           LED7SEG_1_DigitPortDR:    equ   PRT0DR
 0000           LED7SEG_1_DigitPortDM0:   equ   PRT0DM0
 0001           LED7SEG_1_DigitPortDM1:   equ   PRT0DM1
 0003           LED7SEG_1_DigitPortDM2:   equ   PRT0DM2
 0000           
 0014           LED7SEG_1_SegmentPortDR:  equ   PRT5DR
 0014           LED7SEG_1_SegmentPortDM0: equ   PRT5DM0
 0015           LED7SEG_1_SegmentPortDM1: equ   PRT5DM1
 0017           LED7SEG_1_SegmentPortDM2: equ   PRT5DM2
 0000           
 0000           
 0008           LED7SEG_1_DigitCnt:       equ   ((0x8ff>>8)&0x0F)
 0010           LED7SEG_1_DigitDimCnt:    equ   (LED7SEG_1_DigitCnt<<1)
 0001           LED7SEG_1_DigitDrive:     equ   1
 0001           LED7SEG_1_SegmentDrive:   equ   1
 0000           LED7SEG_1_FirstDigit:     equ   ((0x8ff>>12)&0x0F)
 0000           
 0000           
 0001           LED7SEG_1_TIMER_PRESENT:  equ   1
 0000           
 0000           
                IF(1)                      // Active High Digit Drive
 FFFFFF00           LED7SEG_1_DigitOff:       equ   ~LED7SEG_1_DigitMask
                ELSE                                   // Active Low Digit Drive
                LED7SEG_1_DigitOff:       equ   LED7SEG_1_DigitMask
                ENDIF
                
                // Initial segment pattern
 0000           LED7SEG_1_SegmentInit:    equ   0x00
 0000           
 0000           LED7SEG_1_DigitShadow:    equ  Port_0_Data_SHADE
 0000           
 0080           LED7SEG_1_ScanFlag:       equ   0x80      // If set, scan
 0040           LED7SEG_1_DimEnable:      equ   0x40      // Dim Enable  
 0020           LED7SEG_1_DimFlag:        equ   0x20      // If set, Blanking 
 0060           LED7SEG_1_DimNow:         equ   0x60      // If set, Blank this sequence
 0000           
 000F           LED7SEG_1_CntMask:        equ   0x0F      // Digit count mask
 0000           
 0000           
 0001           LED7SEG_1_Dig1Mask:    equ   (0x01<<(LED7SEG_1_FirstDigit+0))
 0002           LED7SEG_1_Dig2Mask:    equ   (0x01<<(LED7SEG_1_FirstDigit+1))
 0004           LED7SEG_1_Dig3Mask:    equ   (0x01<<(LED7SEG_1_FirstDigit+2))
 0008           LED7SEG_1_Dig4Mask:    equ   (0x01<<(LED7SEG_1_FirstDigit+3))
 0010           LED7SEG_1_Dig5Mask:    equ   (0x01<<(LED7SEG_1_FirstDigit+4))
 0020           LED7SEG_1_Dig6Mask:    equ   (0x01<<(LED7SEG_1_FirstDigit+5))
 0040           LED7SEG_1_Dig7Mask:    equ   (0x01<<(LED7SEG_1_FirstDigit+6))
 0080           LED7SEG_1_Dig8Mask:    equ   (0x01<<(LED7SEG_1_FirstDigit+7))
 0000           
 0000           
 0000           ;------------------------------------------------------
 0000           ;  The following is valid only if timer is present.
 0000           ;------------------------------------------------------
                IF (LED7SEG_1_TIMER_PRESENT)
 0001           LED7SEG_1_CONTROL_REG_START_BIT:           equ 0x01    ; Control register start bit
 00E1           LED7SEG_1_INT_REG:                         equ 0x0e1
 0004           LED7SEG_1_INT_MASK:                        equ 0x04
 002B           LED7SEG_1_CONTROL_REG:                     equ 0x2b   ; Control register
 0000            
                ENDIF
                
                ;------------------------------------------------------
                ;  Register Address Constants for  LED7SEG_1
                ;------------------------------------------------------
                
                ;------------------------------------------------------
                ;  Macros for  LED7SEG_1
                ;------------------------------------------------------
                
                
                
                
                
                ; end of file LED7SEG_1.inc
 0003           SYSTEM_STACK_PAGE: equ 3   
 0000           SYSTEM_STACK_BASE_ADDR: equ 0h   
 0001           SYSTEM_LARGE_MEMORY_MODEL: equ 1   
 0000           SYSTEM_SMALL_MEMORY_MODEL: equ 0   
 0001           SYSTEM_TOOLS: equ 1   
 0001           SYSTEM_IDXPG_TRACKS_STK_PP: equ 1   
 0000           SYSTEM_IDXPG_TRACKS_IDX_PP: equ 0   
 0000           SYSTEM_MULTIPAGE_STACK: equ 0 
 0000           
 0000           
 0000           ;  ******* Function Class Definitions *******
 0000           ;
 0000           ;  These definitions are used to describe RAM access patterns. They provide
 0000           ;  documentation and they control prologue and epilogue macros that perform
 0000           ;  the necessary housekeeping functions for large memory model devices like
 0000           ;  the CY8C24x94 and CY8C29x66.
 0000           
 0001           RAM_USE_CLASS_1:               equ 1   ; PUSH, POP & I/O access
 0002           RAM_USE_CLASS_2:               equ 2   ; Indexed address mode on stack page
 0004           RAM_USE_CLASS_3:               equ 4   ; Indexed address mode to any page
 0008           RAM_USE_CLASS_4:               equ 8   ; Direct/Indirect address mode access
 0000           
 0000           
 0000           ;  ******* Page Pointer Manipulation Macros *******
 0000           ;
 0000           ;  Most of the following macros are conditionally compiled so they only
 0000           ;  produce code if the large memory model is selected.
 0000           
 0000              ;-----------------------------------------------
 0000              ;  Set Stack Page Macro
 0000              ;-----------------------------------------------
 0000              ;
 0000              ;  DESC: Modify STK_PP in the large or small memory Models.
 0000              ;
 0000              ; INPUT: Constant (e.g., SYSTEM_STACK_PAGE) that specifies the RAM page on
 0000              ;        which stack operations like PUSH and POP store and retrieve their
 0000              ;        data
 0000              ;
 0000              ;  COST: 8 instruction cycles (in LMM only)
 0000           
 0000              macro RAM_SETPAGE_STK( PG_NUMBER )
 0000              IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0000                 mov reg[STK_PP], @PG_NUMBER
 0000              ENDIF
 0000              macro RAM_SETPAGE_CUR( PG_NUMBER )
 0000              IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0000                 mov reg[CUR_PP], @PG_NUMBER
 0000              ENDIF
 0000              macro RAM_SETPAGE_IDX( PG_NUMBER )
 0000              IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0000                 mov reg[IDX_PP], @PG_NUMBER
 0000              ENDIF
 0000              macro RAM_SETPAGE_MVR( PG_NUMBER )
 0000              IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0000                 mov reg[MVR_PP], @PG_NUMBER
 0000              ENDIF
 0000              macro RAM_SETPAGE_MVW( PG_NUMBER )
 0000              IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0000                 mov reg[MVW_PP], @PG_NUMBER
 0000              ENDIF
 0000              macro RAM_SETPAGE_IDX2STK
 0000              IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0000                 IF ( SYSTEM_MULTIPAGE_STACK )
 0000                    mov   A, reg[STK_PP]
 0000                    mov   reg[IDX_PP], A
 0000                 ELSE
 0000                    RAM_SETPAGE_IDX SYSTEM_STACK_PAGE
 0000                 ENDIF
 0000              ENDIF
 0000              macro RAM_CHANGE_PAGE_MODE( MODE )
 0000              IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0000                 and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
 0000                 or    F,  FLAG_PGMODE_MASK & @MODE
 0000              ENDIF
 0000              macro RAM_SET_NATIVE_PAGING
 0000              IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0000              IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
 0000                 or    F,  FLAG_PGMODE_11b            ; LMM w/ IndexPage<==>StackPage
 0000              ENDIF ;  PGMODE LOCKED
 0000              IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
 0000                 or    F,  FLAG_PGMODE_10b            ; LMM with independent IndexPage
 0000              ENDIF ; PGMODE FREE
 0000              ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
 0000              macro RAM_RESTORE_NATIVE_PAGING
 0000              IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0000              IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
 0000                 RAM_CHANGE_PAGE_MODE FLAG_PGMODE_11b ; LMM w/ IndexPage<==>StackPage
 0000              ENDIF ;  PGMODE LOCKED
 0000              IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
 0000                 RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b ; LMM with independent IndexPage
 0000              ENDIF ; PGMODE FREE
 0000              ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
 0000              macro RAM_X_POINTS_TO_STACKPAGE
 0000              IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0000                 or   F, FLAG_PGMODE_01b
 0000              ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
 0000              macro RAM_X_POINTS_TO_INDEXPAGE
 0000              IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0000                 and  F, ~FLAG_PGMODE_01b
 0000              ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
 0000              macro RAM_PROLOGUE( ACTUAL_CLASS )
 0000           
 0000              IF ( @ACTUAL_CLASS & RAM_USE_CLASS_1 )
 0000              ; Nothing to do
 0000              ENDIF ; RAM_USE_CLASS_1
 0000           
 0000              IF ( @ACTUAL_CLASS & RAM_USE_CLASS_2 )
 0000                 IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
 0000                    RAM_X_POINTS_TO_STACKPAGE         ; exit native paging mode!
 0000                 ENDIF
 0000              ENDIF ; RAM_USE_CLASS_2
 0000           
 0000              IF ( @ACTUAL_CLASS & RAM_USE_CLASS_3 )
 0000                 IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
 0000                    RAM_X_POINTS_TO_INDEXPAGE         ; exit native paging mode!
 0000                 ENDIF
 0000              ENDIF ; RAM_USE_CLASS_3
 0000           
 0000              IF ( @ACTUAL_CLASS & RAM_USE_CLASS_4 )
 0000              ; Nothing to do
 0000              ENDIF ; RAM_USE_CLASS_4
 0000           
 0000              macro RAM_EPILOGUE( ACTUAL_CLASS )
 0000           
 0000              IF ( @ACTUAL_CLASS & RAM_USE_CLASS_1 )
 0000              ; Nothing to do
 0000              ENDIF ; RAM_USE_CLASS_1
 0000           
 0000              IF ( @ACTUAL_CLASS & RAM_USE_CLASS_2 )
 0000                 RAM_RESTORE_NATIVE_PAGING
 0000              ENDIF ; RAM_USE_CLASS_2
 0000           
 0000              IF ( @ACTUAL_CLASS & RAM_USE_CLASS_3 )
 0000                 RAM_RESTORE_NATIVE_PAGING
 0000              ENDIF ; RAM_USE_CLASS_3
 0000           
 0000              IF ( @ACTUAL_CLASS & RAM_USE_CLASS_4 )
 0000              ; Nothing to do
 0000              ENDIF ; RAM_USE_CLASS_4
 0000           
 0000              macro REG_PRESERVE( IOReg )
 0000              mov   A, reg[ @IOReg ]
 0000              push  A
 0000              macro REG_RESTORE( IOReg )
 0000              pop   A
 0000              mov   reg[ @IOReg ], A
 0000              macro ISR_PRESERVE_PAGE_POINTERS
 0000              IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0000                 REG_PRESERVE CUR_PP
 0000                 REG_PRESERVE IDX_PP
 0000                 REG_PRESERVE MVR_PP
 0000                 REG_PRESERVE MVW_PP
 0000              ENDIF
 0000              macro ISR_RESTORE_PAGE_POINTERS
 0000              IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0000                 REG_RESTORE MVW_PP
 0000                 REG_RESTORE MVR_PP
 0000                 REG_RESTORE IDX_PP
 0000                 REG_RESTORE CUR_PP
 0000              ENDIF
                export _LED7SEG_1_Start
                export  LED7SEG_1_Start
                
                export _LED7SEG_1_Stop
                export  LED7SEG_1_Stop
                
                export _LED7SEG_1_Dim
                export  LED7SEG_1_Dim
                
                export _LED7SEG_1_Update
                export  LED7SEG_1_Update
                
                export _LED7SEG_1_PutHex
                export  LED7SEG_1_PutHex
                
                export _LED7SEG_1_PutPattern
                export  LED7SEG_1_PutPattern
                
                export _LED7SEG_1_DP
                export  LED7SEG_1_DP
                
                export _LED7SEG_1_DispInt 
                export  LED7SEG_1_DispInt
                
                export  LED7SEG_1_DigitRAM
                export _LED7SEG_1_DigitRAM
                
                export  LED7SEG_1_ScanStatus
                export _LED7SEG_1_ScanStatus
                
                area InterruptRAM(RAM, REL, CON)
                
 0000            LED7SEG_1_VarPage:                              ; Dummy label for paging
 0000           
 0000            LED7SEG_1_ScanStatus:
 0000           _LED7SEG_1_ScanStatus:                       blk      1
 0001           
 0001            LED7SEG_1_DigitRAM:
 0001           _LED7SEG_1_DigitRAM:                         blk      LED7SEG_1_DigitCnt
 0009           
                AREA UserModules (ROM, REL)
                
                ;; 
                ;;  char dp g f e   d c b a    Code  Code
                ;;   0    0 0 1 1   1 1 1 1    0x3F  0xC0
                ;;   1    0 0 0 0   0 1 1 0    0x06  0xF9
                ;;   2    0 1 0 1   1 0 1 1    0x5B  0xA4
                ;;   3    0 1 0 0   1 1 1 1    0x4F  0xB0
                ;;   4    0 1 1 0   0 1 1 0    0x66  0x99
                ;;   5    0 1 1 0   1 1 0 1    0x6D  0x92
                ;;   6    0 1 1 1   1 1 0 1    0x7D  0x82
                ;;   7    0 0 0 0   0 1 1 1    0x07  0xF8
                ;;   8    0 1 1 1   1 1 1 1    0x7F  0x80
                ;;   9    0 1 1 0   1 1 1 1    0x6F  0x90
                ;;   A    0 1 1 1   0 1 1 1    0x77  0x88
                ;;   b    0 1 1 1   1 1 0 0    0x7C  0x83
                ;;   C    0 0 1 1   1 0 0 1    0x39  0xC6
                ;;   d    0 1 0 1   1 1 1 0    0x5E  0xA1
                ;;   E    0 1 1 1   1 0 0 1    0x79  0x86
                ;;   F    0 1 1 1   0 0 0 1    0x71  0x8E
                ;;   -    0 1 0 0   0 0 0 0    0x40  0xBF
                
                
                
 0000           .LITERAL
 0000            LED7SEG_1_HexSegMask:
 0000           
 0000 3F065B4F666D7D07      DB   0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07
 0008 7F6F777C395E7971      DB   0x7F, 0x6F, 0x77, 0x7C, 0x39, 0x5E, 0x79, 0x71
 0010 40             DB   0x40
 0011           
 0011           
 0011            LED7SEG_1_DigitPortMask:
                IF(LED7SEG_1_DigitDrive)  // Active High Digit Drive
 0011 01             DB   LED7SEG_1_Dig1Mask
 0012 02             DB   LED7SEG_1_Dig2Mask
 0013 04             DB   LED7SEG_1_Dig3Mask
 0014 08             DB   LED7SEG_1_Dig4Mask
 0015 10             DB   LED7SEG_1_Dig5Mask
 0016 20             DB   LED7SEG_1_Dig6Mask
 0017 40             DB   LED7SEG_1_Dig7Mask
 0018 80             DB   LED7SEG_1_Dig8Mask
                ELSE                             // Active Low Digit Drive
                     DB   ~LED7SEG_1_Dig1Mask
                     DB   ~LED7SEG_1_Dig2Mask
                     DB   ~LED7SEG_1_Dig3Mask
                     DB   ~LED7SEG_1_Dig4Mask
                     DB   ~LED7SEG_1_Dig5Mask
                     DB   ~LED7SEG_1_Dig6Mask
                     DB   ~LED7SEG_1_Dig7Mask
                     DB   ~LED7SEG_1_Dig8Mask
                ENDIF
                
                
 0019           DEC_TABLE:   ; Used for base10 display
 0019 0001000A006403E82710 DW 0x0001, 0x000A, 0x0064, 0x03E8, 0x2710
 0023           ;    1       10     100     1000   10,000
 0023           
 0023           .ENDLITERAL
 0023           
 0023           .SECTION
 0023           ;-----------------------------------------------------------------------------
 0023           ;  FUNCTION NAME: LED7SEG_1_Start(void)
 0023           ;
 0023           ;  DESCRIPTION:
 0023           ;     Init state machine and clear buffer memory
 0023           ;
 0023           ;-----------------------------------------------------------------------------
 0023           ;
 0023           ;  ARGUMENTS:
 0023           ;    none
 0023           ;
 0023           ;  RETURNS:  none
 0023           ;
 0023           ;  SIDE EFFECTS:
 0023           ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
 0023           ;
 0023           ;-----------------------------------------------------------------------------
 0023           _LED7SEG_1_Start:
 0023            LED7SEG_1_Start:
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_1 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_1
                
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_2 )
                      IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      or   F, FLAG_PGMODE_01b
                   ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                      ENDIF
                   ENDIF ; RAM_USE_CLASS_2
                
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_3 )
                      IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0023 70BF            and  F, ~FLAG_PGMODE_01b
                   ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                      ENDIF
                   ENDIF ; RAM_USE_CLASS_3
                
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_4 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_4
                
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_1 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_1
                
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_2 )
                      IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      or   F, FLAG_PGMODE_01b
                   ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                      ENDIF
                   ENDIF ; RAM_USE_CLASS_2
                
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_3 )
                      IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and  F, ~FLAG_PGMODE_01b
                   ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                      ENDIF
                   ENDIF ; RAM_USE_CLASS_3
                
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_4 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_4
                
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0025 62D300          mov reg[IDX_PP], >LED7SEG_1_VarPage
                   ENDIF
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0028 62D000          mov reg[CUR_PP], >LED7SEG_1_VarPage
                   ENDIF
 002B 10           push   X
 002C              ; Initialize digit RAM
 002C 5707         mov    X,(LED7SEG_1_DigitCnt-1)
 002E           .ClearLoop:
 002E 560100       mov    [X+LED7SEG_1_DigitRAM],LED7SEG_1_SegmentInit
 0031 79           dec    X
 0032 DFFB         jnc    .ClearLoop
 0034           
 0034              ; Set scan bit
 0034 550080       mov   [LED7SEG_1_ScanStatus],LED7SEG_1_ScanFlag  
 0037           
 0037           
 0037 7110          or    F, FLAG_XIO_MASK
 0039 4300FF       or    reg[LED7SEG_1_DigitPortDM0],LED7SEG_1_DigitMask
 003C 410100       and   reg[LED7SEG_1_DigitPortDM1],~LED7SEG_1_DigitMask
 003F 70EF          and   F, ~FLAG_XIO_MASK
 0041 410300       and   reg[LED7SEG_1_DigitPortDM2],~LED7SEG_1_DigitMask
 0044           
 0044 20           pop   X
 0045           
                IF (LED7SEG_1_TIMER_PRESENT)
 0045 432B01       or    reg[LED7SEG_1_CONTROL_REG],  LED7SEG_1_CONTROL_REG_START_BIT
 0048 43E104        or    reg[LED7SEG_1_INT_REG], LED7SEG_1_INT_MASK               ; enable specified interrupt enable bit
                ENDIF
                
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_1 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_1
                
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_2 )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                   IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_11b
                   ENDIF
                   ENDIF ;  PGMODE LOCKED
                   IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_10b
                   ENDIF
                   ENDIF ; PGMODE FREE
                   ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                   ENDIF ; RAM_USE_CLASS_2
                
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_3 )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                   IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_11b
                   ENDIF
                   ENDIF ;  PGMODE LOCKED
                   IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_10b
                   ENDIF
                   ENDIF ; PGMODE FREE
                   ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                   ENDIF ; RAM_USE_CLASS_3
                
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_4 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_4
                
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_1 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_1
                
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_2 )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                   IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_11b
                   ENDIF
                   ENDIF ;  PGMODE LOCKED
                   IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_10b
                   ENDIF
                   ENDIF ; PGMODE FREE
                   ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                   ENDIF ; RAM_USE_CLASS_2
                
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_3 )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                   IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
 004B 703F            and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
 004D 71C0            or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_11b
                   ENDIF
                   ENDIF ;  PGMODE LOCKED
                   IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_10b
                   ENDIF
                   ENDIF ; PGMODE FREE
                   ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                   ENDIF ; RAM_USE_CLASS_3
                
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_4 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_4
                
 004F 7F           ret
 0050           .ENDSECTION
 0050           
 0050           
 0050           .SECTION
 0050           ;-----------------------------------------------------------------------------
 0050           ;  FUNCTION NAME: LED7SEG_1_Stop(void)
 0050           ;
 0050           ;  DESCRIPTION:
 0050           ;     Stops scanning and turn off all digits
 0050           ;
 0050           ;-----------------------------------------------------------------------------
 0050           ;
 0050           ;  ARGUMENTS:
 0050           ;    none
 0050           ;
 0050           ;  RETURNS:  none
 0050           ;
 0050           ;  SIDE EFFECTS:
 0050           ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
 0050           ;
 0050           ;-----------------------------------------------------------------------------
 0050           _LED7SEG_1_Stop:
 0050            LED7SEG_1_Stop:
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_1 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_1
                
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_2 )
                      IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      or   F, FLAG_PGMODE_01b
                   ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                      ENDIF
                   ENDIF ; RAM_USE_CLASS_2
                
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_3 )
                      IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and  F, ~FLAG_PGMODE_01b
                   ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                      ENDIF
                   ENDIF ; RAM_USE_CLASS_3
                
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_4 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_4
                
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0050 62D000          mov reg[CUR_PP], >LED7SEG_1_VarPage
                   ENDIF
                
 0053 08           push A
 0054              ; Turn off scan
 0054 550000       mov   [LED7SEG_1_ScanStatus],0x00 
 0057           
 0057              ; Turn off all digits
                IF(1)                                            ; Active High Digit Drive
 0057 260000       and  [Port_0_Data_SHADE],~LED7SEG_1_DigitMask
                ELSE                                             ; Active Low Digit Drive
                   or   [Port_0_Data_SHADE],LED7SEG_1_DigitMask
                ENDIF
 005A 5100         mov  A,[Port_0_Data_SHADE]    
 005C 6000         mov  reg[LED7SEG_1_DigitPortDR],A
 005E 18           pop  A
 005F           
                IF (LED7SEG_1_TIMER_PRESENT)
 005F 41E1FB        and   reg[LED7SEG_1_INT_REG], ~LED7SEG_1_INT_MASK              ; disable specified interrupt enable bit
 0062 412BFE       and   reg[LED7SEG_1_CONTROL_REG], ~LED7SEG_1_CONTROL_REG_START_BIT
                ENDIF
                
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_1 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_1
                
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_2 )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                   IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_11b
                   ENDIF
                   ENDIF ;  PGMODE LOCKED
                   IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_10b
                   ENDIF
                   ENDIF ; PGMODE FREE
                   ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                   ENDIF ; RAM_USE_CLASS_2
                
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_3 )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                   IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_11b
                   ENDIF
                   ENDIF ;  PGMODE LOCKED
                   IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_10b
                   ENDIF
                   ENDIF ; PGMODE FREE
                   ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                   ENDIF ; RAM_USE_CLASS_3
                
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_4 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_4
                
 0065 7F           ret
 0066           .ENDSECTION
 0066           
 0066           
 0066           
 0066           .SECTION
 0066           ;-----------------------------------------------------------------------------
 0066           ;  FUNCTION NAME: LED7SEG_1_Dim(Byte bDim)
 0066           ;
 0066           ;  DESCRIPTION:
 0066           ;     Init state machine and clear buffer memory
 0066           ;
 0066           ;-----------------------------------------------------------------------------
 0066           ;
 0066           ;  ARGUMENTS:
 0066           ;    A => bDim   ( Dim Off = 0,  Dim On = 1)
 0066           ;
 0066           ;  RETURNS:  none
 0066           ;
 0066           ;  SIDE EFFECTS:
 0066           ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
 0066           ;
 0066           ;-----------------------------------------------------------------------------
 0066           _LED7SEG_1_Dim:
 0066            LED7SEG_1_Dim:
 0066             
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_1 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_1
                
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_2 )
                      IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      or   F, FLAG_PGMODE_01b
                   ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                      ENDIF
                   ENDIF ; RAM_USE_CLASS_2
                
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_3 )
                      IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and  F, ~FLAG_PGMODE_01b
                   ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                      ENDIF
                   ENDIF ; RAM_USE_CLASS_3
                
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_4 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_4
                
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0066 62D000          mov reg[CUR_PP], >LED7SEG_1_VarPage
                   ENDIF
                
 0069 2101         and    A,0x01
 006B A005         jz     .DimOff
 006D           
 006D           .DimOn:
 006D 2E0040       or     [LED7SEG_1_ScanStatus],LED7SEG_1_DimEnable
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_1 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_1
                
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_2 )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                   IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_11b
                   ENDIF
                   ENDIF ;  PGMODE LOCKED
                   IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_10b
                   ENDIF
                   ENDIF ; PGMODE FREE
                   ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                   ENDIF ; RAM_USE_CLASS_2
                
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_3 )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                   IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_11b
                   ENDIF
                   ENDIF ;  PGMODE LOCKED
                   IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_10b
                   ENDIF
                   ENDIF ; PGMODE FREE
                   ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                   ENDIF ; RAM_USE_CLASS_3
                
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_4 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_4
                
 0070 7F           ret
 0071           
 0071           .DimOff:
 0071 2600BF       and    [LED7SEG_1_ScanStatus],~LED7SEG_1_DimEnable
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_1 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_1
                
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_2 )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                   IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_11b
                   ENDIF
                   ENDIF ;  PGMODE LOCKED
                   IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_10b
                   ENDIF
                   ENDIF ; PGMODE FREE
                   ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                   ENDIF ; RAM_USE_CLASS_2
                
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_3 )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                   IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_11b
                   ENDIF
                   ENDIF ;  PGMODE LOCKED
                   IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_10b
                   ENDIF
                   ENDIF ; PGMODE FREE
                   ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                   ENDIF ; RAM_USE_CLASS_3
                
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_4 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_4
                
 0074 7F           ret
 0075           
 0075           .ENDSECTION
 0075           
 0075           .SECTION
 0075           ;-----------------------------------------------------------------------------
 0075           ;  FUNCTION NAME: LED7SEG_1_Update(void)
 0075           ;
 0075           ;  DESCRIPTION:
 0075           ;     Advance and display next digit from array.  This function is designed
 0075           ;     to be called from an ISR, although it could be called in the mainline
 0075           ;     of your program.
 0075           ;
 0075           ;     To call this function from a non Large Memory Model (LMM) device,
 0075           ;     in an ISR use the following.
 0075           ;
 0075           ;     lcall LED7SEG_1_Update
 0075           ;
 0075           ;     If using a LMM part, and calling from an ISR, make sure the processor
 0075           ;     is either in page mode 0, or in native page mode.  
 0075           ;
 0075           ;-----------------------------------------------------------------------------
 0075           ;
 0075           ;  ARGUMENTS:
 0075           ;    none
 0075           ;
 0075           ;  RETURNS:  none
 0075           ;
 0075           ;  SIDE EFFECTS:
 0075           ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
 0075           ;
 0075           ;  How It Works:
 0075           ;    *  Check if Scan is on
 0075           ;    *  Blank display, Turn off common drive
 0075           ;    *  Load Segment register
 0075           ;    *  Set proper digit, (Turn on common drive)
 0075           ;    *  Adance counter to next digit
 0075           ;-----------------------------------------------------------------------------
 0075           _LED7SEG_1_Update:
 0075            LED7SEG_1_Update:
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_1 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_1
                
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_2 )
                      IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      or   F, FLAG_PGMODE_01b
                   ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                      ENDIF
                   ENDIF ; RAM_USE_CLASS_2
                
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_3 )
                      IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and  F, ~FLAG_PGMODE_01b
                   ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                      ENDIF
                   ENDIF ; RAM_USE_CLASS_3
                
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_4 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_4
                
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_1 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_1
                
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_2 )
                      IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      or   F, FLAG_PGMODE_01b
                   ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                      ENDIF
                   ENDIF ; RAM_USE_CLASS_2
                
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_3 )
                      IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0075 70BF            and  F, ~FLAG_PGMODE_01b
                   ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                      ENDIF
                   ENDIF ; RAM_USE_CLASS_3
                
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_4 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_4
                
                
 0077 08           push  A
 0078 10           push  X
                   IF (SYSTEM_LARGE_MEMORY_MODEL)
 0079 5DD3         mov   A, reg[ IDX_PP ]
 007B 08           push  A
 007C 5DD0         mov   A, reg[ CUR_PP ]
 007E 08           push  A
                   ENDIF
                
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
 007F 62D300          mov reg[IDX_PP], >LED7SEG_1_VarPage
                   ENDIF
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0082 62D000          mov reg[CUR_PP], >LED7SEG_1_VarPage
                   ENDIF
                
 0085 470080       tst   [LED7SEG_1_ScanStatus],LED7SEG_1_ScanFlag  // Test if scanning is enabled
 0088 A03B         jz    .Update_End
 008A           
 008A              ; Turn off display briefly
                IF(1)                                            ; Active High Digit Drive
 008A 260000       and  [Port_0_Data_SHADE],~LED7SEG_1_DigitMask
                ELSE                                             ; Active Low Digit Drive
                   or   [Port_0_Data_SHADE],LED7SEG_1_DigitMask
                ENDIF
 008D 5100         mov   A,[Port_0_Data_SHADE]    
 008F 6000         mov   reg[LED7SEG_1_DigitPortDR],A
 0091           
 0091              ; Get the segment value, and write it to the segment port
 0091 5100         mov   A,[LED7SEG_1_ScanStatus]
 0093 210F         and   A,LED7SEG_1_CntMask                     ; Mask off all but scan position
 0095 4B           swap  A,X
 0096           
 0096              ; Check for Dim flag
 0096 470020       tst   [LED7SEG_1_ScanStatus],LED7SEG_1_DimFlag   ; If set skip update
 0099 B00E         jnz   .IncDigit
 009B           
 009B 5201         mov   A,[X+LED7SEG_1_DigitRAM]
 009D           
 009D           ; Invert here if Active Low segment drive
                IF(1)                                            ; Active Low Segment Drive
                   ; Do nothing
                ELSE
                   cpl   A
                ENDIF
 009D 6014         mov   reg[LED7SEG_1_SegmentPortDR],A
 009F           
 009F              ; Turn digit back on
 009F           
 009F 5B           mov   A,X                                     ; Copy index into A
 00A0 FF6F         index LED7SEG_1_DigitPortMask                 ; Digit mask into A
 00A2           
                IF(1)                                            ; Active High Digit Drive
 00A2 2C00         or   [Port_0_Data_SHADE],A
                ELSE                                             ; Active Low Digit Drive
                   and  [Port_0_Data_SHADE],A
                ENDIF
 00A4 5100         mov  A,[Port_0_Data_SHADE]
 00A6 6000         mov  reg[LED7SEG_1_DigitPortDR],A
 00A8           
 00A8           
 00A8              ; Calculate next digit
 00A8           .IncDigit:
 00A8 4B           swap  A,X                                     ; Put current digit into A
 00A9 74           inc   A                                       ; Advance to next
 00AA 7600         inc   [LED7SEG_1_ScanStatus]
 00AC 1108         sub   A,LED7SEG_1_DigitCnt
 00AE A005         jz    .Reset_Count
 00B0 D003         jnc   .Reset_Count
 00B2 8011         jmp   .Update_End
 00B4           
 00B4           .Reset_Count:
 00B4 2600F0       and   [LED7SEG_1_ScanStatus],~LED7SEG_1_CntMask    ; Reset count to zero  
 00B7 470040       tst   [LED7SEG_1_ScanStatus],LED7SEG_1_DimEnable   ; If set skip update
 00BA A006         jz    .Update_End_DimOff
 00BC 360020       xor   [LED7SEG_1_ScanStatus],LED7SEG_1_DimFlag   
 00BF 8004         jmp   .Update_End
 00C1           
 00C1           .Update_End_DimOff:                              ; Make sure Dim is off
 00C1 2600DF       and   [LED7SEG_1_ScanStatus],~LED7SEG_1_DimFlag    ; Make sure dim flag off
 00C4           
 00C4           .Update_End:
                   IF (SYSTEM_LARGE_MEMORY_MODEL)  
 00C4 18           pop   A
 00C5 60D0         mov   reg[ CUR_PP ], A
 00C7 18           pop   A
 00C8 60D3         mov   reg[ IDX_PP ], A
                   ENDIF
                
 00CA 20           pop   X
 00CB 18           pop   A
 00CC           .Update_Exit:
 00CC           
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_1 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_1
                
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_2 )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                   IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_11b
                   ENDIF
                   ENDIF ;  PGMODE LOCKED
                   IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_10b
                   ENDIF
                   ENDIF ; PGMODE FREE
                   ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                   ENDIF ; RAM_USE_CLASS_2
                
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_3 )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                   IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
 00CC 703F            and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
 00CE 71C0            or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_11b
                   ENDIF
                   ENDIF ;  PGMODE LOCKED
                   IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_10b
                   ENDIF
                   ENDIF ; PGMODE FREE
                   ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                   ENDIF ; RAM_USE_CLASS_3
                
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_4 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_4
                
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_1 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_1
                
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_2 )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                   IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_11b
                   ENDIF
                   ENDIF ;  PGMODE LOCKED
                   IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_10b
                   ENDIF
                   ENDIF ; PGMODE FREE
                   ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                   ENDIF ; RAM_USE_CLASS_2
                
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_3 )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                   IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_11b
                   ENDIF
                   ENDIF ;  PGMODE LOCKED
                   IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_10b
                   ENDIF
                   ENDIF ; PGMODE FREE
                   ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                   ENDIF ; RAM_USE_CLASS_3
                
                   IF ( RAM_USE_CLASS_4 & RAM_USE_CLASS_4 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_4
                
 00D0 7F           ret
 00D1           .ENDSECTION
 00D1           
 00D1           .SECTION
 00D1           ;-----------------------------------------------------------------------------
 00D1           ;  FUNCTION NAME: LED7SEG_1_PutHex(BYTE bValue, BYTE bDigit)
 00D1           ;
 00D1           ;  DESCRIPTION:
 00D1           ;     Write hex value to one of the digits
 00D1           ;
 00D1           ;-----------------------------------------------------------------------------
 00D1           ;
 00D1           ;  ARGUMENTS:
 00D1           ;    A => Value to display
 00D1           ;    X => Digit to update  ( 1 to n )
 00D1           ;
 00D1           ;  RETURNS:  none
 00D1           ;
 00D1           ;  SIDE EFFECTS:
 00D1           ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
 00D1           ;
 00D1           ;-----------------------------------------------------------------------------
 00D1           _LED7SEG_1_PutHex:
 00D1            LED7SEG_1_PutHex:
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_1 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_1
                
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_2 )
                      IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      or   F, FLAG_PGMODE_01b
                   ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                      ENDIF
                   ENDIF ; RAM_USE_CLASS_2
                
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_3 )
                      IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
 00D1 70BF            and  F, ~FLAG_PGMODE_01b
                   ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                      ENDIF
                   ENDIF ; RAM_USE_CLASS_3
                
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_4 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_4
                
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
 00D3 62D300          mov reg[IDX_PP], >LED7SEG_1_VarPage
                   ENDIF
                  
 00D6 FF28         index   LED7SEG_1_HexSegMask                  ; Get code
 00D8 79           dec     X                                     ; Dec to shift from (1 to N) to (0 to N-1)
 00D9 4B           swap    A,X                                   ; Code in X, index in A
 00DA 3908         cmp     A,(LED7SEG_1_DigitCnt)
 00DC D007         jnc     .putHex_End
 00DE           
 00DE 4B           swap    A,X                                   ; Code in A, index in X
 00DF 270180       and     [X+LED7SEG_1_DigitRAM],0x80
 00E2 2D01         or      [X+LED7SEG_1_DigitRAM],A
 00E4           .putHex_End:
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_1 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_1
                
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_2 )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                   IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_11b
                   ENDIF
                   ENDIF ;  PGMODE LOCKED
                   IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_10b
                   ENDIF
                   ENDIF ; PGMODE FREE
                   ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                   ENDIF ; RAM_USE_CLASS_2
                
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_3 )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                   IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
 00E4 703F            and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
 00E6 71C0            or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_11b
                   ENDIF
                   ENDIF ;  PGMODE LOCKED
                   IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_10b
                   ENDIF
                   ENDIF ; PGMODE FREE
                   ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                   ENDIF ; RAM_USE_CLASS_3
                
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_4 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_4
                
 00E8 7F           ret
 00E9           .ENDSECTION
 00E9           
 00E9           .SECTION
 00E9           ;-----------------------------------------------------------------------------
 00E9           ;  FUNCTION NAME: LED7SEG_1_PutPattern(BYTE bPattern, BYTE bDigit)
 00E9           ;
 00E9           ;  DESCRIPTION:
 00E9           ;     Write pattern to 7 segment display
 00E9           ;
 00E9           ;-----------------------------------------------------------------------------
 00E9           ;
 00E9           ;  ARGUMENTS:
 00E9           ;    A => Pattern to display
 00E9           ;    X => Digit to update  ( 1 to n )
 00E9           ;
 00E9           ;  RETURNS:  none
 00E9           ;
 00E9           ;  SIDE EFFECTS:
 00E9           ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
 00E9           ;
 00E9           ;-----------------------------------------------------------------------------
 00E9           _LED7SEG_1_PutPattern:
 00E9            LED7SEG_1_PutPattern:
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_1 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_1
                
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_2 )
                      IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      or   F, FLAG_PGMODE_01b
                   ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                      ENDIF
                   ENDIF ; RAM_USE_CLASS_2
                
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_3 )
                      IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
 00E9 70BF            and  F, ~FLAG_PGMODE_01b
                   ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                      ENDIF
                   ENDIF ; RAM_USE_CLASS_3
                
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_4 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_4
                
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
 00EB 62D300          mov reg[IDX_PP], >LED7SEG_1_VarPage
                   ENDIF
                  
 00EE 79           dec     X                                     ; Dec to shift from (1 to N) to (0 to N-1)
 00EF 4B           swap    A,X                                   ; Code in X, index in A
 00F0 3908         cmp     A,(LED7SEG_1_DigitCnt)
 00F2 D004         jnc     .putPat_End
 00F4           
 00F4 4B           swap    A,X                                   ; Code in A, index in X
 00F5 5401         mov     [X+LED7SEG_1_DigitRAM],A
 00F7           .putPat_End:
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_1 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_1
                
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_2 )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                   IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_11b
                   ENDIF
                   ENDIF ;  PGMODE LOCKED
                   IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_10b
                   ENDIF
                   ENDIF ; PGMODE FREE
                   ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                   ENDIF ; RAM_USE_CLASS_2
                
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_3 )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                   IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
 00F7 703F            and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
 00F9 71C0            or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_11b
                   ENDIF
                   ENDIF ;  PGMODE LOCKED
                   IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_10b
                   ENDIF
                   ENDIF ; PGMODE FREE
                   ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                   ENDIF ; RAM_USE_CLASS_3
                
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_4 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_4
                
 00FB 7F           ret
 00FC           .ENDSECTION
 00FC           
 00FC           .SECTION
 00FC           ;-----------------------------------------------------------------------------
 00FC           ;  FUNCTION NAME: LED7SEG_1_DP(BYTE bDpOnOff, BYTE bDigit)
 00FC           ;
 00FC           ;  DESCRIPTION:
 00FC           ;     Set the decimal point with the given mask.
 00FC           ;
 00FC           ;-----------------------------------------------------------------------------
 00FC           ;
 00FC           ;  ARGUMENTS:
 00FC           ;    A => DP ON/OFF (0 = DP Off, 1 = DP On)
 00FC           ;    X => Digit  (1 to N)
 00FC           ;
 00FC           ;  RETURNS:  none
 00FC           ;
 00FC           ;  SIDE EFFECTS:
 00FC           ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
 00FC           ;
 00FC           ;-----------------------------------------------------------------------------
 00FC           _LED7SEG_1_DP:
 00FC            LED7SEG_1_DP:
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_1 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_1
                
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_2 )
                      IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      or   F, FLAG_PGMODE_01b
                   ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                      ENDIF
                   ENDIF ; RAM_USE_CLASS_2
                
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_3 )
                      IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
 00FC 70BF            and  F, ~FLAG_PGMODE_01b
                   ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                      ENDIF
                   ENDIF ; RAM_USE_CLASS_3
                
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_4 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_4
                
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
 00FE 62D300          mov reg[IDX_PP], >LED7SEG_1_VarPage
                   ENDIF
 0101 79           dec    X                                      ; noramlize from 1 - N, to 0 to N-1
 0102 4B           swap   A,X
 0103 3908         cmp    A,(LED7SEG_1_DigitCnt)
 0105 D00E         jnc    .DP_End
 0107              
 0107 4B           swap   A,X
 0108 3900         cmp    A,0x00                                 ; Is flag set
 010A A006         jz     .DPOff
 010C           
 010C 2F0180       or     [X+LED7SEG_1_DigitRAM],0x80            ; Set DP
 010F 8004         jmp    .DP_End
 0111           .DPOff:
 0111 27017F       and    [X+LED7SEG_1_DigitRAM],0x7F            ; Clear DP
 0114           
 0114           .DP_End:
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_1 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_1
                
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_2 )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                   IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_11b
                   ENDIF
                   ENDIF ;  PGMODE LOCKED
                   IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_10b
                   ENDIF
                   ENDIF ; PGMODE FREE
                   ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                   ENDIF ; RAM_USE_CLASS_2
                
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_3 )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                   IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0114 703F            and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
 0116 71C0            or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_11b
                   ENDIF
                   ENDIF ;  PGMODE LOCKED
                   IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_10b
                   ENDIF
                   ENDIF ; PGMODE FREE
                   ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                   ENDIF ; RAM_USE_CLASS_3
                
                   IF ( RAM_USE_CLASS_3 & RAM_USE_CLASS_4 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_4
                
 0118 7F           ret
 0119           .ENDSECTION
 0119           
 0119           
 0119           .SECTION
 0119           ;-----------------------------------------------------------------------------
 0119           ;  FUNCTION NAME: LED7SEG_1_DispInt(int iValue, BYTE bPos, BYTE bLSD)
 0119           ;
 0119           ;  DESCRIPTION:
 0119           ;     Display integer on 7-Segment display
 0119           ;
 0119           ;-----------------------------------------------------------------------------
 0119           ;
 0119           ;  ARGUMENTS:
 0119           ;          [SP-3] => iValue[7:0]   Value to convert
 0119           ;          [SP-4] => iValue[15:8]  
 0119           ;          [SP-5] => bPos[7:0]     Digit starting position
 0119           ;          [SP-6] => bLSD[7:0]     Digits to display
 0119           ;
 0119           ;
 0119           ;  RETURNS:  none
 0119           ;
 0119           ;  SIDE EFFECTS:
 0119           ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
 0119           ;
 0119           ;-----------------------------------------------------------------------------
 0119           ;
 FFFFFFFD           DI_ValueLSB:   equ   -3
 FFFFFFFC           DI_ValueMSB:   equ   -4
 FFFFFFFB           DI_POS:        equ   -5
 FFFFFFFA           DI_LSD:        equ   -6
 0000           DI_DECPTR:     equ    0
 0001           DI_RESULT:     equ    1
 0002           DI_TMP:        equ    2
 0003           DI_STACKSIZE:  equ    3
 0119           
 0119           _LED7SEG_1_DispInt:
 0119            LED7SEG_1_DispInt:
                   IF ( RAM_USE_CLASS_2 & RAM_USE_CLASS_1 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_1
                
                   IF ( RAM_USE_CLASS_2 & RAM_USE_CLASS_2 )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                   IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0119 703F            and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
 011B 71C0            or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_11b
                   ENDIF
                   ENDIF ;  PGMODE LOCKED
                   IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_10b
                   ENDIF
                   ENDIF ; PGMODE FREE
                   ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                   ENDIF ; RAM_USE_CLASS_2
                
                   IF ( RAM_USE_CLASS_2 & RAM_USE_CLASS_3 )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                   IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_11b
                   ENDIF
                   ENDIF ;  PGMODE LOCKED
                   IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_10b
                   ENDIF
                   ENDIF ; PGMODE FREE
                   ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                   ENDIF ; RAM_USE_CLASS_3
                
                   IF ( RAM_USE_CLASS_2 & RAM_USE_CLASS_4 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_4
                
                   
 011D 4F           mov   X,SP                                    ; Get copy of the stack pointer
 011E 3803         add   SP,DI_STACKSIZE                         ; Make some extra room for vars
 0120           
 0120              ; Testing only
 0120 52FC         mov   A,[X+DI_ValueMSB]
 0122 52FD         mov   A,[X+DI_ValueLSB]
 0124 52FB         mov   A,[X+DI_POS]
 0126 7BFA         dec   [X+DI_LSD]                              ; shift count from [1 to N] to [0 to N-1]
 0128           
 0128 560004       mov   [X+DI_DECPTR],4                         ; Load dec ptr with 10000 value
 012B           
 012B           
 012B              ; Comapare input value to decade
 012B           .DEC_LOOP_TOP:
 012B 560100       mov   [X+DI_RESULT],0                         ; Reset result
 012E           .DEC_LOOP:
 012E              ; Compare MSB
 012E 5200         mov   A,[X+DI_DECPTR]
 0130 64           asl   A                                       ; Index it for 2 (word) bytes ber value
 0131 FEE6         index DEC_TABLE
 0133 3BFC         cmp   A,[X+DI_ValueMSB]                       ; Is 10^x > Value  (10^x - value)
 0135 C00F         jc    .DO_INC_SUB                             ; If value is still bigger, increment and subtract
 0137 B024         jnz   .TRY_NEXT_DEC
 0139           
 0139              ; Compare LSB only if MSB values were equal
 0139 5200         mov   A,[X+DI_DECPTR]                         ; Get LSB of DEC value
 013B 64           asl   A                                       ; Index it for 2 bytes per value
 013C 74           inc   A                                       ; Advance to LSB value
 013D FEDA         index DEC_TABLE
 013F 3BFD         cmp   A,[X+DI_ValueLSB]                       ; Is 10^x > Value  (10^x - value)
 0141 C003         jc    .DO_INC_SUB                             ; If value is still bigger, increment and subtract
 0143 B018         jnz   .TRY_NEXT_DEC
 0145                                                            ; If it fell through, they are equal
 0145           .DO_INC_SUB:
 0145 7701         inc   [X+DI_RESULT]                           ; Increment the result counter
 0147              ; Subtract DEC value from Value
 0147 5200         mov   A,[X+DI_DECPTR]
 0149 64           asl   A                                       ; Index it for 2 bytes per value
 014A FECD         index DEC_TABLE
 014C 5402         mov   [X+DI_TMP],A                            ; Store this value for a moment  
 014E           
 014E 5200         mov   A,[X+DI_DECPTR]                         ; Get LSB of DEC value
 0150 64           asl   A                                       ; Index it for 2 bytes per value
 0151 74           inc   A                                       ; Advance to LSB value
 0152 FEC5         index DEC_TABLE
 0154 15FD         sub   [X+DI_ValueLSB],A                       ; Is 10^x > Value  (10^x - value)
 0156 5202         mov   A,[X+DI_TMP]
 0158 1DFC         sbb   [X+DI_ValueMSB],A
 015A 8FD3         jmp   .DEC_LOOP                               ; Keep subtracting until less than.
 015C              
 015C           .TRY_NEXT_DEC:                                   ; Completed last decade
 015C           
 015C 52FA         mov   A,[X+DI_LSD]                            ; Get first position
 015E 3B00         cmp   A,[X+DI_DECPTR]      
 0160 C011         jc    .SkipPrint                              ; Not ready skip the print
 0162           
 0162           
 0162              ; Figure if digit should be displayed
 0162 5201         mov   A,[X+DI_RESULT]                         ; Get result
 0164 10           push  X
 0165 59FB         mov   X,[X+DI_POS]                            ; Load Position
 0167           
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                   IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
 0167 71C0            or    F,  FLAG_PGMODE_11b            ; LMM w/ IndexPage<==>StackPage
                   ENDIF ;  PGMODE LOCKED
                   IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                      or    F,  FLAG_PGMODE_10b            ; LMM with independent IndexPage
                   ENDIF ; PGMODE FREE
                   ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
 0169 9F66         call  LED7SEG_1_PutHex
                   IF ( RAM_USE_CLASS_2 & RAM_USE_CLASS_1 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_1
                
                   IF ( RAM_USE_CLASS_2 & RAM_USE_CLASS_2 )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                   IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
 016B 703F            and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
 016D 71C0            or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_11b
                   ENDIF
                   ENDIF ;  PGMODE LOCKED
                   IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_10b
                   ENDIF
                   ENDIF ; PGMODE FREE
                   ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                   ENDIF ; RAM_USE_CLASS_2
                
                   IF ( RAM_USE_CLASS_2 & RAM_USE_CLASS_3 )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                   IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_11b
                   ENDIF
                   ENDIF ;  PGMODE LOCKED
                   IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_10b
                   ENDIF
                   ENDIF ; PGMODE FREE
                   ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                   ENDIF ; RAM_USE_CLASS_3
                
                   IF ( RAM_USE_CLASS_2 & RAM_USE_CLASS_4 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_4
                
 016F 20           pop   X
 0170 77FB         inc   [X+DI_POS]                              ; Next time print to the right
 0172           
 0172           .SkipPrint:
 0172 560100       mov   [X+DI_RESULT],0
 0175 7B00         dec   [X+DI_DECPTR]
 0177 BFB6         jnz   .DEC_LOOP
 0179           
 0179 52FD         mov   A,[X+DI_ValueLSB]                       ; Is 10^x > Value  (10^x - value)
 017B 59FB         mov   X,[X+DI_POS]                            ; Load Position
 017D           
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                   IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
 017D 71C0            or    F,  FLAG_PGMODE_11b            ; LMM w/ IndexPage<==>StackPage
                   ENDIF ;  PGMODE LOCKED
                   IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                      or    F,  FLAG_PGMODE_10b            ; LMM with independent IndexPage
                   ENDIF ; PGMODE FREE
                   ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
 017F 9F50         call  LED7SEG_1_PutHex
                   IF ( RAM_USE_CLASS_2 & RAM_USE_CLASS_1 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_1
                
                   IF ( RAM_USE_CLASS_2 & RAM_USE_CLASS_2 )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                   IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0181 703F            and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
 0183 71C0            or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_11b
                   ENDIF
                   ENDIF ;  PGMODE LOCKED
                   IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_10b
                   ENDIF
                   ENDIF ; PGMODE FREE
                   ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                   ENDIF ; RAM_USE_CLASS_2
                
                   IF ( RAM_USE_CLASS_2 & RAM_USE_CLASS_3 )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                   IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_11b
                   ENDIF
                   ENDIF ;  PGMODE LOCKED
                   IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_10b
                   ENDIF
                   ENDIF ; PGMODE FREE
                   ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                   ENDIF ; RAM_USE_CLASS_3
                
                   IF ( RAM_USE_CLASS_2 & RAM_USE_CLASS_4 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_4
                
                
 0185           .DispInt_End:
 0185 38FD         add   SP,-DI_STACKSIZE                        ; Restore stack
                   IF ( RAM_USE_CLASS_2 & RAM_USE_CLASS_1 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_1
                
                   IF ( RAM_USE_CLASS_2 & RAM_USE_CLASS_2 )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                   IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0187 703F            and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
 0189 71C0            or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_11b
                   ENDIF
                   ENDIF ;  PGMODE LOCKED
                   IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_10b
                   ENDIF
                   ENDIF ; PGMODE FREE
                   ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                   ENDIF ; RAM_USE_CLASS_2
                
                   IF ( RAM_USE_CLASS_2 & RAM_USE_CLASS_3 )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                   IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_11b
                   ENDIF
                   ENDIF ;  PGMODE LOCKED
                   IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
                   IF ( SYSTEM_LARGE_MEMORY_MODEL )
                      and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
                      or    F,  FLAG_PGMODE_MASK & FLAG_PGMODE_10b
                   ENDIF
                   ENDIF ; PGMODE FREE
                   ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                   ENDIF ; RAM_USE_CLASS_3
                
                   IF ( RAM_USE_CLASS_2 & RAM_USE_CLASS_4 )
                   ; Nothing to do
                   ENDIF ; RAM_USE_CLASS_4
                
 018B 7F           ret
 018C           .ENDSECTION
