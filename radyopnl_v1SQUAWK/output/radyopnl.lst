0000: 80 67    JMP   0x0068
0002: 30       HALT  
0003: 30       HALT  

FILE: .\boot.asm
                                   (0001) ; Generated by PSoC Designer ver 4.4  b1884 : 14 Jan, 2007
                                   (0002) ;
                                   (0003) ;@Id: boot.tpl#682 @
                                   (0004) ;=============================================================================
                                   (0005) ;  FILENAME:   boot.asm
                                   (0006) ;  VERSION:    4.16
                                   (0007) ;  DATE:       6 October 2005
                                   (0008) ;
                                   (0009) ;  DESCRIPTION:
                                   (0010) ;  M8C Boot Code for CY8C24x90 microcontroller devices.
                                   (0011) ;
                                   (0012) ;  Copyright (C) Cypress Semiconductor 2000-2005. All rights reserved.
                                   (0013) ;
                                   (0014) ; NOTES:
                                   (0015) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
                                   (0016) ; the project's root directory to create BOOT.ASM. Any changes made to
                                   (0017) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                   (0018) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                   (0019) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
                                   (0020) ; are not accidentally modified.
                                   (0021) ;
                                   (0022) ;=============================================================================
                                   (0023) 
                                   (0024) include ".\lib\GlobalParams.inc"
                                   (0025) include "m8c.inc"
                                   (0026) include "m8ssc.inc"
                                   (0027) include "memory.inc"
                                   (0028) 
                                   (0029) ;--------------------------------------
                                   (0030) ; Export Declarations
                                   (0031) ;--------------------------------------
                                   (0032) 
                                   (0033) export __Start
                                   (0034) export __bss_start
                                   (0035) export __data_start
                                   (0036) export __idata_start
                                   (0037) export __func_lit_start
                                   (0038) export __text_start
                                   (0039) export  _bGetPowerSetting
                                   (0040) export   bGetPowerSetting
                                   (0041) 
                                   (0042) 
                                   (0043) ;--------------------------------------
                                   (0044) ; Optimization flags
                                   (0045) ;--------------------------------------
                                   (0046) ;
                                   (0047) ; To change the value of these flags, modify the file boot.tpl, not
                                   (0048) ; boot.asm. See the notes in the banner comment at the beginning of
                                   (0049) ; this file.
                                   (0050) 
                                   (0051) ; Optimization for Assembly language (only) projects and C-language projects
                                   (0052) ; that do not depend on the C compiler to initialize the values of RAM variables.
                                   (0053) ;   Set to 1: Support for C Run-time Environment initialization
                                   (0054) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
                                   (0055) ;
                                   (0056) C_LANGUAGE_SUPPORT:              equ 1
                                   (0057) 
                                   (0058) 
                                   (0059) ; For historical reasons, by default the boot code uses an lcall instruction
                                   (0060) ; to invoke the user's _main code. If _main executes a return instruction,
                                   (0061) ; boot provides an infinite loop. By changing the following equate from zero
                                   (0062) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
                                   (0063) ; bytes on the stack which are otherwise required for the return address. If
                                   (0064) ; this option is enabled, _main must not return. (Beginning with the 4.2
                                   (0065) ; release, the C compiler automatically places an infinite loop at the end
                                   (0066) ; of main, rather than a return instruction.)
                                   (0067) ;
                                   (0068) ENABLE_LJMP_TO_MAIN:             equ 0
                                   (0069) 
                                   (0070) 
                                   (0071) ;-----------------------------------------------------------------------------
                                   (0072) ; Interrupt Vector Table
                                   (0073) ;-----------------------------------------------------------------------------
                                   (0074) ;
                                   (0075) ; Interrupt vector table entries are 4 bytes long.  Each one contains
                                   (0076) ; a jump instruction to an ISR (Interrupt Service Routine), although
                                   (0077) ; very short ISRs could be encoded within the table itself. Normally,
                                   (0078) ; vector jump targets are modified automatically according to the user
                                   (0079) ; modules selected. This occurs when the 'Generate Application' opera-
                                   (0080) ; tion is run causing PSoC Designer to create boot.asm and the other
                                   (0081) ; configuration files. If you need to hard code a vector, update the
                                   (0082) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
                                   (0083) ; of this file.
                                   (0084) ;-----------------------------------------------------------------------------
                                   (0085) 
                                   (0086)     AREA TOP (ROM, ABS, CON)
                                   (0087) 
                                   (0088)     org   0                        ;Reset Interrupt Vector
                                   (0089)     jmp   __Start                  ;First instruction executed following a Reset
                                   (0090) 
                                   (0091)     org   04h                      ;Supply Monitor Interrupt Vector
0004: 30       HALT                (0092)     halt                           ;Stop execution if power falls too low
0005: 30       HALT  
0006: 30       HALT  
0007: 30       HALT  
                                   (0093) 
                                   (0094)     org   08h                      ;Analog Column 0 Interrupt Vector
                                   (0095)     // call	void_handler
0008: 7E       RETI                (0096)     reti
0009: 30       HALT  
000A: 30       HALT  
000B: 30       HALT  
                                   (0097) 
                                   (0098)     org   0Ch                      ;Analog Column 1 Interrupt Vector
                                   (0099)     // call	void_handler
000C: 7E       RETI                (0100)     reti
000D: 30       HALT  
000E: 30       HALT  
000F: 30       HALT  
0010: 30       HALT  
0011: 30       HALT  
0012: 30       HALT  
0013: 30       HALT  
0014: 30       HALT  
0015: 30       HALT  
0016: 30       HALT  
0017: 30       HALT  
                                   (0101) 
                                   (0102)     org   18h                      ;VC3 Interrupt Vector
                                   (0103)     // call	void_handler
0018: 7E       RETI                (0104)     reti
0019: 30       HALT  
001A: 30       HALT  
001B: 30       HALT  
                                   (0105) 
                                   (0106)     org   1Ch                      ;GPIO Interrupt Vector
                                   (0107)     // call	void_handler
001C: 7E       RETI                (0108)     reti
001D: 30       HALT  
001E: 30       HALT  
001F: 30       HALT  
                                   (0109) 
                                   (0110)     org   20h                      ;PSoC Block DBB00 Interrupt Vector
0020: 7D 07 85 LJMP  0x0785        (0111)     ljmp	_ADCINC12_1_TMR_ISR
0023: 7E       RETI                (0112)     reti
                                   (0113) 
                                   (0114)     org   24h                      ;PSoC Block DBB01 Interrupt Vector
0024: 7D 07 82 LJMP  0x0782        (0115)     ljmp	_ADCINC12_1_CNT_ISR
0027: 7E       RETI                (0116)     reti
                                   (0117) 
                                   (0118)     org   28h                      ;PSoC Block DCB02 Interrupt Vector
0028: 7D 03 F0 LJMP  0x03F0        (0119)     ljmp	_LED7SEG_1_ISR
002B: 7E       RETI                (0120)     reti
                                   (0121) 
                                   (0122)     org   2Ch                      ;PSoC Block DCB03 Interrupt Vector
002C: 7D 08 62 LJMP  __text_start  (0123)     ljmp	_Counter8_1_ISR
002F: 7E       RETI                (0124)     reti
0030: 30       HALT  
0031: 30       HALT  
0032: 30       HALT  
0033: 30       HALT  
0034: 30       HALT  
0035: 30       HALT  
0036: 30       HALT  
0037: 30       HALT  
0038: 30       HALT  
0039: 30       HALT  
003A: 30       HALT  
003B: 30       HALT  
003C: 30       HALT  
003D: 30       HALT  
003E: 30       HALT  
003F: 30       HALT  
                                   (0125) 
                                   (0126)     org   40h                      ;USB Reset Interrupt Vector
                                   (0127)     // call	void_handler
0040: 7E       RETI                (0128)     reti
0041: 30       HALT  
0042: 30       HALT  
0043: 30       HALT  
                                   (0129) 
                                   (0130)     org   44h                      ;USB SOF Interrupt Vector
                                   (0131)     // call	void_handler
0044: 7E       RETI                (0132)     reti
0045: 30       HALT  
0046: 30       HALT  
0047: 30       HALT  
                                   (0133) 
                                   (0134)     org   48h                      ;USB EP0 Interrupt Vector
                                   (0135)     // call	void_handler
0048: 7E       RETI                (0136)     reti
0049: 30       HALT  
004A: 30       HALT  
004B: 30       HALT  
                                   (0137) 
                                   (0138)     org   4Ch                      ;USB EP1 Interrupt Vector
                                   (0139)     // call	void_handler
004C: 7E       RETI                (0140)     reti
004D: 30       HALT  
004E: 30       HALT  
004F: 30       HALT  
                                   (0141) 
                                   (0142)     org   50h                      ;USB EP2 Interrupt Vector
                                   (0143)     // call	void_handler
0050: 7E       RETI                (0144)     reti
0051: 30       HALT  
0052: 30       HALT  
0053: 30       HALT  
                                   (0145) 
                                   (0146)     org   54h                      ;USB EP3 Interrupt Vector
                                   (0147)     // call	void_handler
0054: 7E       RETI                (0148)     reti
0055: 30       HALT  
0056: 30       HALT  
0057: 30       HALT  
                                   (0149) 
                                   (0150)     org   58h                      ;USB EP4 Interrupt Vector
                                   (0151)     // call	void_handler
0058: 7E       RETI                (0152)     reti
0059: 30       HALT  
005A: 30       HALT  
005B: 30       HALT  
                                   (0153) 
                                   (0154)     org   5Ch                      ;USB Wakeup Interrupt Vector
                                   (0155)     // call	void_handler
005C: 7E       RETI                (0156)     reti
005D: 30       HALT  
005E: 30       HALT  
005F: 30       HALT  
                                   (0157) 
                                   (0158)     org   60h                      ;PSoC I2C Interrupt Vector
0060: 7D 05 A2 LJMP  0x05A2        (0159)     ljmp	_I2CHW_1_ISR
0063: 7E       RETI                (0160)     reti
                                   (0161) 
                                   (0162)     org   64h                      ;Sleep Timer Interrupt Vector
                                   (0163)     // call	void_handler
0064: 7E       RETI                (0164)     reti
0065: 30       HALT  
0066: 30       HALT  
0067: 30       HALT  
                                   (0165) 
                                   (0166) ;-----------------------------------------------------------------------------
                                   (0167) ;  Start of Execution.
                                   (0168) ;-----------------------------------------------------------------------------
                                   (0169) ;  The Supervisory ROM SWBootReset function has already completed the
                                   (0170) ;  calibrate1 process, loading trim values for 5 volt operation.
                                   (0171) ;
                                   (0172)     org 68h
                                   (0173) __Start:
                                   (0174) 
                                   (0175)     ; initialize values for voltage stabilization, if required,
                                   (0176)     ; leaving power-on reset (POR) level at the default (low) level, at
                                   (0177)     ; least for now. 
                                   (0178)     ;
0068: 71 10    OR    F,16          (0179)     M8C_SetBank1
006A: 62 E3 07 MOV   REG[227],7    (0180)     mov   reg[VLT_CR], LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
006D: 70 EF    AND   F,239         (0181)     M8C_SetBank0
                                   (0182) 
                                   (0183)     ; %53%20%46%46% Apply Erratum 001-05137 workaround
006F: 50 20    MOV   A,32          (0184)     mov   A, 20h
0071: 28       ROMX                (0185)     romx
                                   (0186)     ; %45%20%46%46% End workaround
                                   (0187) 	
                                   (0188) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                                   (0189)     M8C_EnableWatchDog
                                   (0190) ENDIF
                                   (0191) 
0072: 41 FE FB AND   REG[254],251  (0192)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
                                   (0193) 
                                   (0194)     ;---------------------------
                                   (0195)     ; Set up the Temporary stack
                                   (0196)     ;---------------------------
                                   (0197)     ; A temporary stack is set up for the SSC instructions.
                                   (0198)     ; The real stack start will be assigned later.
                                   (0199)     ;
                                   (0200) _stack_start:          equ 80h
0075: 50 80    MOV   A,128         (0201)     mov   A, _stack_start          ; Set top of stack to end of used RAM
0077: 4E       SWAP  SP,A          (0202)     swap  SP, A                    ; This is only temporary if going to LMM
                                   (0203) 
                                   (0204)     ;------------------------
                                   (0205)     ; Set Power-related Trim 
                                   (0206)     ;------------------------
                                   (0207) 
                                   (0208) IF ( POWER_SETTING & POWER_SET_5V0)            ; *** 5.0 Volt operation   ***
                                   (0209) 
                                   (0210)   IF ( AGND_BYPASS )
                                   (0211)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                   (0212)     ; The 5V trim has already been set, but we need to update the AGNDBYP
                                   (0213)     ; bit in the write-only BDG_TR register. Recalculate the register
                                   (0214)     ; value using the proper trim values.
                                   (0215)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                   (0216)     M8SSC_SetTableVoltageTrim 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                   (0217)   ENDIF
                                   (0218) ELSE
                                   (0219) 	; 3.3V operation trim codes
                                   (0220) 	; Set the IMO and Bandgap trims for 3v operation
                                   (0221)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V, AGN_BYPASS_JUST
                                   (0222) 	
                                   (0223) 	; Set the IMO Gain Trim for 3v operation
                                   (0224) 	M8SSC_SetTableIMOGainTrim 2, SSCTBL2_TRIM_IMO_GAIN_3V
                                   (0225) 
                                   (0226) ENDIF ; 3.3 Volt Operation
                                   (0227) 
0078: 55 F8 00 MOV   [intRet+1],0  (0228)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
007B: 55 F9 00 MOV   [intRet+2],0  (0229)     mov  [bSSC_KEYSP], 0
                                   (0230) 				
                                   (0231)     ;---------------------------------------
                                   (0232)     ; Initialize Crystal Oscillator and PLL
                                   (0233)     ;---------------------------------------
                                   (0234) 
                                   (0235)     ; Either no ECO, or waiting for stable clock is to be done in main
007E: 71 10    OR    F,16          (0236)     M8C_SetBank1
0080: 62 E0 02 MOV   REG[224],2    (0237)     mov   reg[OSC_CR0], (SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
0083: 70 EF    AND   F,239         (0238)     M8C_SetBank0
0085: 62 E3 38 MOV   REG[227],56   (0239)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                   (0240) 
                                   (0241)     ;---------------------------------------------
                                   (0242)     ; Enter the Large Memory Model, if applicable
                                   (0243)     ;---------------------------------------------
                                   (0244) IF ( SYSTEM_LARGE_MEMORY_MODEL )
0088: 62 D1 03 MOV   REG[209],3    (0245)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
008B: 50 00    MOV   A,0           (0246)     mov   A, SYSTEM_STACK_BASE_ADDR        ;   and offset, if any
008D: 4E       SWAP  SP,A          (0247)     swap  A, SP
008E: 62 D3 03 MOV   REG[211],3    (0248)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
0091: 62 D0 00 MOV   REG[208],0    (0249)     RAM_SETPAGE_CUR 0
0094: 62 D5 00 MOV   REG[213],0    (0250)     RAM_SETPAGE_MVW 0
0097: 62 D4 00 MOV   REG[212],0    (0251)     RAM_SETPAGE_MVR 0
                                   (0252) 
                                   (0253)   IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
009A: 71 C0    OR    F,192         (0254)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                   (0255)   ELSE
                                   (0256)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                   (0257)   ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                   (0258) ELSE
                                   (0259)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
                                   (0260)     swap  SP, A
                                   (0261) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                   (0262) 
                                   (0263)     ;------------------------
                                   (0264)     ; Close CT leakage path.
                                   (0265)     ;------------------------
009C: 62 71 05 MOV   REG[113],5    (0266)     mov   reg[ACB00CR0], 05h
009F: 62 75 05 MOV   REG[117],5    (0267)     mov   reg[ACB01CR0], 05h
                                   (0268) 
                                   (0269)     ;-------------------------
                                   (0270)     ; Load Base Configuration
                                   (0271)     ;-------------------------
                                   (0272)     ; Load global parameter settings and load the user modules in the
                                   (0273)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
                                   (0274)     ; to minimize start up time; (2) We may still need to play with the
                                   (0275)     ; Sleep Timer.
                                   (0276)     ;
00A2: 7C 03 A3 LCALL 0x03A3        (0277)     lcall LoadConfigInit
00A5: 71 10    OR    F,16          (0278) 	M8C_SetBank1
00A7: 41 E7 3F AND   REG[231],63   (0279) 	and  reg[DEC_CR1], 0x3F
00AA: 43 E7 80 OR    REG[231],128  (0280) 	or   reg[DEC_CR1], 0x80
00AD: 70 EF    AND   F,239         (0281) 	M8C_SetBank0
                                   (0282)     ;-----------------------------------
                                   (0283)     ; Initialize C Run-Time Environment
                                   (0284)     ;-----------------------------------
                                   (0285) IF ( C_LANGUAGE_SUPPORT )
                                   (0286) IF ( SYSTEM_SMALL_MEMORY_MODEL )
                                   (0287)     mov  A,0                           ; clear the 'bss' segment to zero
                                   (0288)     mov  [__r0],<__bss_start
                                   (0289) BssLoop:
                                   (0290)     cmp  [__r0],<__bss_end
                                   (0291)     jz   BssDone
                                   (0292)     mvi  [__r0],A
                                   (0293)     jmp  BssLoop
                                   (0294) BssDone:
                                   (0295)     mov  A,>__idata_start              ; copy idata to data segment
                                   (0296)     mov  X,<__idata_start
                                   (0297)     mov  [__r0],<__data_start
                                   (0298) IDataLoop:
                                   (0299)     cmp  [__r0],<__data_end
                                   (0300)     jz   C_RTE_Done
                                   (0301)     push A
                                   (0302)     romx
                                   (0303)     mvi  [__r0],A
                                   (0304)     pop  A
                                   (0305)     inc  X
                                   (0306)     adc  A,0
                                   (0307)     jmp  IDataLoop
                                   (0308) 
                                   (0309) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
                                   (0310) 
                                   (0311) IF ( SYSTEM_LARGE_MEMORY_MODEL )
00AF: 62 D0 00 MOV   REG[208],0    (0312)     mov   reg[CUR_PP], >__r0           ; force direct addr mode instructions
                                   (0313)                                        ; to use the Virtual Register page.
                                   (0314) 
                                   (0315)     ; Dereference the constant (flash) pointer pXIData to access the start
                                   (0316)     ; of the extended idata area, "xidata." Xidata follows the end of the
                                   (0317)     ; text segment and may have been relocated by the Code Compressor.
                                   (0318)     ;
00B2: 50 01    MOV   A,1           (0319)     mov   A, >__pXIData                ; Get the address of the flash
00B4: 57 A0    MOV   X,160         (0320)     mov   X, <__pXIData                ;   pointer to the xidata area.
00B6: 08       PUSH  A             (0321)     push  A
00B7: 28       ROMX                (0322)     romx                               ; get the MSB of xidata's address
00B8: 53 F6    MOV   [__r0],A      (0323)     mov   [__r0], A
00BA: 18       POP   A             (0324)     pop   A
00BB: 75       INC   X             (0325)     inc   X
00BC: 09 00    ADC   A,0           (0326)     adc   A, 0
00BE: 28       ROMX                (0327)     romx                               ; get the LSB of xidata's address
00BF: 4B       SWAP  A,X           (0328)     swap  A, X
00C0: 51 F6    MOV   A,[246]       (0329)     mov   A, [__r0]                    ; pXIData (in [A,X]) points to the
                                   (0330)                                        ;   XIData structure list in flash
00C2: 80 04    JMP   0x00C7        (0331)     jmp   .AccessStruct
                                   (0332) 
                                   (0333)     ; Unpack one element in the xidata "structure list" that specifies the
                                   (0334)     ; values of C variables. Each structure contains 3 member elements.
                                   (0335)     ; The first is a pointer to a contiguous block of RAM to be initial-
                                   (0336)     ; ized. Blocks are always 255 bytes or less in length and never cross
                                   (0337)     ; RAM page boundaries. The list terminates when the MSB of the pointer
                                   (0338)     ; contains 0xFF. There are two formats for the struct depending on the
                                   (0339)     ; value in the second member element, an unsigned byte:
                                   (0340)     ; (1) If the value of the second element is non-zero, it represents
                                   (0341)     ; the 'size' of the block of RAM to be initialized. In this case, the
                                   (0342)     ; third member of the struct is an array of bytes of length 'size' and
                                   (0343)     ; the bytes are copied to the block of RAM.
                                   (0344)     ; (2) If the value of the second element is zero, the block of RAM is
                                   (0345)     ; to be cleared to zero. In this case, the third member of the struct
                                   (0346)     ; is an unsigned byte containing the number of bytes to clear.
                                   (0347) 
                                   (0348) .AccessNextStructLoop:
00C4: 75       INC   X             (0349)     inc   X                            ; pXIData++
00C5: 09 00    ADC   A,0           (0350)     adc   A, 0
                                   (0351) .AccessStruct:                         ; Entry point for first block
                                   (0352)     ;
                                   (0353)     ; Assert: pXIData in [A,X] points to the beginning of an XIData struct.
                                   (0354)     ;
00C7: 62 E3 00 MOV   REG[227],0    (0355)     M8C_ClearWDT                       ; Clear the watchdog for long inits
00CA: 08       PUSH  A             (0356)     push  A
00CB: 28       ROMX                (0357)     romx                               ; MSB of RAM addr (CPU.A <- *pXIData)
00CC: 60 D5    MOV   REG[213],A    (0358)     mov   reg[MVW_PP], A               ;   for use with MVI write operations
00CE: 74       INC   A             (0359)     inc   A                            ; End of Struct List? (MSB==0xFF?)
00CF: A0 4B    JZ    0x011B        (0360)     jz    .C_RTE_WrapUp                ;   Yes, C runtime environment complete
00D1: 18       POP   A             (0361)     pop   A                            ; restore pXIData to [A,X]
00D2: 75       INC   X             (0362)     inc   X                            ; pXIData++
00D3: 09 00    ADC   A,0           (0363)     adc   A, 0
00D5: 08       PUSH  A             (0364)     push  A
00D6: 28       ROMX                (0365)     romx                               ; LSB of RAM addr (CPU.A <- *pXIData)
00D7: 53 F6    MOV   [__r0],A      (0366)     mov   [__r0], A                    ; RAM Addr now in [reg[MVW_PP],[__r0]]
00D9: 18       POP   A             (0367)     pop   A                            ; restore pXIData to [A,X]
00DA: 75       INC   X             (0368)     inc   X                            ; pXIData++ (point to size)
00DB: 09 00    ADC   A,0           (0369)     adc   A, 0
00DD: 08       PUSH  A             (0370)     push  A
00DE: 28       ROMX                (0371)     romx                               ; Get the size (CPU.A <- *pXIData)
00DF: A0 1C    JZ    0x00FC        (0372)     jz    .ClearRAMBlockToZero         ; If Size==0, then go clear RAM
00E1: 53 F5    MOV   [__r1],A      (0373)     mov   [__r1], A                    ;             else downcount in __r1
00E3: 18       POP   A             (0374)     pop   A                            ; restore pXIData to [A,X]
                                   (0375) 
                                   (0376) .CopyNextByteLoop:
                                   (0377)     ; For each byte in the structure's array member, copy from flash to RAM.
                                   (0378)     ; Assert: pXIData in [A,X] points to previous byte of flash source;
                                   (0379)     ;         [reg[MVW_PP],[__r0]] points to next RAM destination;
                                   (0380)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                   (0381)     ;
00E4: 75       INC   X             (0382)     inc   X                            ; pXIData++ (point to next data byte)
00E5: 09 00    ADC   A,0           (0383)     adc   A, 0
00E7: 08       PUSH  A             (0384)     push  A
00E8: 28       ROMX                (0385)     romx                               ; Get the data value (CPU.A <- *pXIData)
00E9: 3F F6    MVI   [__r0],A      (0386)     mvi   [__r0], A                    ; Transfer the data to RAM
00EB: 47 F6 FF TST   [246],255     (0387)     tst   [__r0], 0xff                 ; Check for page crossing
00EE: B0 06    JNZ   0x00F5        (0388)     jnz   .CopyLoopTail                ;   No crossing, keep going
00F0: 5D D5    MOV   A,REG[213]    (0389)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
00F2: 74       INC   A             (0390)     inc   A
00F3: 60 D5    MOV   REG[213],A    (0391)     mov   reg[ MVW_PP], A
                                   (0392) .CopyLoopTail:
00F5: 18       POP   A             (0393)     pop   A                            ; restore pXIData to [A,X]
00F6: 7A F5    DEC   [__r1]        (0394)     dec   [__r1]                       ; End of this array in flash?
00F8: BF EB    JNZ   0x00E4        (0395)     jnz   .CopyNextByteLoop            ;   No,  more bytes to copy
00FA: 8F C9    JMP   0x00C4        (0396)     jmp   .AccessNextStructLoop        ;   Yes, initialize another RAM block
                                   (0397) 
                                   (0398) .ClearRAMBlockToZero:
00FC: 18       POP   A             (0399)     pop   A                            ; restore pXIData to [A,X]
00FD: 75       INC   X             (0400)     inc   X                            ; pXIData++ (point to next data byte)
00FE: 09 00    ADC   A,0           (0401)     adc   A, 0
0100: 08       PUSH  A             (0402)     push  A
0101: 28       ROMX                (0403)     romx                               ; Get the run length (CPU.A <- *pXIData)
0102: 53 F5    MOV   [__r1],A      (0404)     mov   [__r1], A                    ; Initialize downcounter
0104: 50 00    MOV   A,0           (0405)     mov   A, 0                         ; Initialize source data
                                   (0406) 
                                   (0407) .ClearRAMBlockLoop:
                                   (0408)     ; Assert: [reg[MVW_PP],[__r0]] points to next RAM destination and
                                   (0409)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                   (0410)     ;
0106: 3F F6    MVI   [__r0],A      (0411)     mvi   [__r0], A                    ; Clear a byte
0108: 47 F6 FF TST   [246],255     (0412)     tst   [__r0], 0xff                 ; Check for page crossing
010B: B0 08    JNZ   0x0114        (0413)     jnz   .ClearLoopTail               ;   No crossing, keep going
010D: 5D D5    MOV   A,REG[213]    (0414)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
010F: 74       INC   A             (0415)     inc   A
0110: 60 D5    MOV   REG[213],A    (0416)     mov   reg[ MVW_PP], A
0112: 50 00    MOV   A,0           (0417)     mov   A, 0                         ; Restore the zero used for clearing
                                   (0418) .ClearLoopTail:
0114: 7A F5    DEC   [__r1]        (0419)     dec   [__r1]                       ; Was this the last byte?
0116: BF EF    JNZ   0x0106        (0420)     jnz   .ClearRAMBlockLoop           ;   No,  continue
0118: 18       POP   A             (0421)     pop   A                            ;   Yes, restore pXIData to [A,X] and
0119: 8F AA    JMP   0x00C4        (0422)     jmp   .AccessNextStructLoop        ;        initialize another RAM block
                                   (0423) 
                                   (0424) .C_RTE_WrapUp:
011B: 18       POP   A             (0425)     pop   A                            ; balance stack
                                   (0426) 
                                   (0427) ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                                   (0428) 
                                   (0429) C_RTE_Done:
                                   (0430) 
                                   (0431) ENDIF ; C_LANGUAGE_SUPPORT
                                   (0432) 
                                   (0433) 
                                   (0434)     ;-------------------------------
                                   (0435)     ; Set Power-On Reset (POR) Level
                                   (0436)     ;-------------------------------
011C: 71 10    OR    F,16          (0437)     M8C_SetBank1
                                   (0438) 
                                   (0439) IF (POWER_SETTING & POWER_SET_3V3)             ; 3.3V Operation?
                                   (0440)     or   reg[VLT_CR], VLT_CR_POR_LOW           ;   Yes, change to midpoint trip
                                   (0441) ELSE										   ; 5V Operation
                                   (0442)   IF ( CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz )    ;      As fast as 24MHz?
011E: 43 E3 00 OR    REG[227],0    (0443)     or   reg[VLT_CR], VLT_CR_POR_LOW           ;         No, change to midpoint trip
                                   (0444)   ELSE ; 24HMz                                 ;
                                   (0445)     or    reg[VLT_CR], VLT_CR_POR_HIGH         ;        Yes, switch to	highest setting
                                   (0446)   ENDIF ; 24MHz
                                   (0447) ENDIF ; 3.3V Operation
                                   (0448) 
0121: 70 EF    AND   F,239         (0449)     M8C_SetBank0
                                   (0450) 
                                   (0451)     ;----------------------------
                                   (0452)     ; Wrap up and invoke "main"
                                   (0453)     ;----------------------------
                                   (0454) 
                                   (0455)     ; Disable the Sleep interrupt that was used for timing above.  In fact,
                                   (0456)     ; no interrupts should be enabled now, so may as well clear the register.
                                   (0457)     ;
0123: 62 E0 00 MOV   REG[224],0    (0458)     mov  reg[INT_MSK0],0
                                   (0459) 
                                   (0460)     ; Everything has started OK. Now select requested CPU & sleep frequency.
                                   (0461)     ;
0126: 71 10    OR    F,16          (0462)     M8C_SetBank1
0128: 62 E0 02 MOV   REG[224],2    (0463)     mov  reg[OSC_CR0],(SLEEP_TIMER_JUST | CPU_CLOCK_JUST)
012B: 70 EF    AND   F,239         (0464)     M8C_SetBank0
                                   (0465) 
                                   (0466)     ; Global Interrupt are NOT enabled, this should be done in main().
                                   (0467)     ; LVD is set but will not occur unless Global Interrupts are enabled.
                                   (0468)     ; Global Interrupts should be enabled as soon as possible in main().
                                   (0469)     ;
012D: 62 E2 00 MOV   REG[226],0    (0470)     mov  reg[INT_VC],0             ; Clear any pending interrupts which may
                                   (0471)                                    ; have been set during the boot process.
                                   (0472) IF ENABLE_LJMP_TO_MAIN
                                   (0473)     ljmp  _main                    ; goto main (no return)
                                   (0474) ELSE
0130: 7C 09 8D LCALL _main         (0475)     lcall _main                    ; call main
                                   (0476) .Exit:
0133: 8F FF    JMP   0x0133        (0477)     jmp  .Exit                     ; Wait here after return till power-off or reset
                                   (0478) ENDIF
                                   (0479) 
                                   (0480)     ;---------------------------------
                                   (0481)     ; Library Access to Global Parms
                                   (0482)     ;---------------------------------
                                   (0483)     ;
                                   (0484)  bGetPowerSetting:
                                   (0485) _bGetPowerSetting:
                                   (0486)     ; Returns value of POWER_SETTING in the A register.
                                   (0487)     ; No inputs. No Side Effects.
                                   (0488)     ;
0135: 50 10    MOV   A,16          (0489)     mov   A, POWER_SETTING          ; Supply voltage and internal main osc
0137: 7F       RET                 (0490)     ret
0138: 30       HALT  
0139: 30       HALT  
013A: 30       HALT  
013B: 30       HALT  
013C: 30       HALT  
013D: 30       HALT  
013E: 30       HALT  
013F: 30       HALT  
0140: 30       HALT  
0141: 30       HALT  
0142: 30       HALT  
0143: 30       HALT  
0144: 30       HALT  
0145: 30       HALT  
0146: 30       HALT  
0147: 30       HALT  
0148: 30       HALT  
0149: 30       HALT  
014A: 30       HALT  
014B: 30       HALT  
014C: 30       HALT  
014D: 30       HALT  
014E: 30       HALT  
014F: 30       HALT  
0150: 30       HALT  
0151: 30       HALT  
0152: 30       HALT  
0153: 30       HALT  
0154: 30       HALT  
0155: 30       HALT  
0156: 30       HALT  
0157: 30       HALT  
0158: 30       HALT  
0159: 30       HALT  
015A: 30       HALT  
015B: 30       HALT  
015C: 30       HALT  
015D: 30       HALT  
015E: 30       HALT  
015F: 30       HALT  
0160: 30       HALT  
0161: 30       HALT  
0162: 30       HALT  
0163: 30       HALT  
0164: 30       HALT  
0165: 30       HALT  
0166: 30       HALT  
0167: 30       HALT  
0168: 30       HALT  
0169: 30       HALT  
016A: 30       HALT  
016B: 30       HALT  
016C: 30       HALT  
016D: 30       HALT  
016E: 30       HALT  
016F: 30       HALT  
0170: 30       HALT  
0171: 30       HALT  
0172: 30       HALT  
0173: 30       HALT  
0174: 30       HALT  
0175: 30       HALT  
0176: 30       HALT  
0177: 30       HALT  
0178: 30       HALT  
0179: 30       HALT  
017A: 30       HALT  
017B: 30       HALT  
017C: 30       HALT  
017D: 30       HALT  
017E: 30       HALT  
017F: 30       HALT  
0180: 30       HALT  
0181: 30       HALT  
0182: 30       HALT  
0183: 30       HALT  
0184: 30       HALT  
0185: 30       HALT  
0186: 30       HALT  
0187: 30       HALT  
0188: 30       HALT  
0189: 30       HALT  
018A: 30       HALT  
018B: 30       HALT  
018C: 30       HALT  
018D: 30       HALT  
018E: 30       HALT  
018F: 30       HALT  
0190: 30       HALT  
0191: 30       HALT  
0192: 30       HALT  
0193: 30       HALT  
0194: 30       HALT  
0195: 30       HALT  
0196: 30       HALT  
0197: 30       HALT  
0198: 30       HALT  
0199: 30       HALT  
019A: 30       HALT  
019B: 30       HALT  
019C: 30       HALT  
019D: 30       HALT  
019E: 30       HALT  
019F: 30       HALT  
01A0: 0E 36 71 ADC   [54],113

FILE: lib\psocconfigtbl.asm
                                   (0001) ; Generated by PSoC Designer ver 4.4  b1884 : 14 Jan, 2007
                                   (0002) ;
                                   (0003) include "m8c.inc"
                                   (0004) ;  Personalization tables 
                                   (0005) export LoadConfigTBL_radyopnl
                                   (0006) AREA psoc_config(rom, rel)
                                   (0007) LoadConfigTBL_radyopnl:
                                   (0008) ;  Ordered Global Register values
01A3: 10       PUSH  X             (0009) 	M8C_SetBank1
01A4: 62 00 00 MOV   REG[0],0      (0010) 	mov	reg[00h], 00h		; Port_0_DriveMode_0 register (PRT0DM0)
01A7: 62 01 FF MOV   REG[1],255    (0011) 	mov	reg[01h], ffh		; Port_0_DriveMode_1 register (PRT0DM1)
01AA: 70 EF    AND   F,239         (0012) 	M8C_SetBank0
01AC: 62 03 FF MOV   REG[3],255    (0013) 	mov	reg[03h], ffh		; Port_0_DriveMode_2 register (PRT0DM2)
01AF: 62 02 00 MOV   REG[2],0      (0014) 	mov	reg[02h], 00h		; Port_0_GlobalSelect register (PRT0GS)
01B2: 71 10    OR    F,16          (0015) 	M8C_SetBank1
01B4: 62 02 00 MOV   REG[2],0      (0016) 	mov	reg[02h], 00h		; Port_0_IntCtrl_0 register (PRT0IC0)
01B7: 62 03 00 MOV   REG[3],0      (0017) 	mov	reg[03h], 00h		; Port_0_IntCtrl_1 register (PRT0IC1)
01BA: 70 EF    AND   F,239         (0018) 	M8C_SetBank0
01BC: 62 01 00 MOV   REG[1],0      (0019) 	mov	reg[01h], 00h		; Port_0_IntEn register (PRT0IE)
01BF: 71 10    OR    F,16          (0020) 	M8C_SetBank1
01C1: 62 04 A0 MOV   REG[4],160    (0021) 	mov	reg[04h], a0h		; Port_1_DriveMode_0 register (PRT1DM0)
01C4: 62 05 FF MOV   REG[5],255    (0022) 	mov	reg[05h], ffh		; Port_1_DriveMode_1 register (PRT1DM1)
01C7: 70 EF    AND   F,239         (0023) 	M8C_SetBank0
01C9: 62 07 FF MOV   REG[7],255    (0024) 	mov	reg[07h], ffh		; Port_1_DriveMode_2 register (PRT1DM2)
01CC: 62 06 00 MOV   REG[6],0      (0025) 	mov	reg[06h], 00h		; Port_1_GlobalSelect register (PRT1GS)
01CF: 71 10    OR    F,16          (0026) 	M8C_SetBank1
01D1: 62 06 00 MOV   REG[6],0      (0027) 	mov	reg[06h], 00h		; Port_1_IntCtrl_0 register (PRT1IC0)
01D4: 62 07 00 MOV   REG[7],0      (0028) 	mov	reg[07h], 00h		; Port_1_IntCtrl_1 register (PRT1IC1)
01D7: 70 EF    AND   F,239         (0029) 	M8C_SetBank0
01D9: 62 05 00 MOV   REG[5],0      (0030) 	mov	reg[05h], 00h		; Port_1_IntEn register (PRT1IE)
01DC: 71 10    OR    F,16          (0031) 	M8C_SetBank1
01DE: 62 08 00 MOV   REG[8],0      (0032) 	mov	reg[08h], 00h		; Port_2_DriveMode_0 register (PRT2DM0)
01E1: 62 09 3F MOV   REG[9],63     (0033) 	mov	reg[09h], 3fh		; Port_2_DriveMode_1 register (PRT2DM1)
01E4: 70 EF    AND   F,239         (0034) 	M8C_SetBank0
01E6: 62 0B 3F MOV   REG[11],63    (0035) 	mov	reg[0bh], 3fh		; Port_2_DriveMode_2 register (PRT2DM2)
01E9: 62 0A 00 MOV   REG[10],0     (0036) 	mov	reg[0ah], 00h		; Port_2_GlobalSelect register (PRT2GS)
01EC: 71 10    OR    F,16          (0037) 	M8C_SetBank1
01EE: 62 0A 00 MOV   REG[10],0     (0038) 	mov	reg[0ah], 00h		; Port_2_IntCtrl_0 register (PRT2IC0)
01F1: 62 0B 00 MOV   REG[11],0     (0039) 	mov	reg[0bh], 00h		; Port_2_IntCtrl_1 register (PRT2IC1)
01F4: 70 EF    AND   F,239         (0040) 	M8C_SetBank0
01F6: 62 09 00 MOV   REG[9],0      (0041) 	mov	reg[09h], 00h		; Port_2_IntEn register (PRT2IE)
01F9: 71 10    OR    F,16          (0042) 	M8C_SetBank1
01FB: 62 0C 00 MOV   REG[12],0     (0043) 	mov	reg[0ch], 00h		; Port_3_DriveMode_0 register (PRT3DM0)
01FE: 62 0D FF MOV   REG[13],255   (0044) 	mov	reg[0dh], ffh		; Port_3_DriveMode_1 register (PRT3DM1)
0201: 70 EF    AND   F,239         (0045) 	M8C_SetBank0
0203: 62 0F F0 MOV   REG[15],240   (0046) 	mov	reg[0fh], f0h		; Port_3_DriveMode_2 register (PRT3DM2)
0206: 62 0E 00 MOV   REG[14],0     (0047) 	mov	reg[0eh], 00h		; Port_3_GlobalSelect register (PRT3GS)
0209: 71 10    OR    F,16          (0048) 	M8C_SetBank1
020B: 62 0E 00 MOV   REG[14],0     (0049) 	mov	reg[0eh], 00h		; Port_3_IntCtrl_0 register (PRT3IC0)
020E: 62 0F 00 MOV   REG[15],0     (0050) 	mov	reg[0fh], 00h		; Port_3_IntCtrl_1 register (PRT3IC1)
0211: 70 EF    AND   F,239         (0051) 	M8C_SetBank0
0213: 62 0D 00 MOV   REG[13],0     (0052) 	mov	reg[0dh], 00h		; Port_3_IntEn register (PRT3IE)
0216: 71 10    OR    F,16          (0053) 	M8C_SetBank1
0218: 62 10 00 MOV   REG[16],0     (0054) 	mov	reg[10h], 00h		; Port_4_DriveMode_0 register (PRT4DM0)
021B: 62 11 3F MOV   REG[17],63    (0055) 	mov	reg[11h], 3fh		; Port_4_DriveMode_1 register (PRT4DM1)
021E: 70 EF    AND   F,239         (0056) 	M8C_SetBank0
0220: 62 13 3F MOV   REG[19],63    (0057) 	mov	reg[13h], 3fh		; Port_4_DriveMode_2 register (PRT4DM2)
0223: 62 12 00 MOV   REG[18],0     (0058) 	mov	reg[12h], 00h		; Port_4_GlobalSelect register (PRT4GS)
0226: 71 10    OR    F,16          (0059) 	M8C_SetBank1
0228: 62 12 00 MOV   REG[18],0     (0060) 	mov	reg[12h], 00h		; Port_4_IntCtrl_0 register (PRT4IC0)
022B: 62 13 00 MOV   REG[19],0     (0061) 	mov	reg[13h], 00h		; Port_4_IntCtrl_1 register (PRT4IC1)
022E: 70 EF    AND   F,239         (0062) 	M8C_SetBank0
0230: 62 11 00 MOV   REG[17],0     (0063) 	mov	reg[11h], 00h		; Port_4_IntEn register (PRT4IE)
0233: 71 10    OR    F,16          (0064) 	M8C_SetBank1
0235: 62 14 FF MOV   REG[20],255   (0065) 	mov	reg[14h], ffh		; Port_5_DriveMode_0 register (PRT5DM0)
0238: 62 15 00 MOV   REG[21],0     (0066) 	mov	reg[15h], 00h		; Port_5_DriveMode_1 register (PRT5DM1)
023B: 70 EF    AND   F,239         (0067) 	M8C_SetBank0
023D: 62 17 00 MOV   REG[23],0     (0068) 	mov	reg[17h], 00h		; Port_5_DriveMode_2 register (PRT5DM2)
0240: 62 16 00 MOV   REG[22],0     (0069) 	mov	reg[16h], 00h		; Port_5_GlobalSelect register (PRT5GS)
0243: 71 10    OR    F,16          (0070) 	M8C_SetBank1
0245: 62 16 00 MOV   REG[22],0     (0071) 	mov	reg[16h], 00h		; Port_5_IntCtrl_0 register (PRT5IC0)
0248: 62 17 00 MOV   REG[23],0     (0072) 	mov	reg[17h], 00h		; Port_5_IntCtrl_1 register (PRT5IC1)
024B: 70 EF    AND   F,239         (0073) 	M8C_SetBank0
024D: 62 15 00 MOV   REG[21],0     (0074) 	mov	reg[15h], 00h		; Port_5_IntEn register (PRT5IE)
0250: 71 10    OR    F,16          (0075) 	M8C_SetBank1
0252: 62 1C 00 MOV   REG[28],0     (0076) 	mov	reg[1ch], 00h		; Port_7_DriveMode_0 register (PRT7DM0)
0255: 62 1D 81 MOV   REG[29],129   (0077) 	mov	reg[1dh], 81h		; Port_7_DriveMode_1 register (PRT7DM1)
0258: 70 EF    AND   F,239         (0078) 	M8C_SetBank0
025A: 62 1F 00 MOV   REG[31],0     (0079) 	mov	reg[1fh], 00h		; Port_7_DriveMode_2 register (PRT7DM2)
025D: 62 1E 00 MOV   REG[30],0     (0080) 	mov	reg[1eh], 00h		; Port_7_GlobalSelect register (PRT7GS)
0260: 71 10    OR    F,16          (0081) 	M8C_SetBank1
0262: 62 1E 00 MOV   REG[30],0     (0082) 	mov	reg[1eh], 00h		; Port_7_IntCtrl_0 register (PRT7IC0)
0265: 62 1F 00 MOV   REG[31],0     (0083) 	mov	reg[1fh], 00h		; Port_7_IntCtrl_1 register (PRT7IC1)
0268: 70 EF    AND   F,239         (0084) 	M8C_SetBank0
026A: 62 1D 00 MOV   REG[29],0     (0085) 	mov	reg[1dh], 00h		; Port_7_IntEn register (PRT7IE)
026D: 70 EF    AND   F,239         (0086) 	M8C_SetBank0
                                   (0087) ;  Global Register values
026F: 62 60 08 MOV   REG[96],8     (0088) 	mov	reg[60h], 08h		; AnalogColumnInputSelect register (AMX_IN)
0272: 62 66 00 MOV   REG[102],0    (0089) 	mov	reg[66h], 00h		; AnalogComparatorControl1 register (CMP_CR1)
0275: 62 61 C0 MOV   REG[97],192   (0090) 	mov	reg[61h], c0h		; AnalogMuxBusConfig register (AMUXCFG)
0278: 62 63 05 MOV   REG[99],5     (0091) 	mov	reg[63h], 05h		; AnalogReferenceControl register (ARF_CR)
027B: 62 65 00 MOV   REG[101],0    (0092) 	mov	reg[65h], 00h		; AnalogSyncControl register (ASY_CR)
027E: 62 FD 00 MOV   REG[253],0    (0093) 	mov	reg[fdh], 00h		; DAC_Data register (DAC_D)
0281: 62 E6 00 MOV   REG[230],0    (0094) 	mov	reg[e6h], 00h		; DecimatorControl_0 register (DEC_CR0)
0284: 62 E7 03 MOV   REG[231],3    (0095) 	mov	reg[e7h], 03h		; DecimatorControl_1 register (DEC_CR1)
0287: 62 56 00 MOV   REG[86],0     (0096) 	mov	reg[56h], 00h		; Endpoint0Control register (EP0_CR)
028A: 62 57 00 MOV   REG[87],0     (0097) 	mov	reg[57h], 00h		; Endpoint0Count register (EP0_CNT)
028D: 62 58 00 MOV   REG[88],0     (0098) 	mov	reg[58h], 00h		; Endpoint0Data0 register (EP0_DR0)
0290: 62 59 00 MOV   REG[89],0     (0099) 	mov	reg[59h], 00h		; Endpoint0Data1 register (EP0_DR1)
0293: 62 5A 00 MOV   REG[90],0     (0100) 	mov	reg[5ah], 00h		; Endpoint0Data2 register (EP0_DR2)
0296: 62 5B 00 MOV   REG[91],0     (0101) 	mov	reg[5bh], 00h		; Endpoint0Data3 register (EP0_DR3)
0299: 62 5C 00 MOV   REG[92],0     (0102) 	mov	reg[5ch], 00h		; Endpoint0Data4 register (EP0_DR4)
029C: 62 5D 00 MOV   REG[93],0     (0103) 	mov	reg[5dh], 00h		; Endpoint0Data5 register (EP0_DR5)
029F: 62 5E 00 MOV   REG[94],0     (0104) 	mov	reg[5eh], 00h		; Endpoint0Data6 register (EP0_DR6)
02A2: 62 5F 00 MOV   REG[95],0     (0105) 	mov	reg[5fh], 00h		; Endpoint0Data7 register (EP0_DR7)
02A5: 62 4F 00 MOV   REG[79],0     (0106) 	mov	reg[4fh], 00h		; Endpoint1Count0 register (EP1_CNT)
02A8: 62 4E 00 MOV   REG[78],0     (0107) 	mov	reg[4eh], 00h		; Endpoint1Count1 register (EP1_CNT1)
02AB: 62 51 00 MOV   REG[81],0     (0108) 	mov	reg[51h], 00h		; Endpoint2Count0 register (EP2_CNT)
02AE: 62 50 00 MOV   REG[80],0     (0109) 	mov	reg[50h], 00h		; Endpoint2Count1 register (EP2_CNT1)
02B1: 62 53 00 MOV   REG[83],0     (0110) 	mov	reg[53h], 00h		; Endpoint3Count0 register (EP3_CNT)
02B4: 62 52 00 MOV   REG[82],0     (0111) 	mov	reg[52h], 00h		; Endpoint3Count1 register (EP3_CNT1)
02B7: 62 55 00 MOV   REG[85],0     (0112) 	mov	reg[55h], 00h		; Endpoint4Count0 register (EP4_CNT)
02BA: 62 54 00 MOV   REG[84],0     (0113) 	mov	reg[54h], 00h		; Endpoint4Count1 register (EP4_CNT1)
02BD: 62 D6 04 MOV   REG[214],4    (0114) 	mov	reg[d6h], 04h		; I2CConfig register (I2CCFG)
02C0: 62 B0 00 MOV   REG[176],0    (0115) 	mov	reg[b0h], 00h		; Row_0_InputMux register (RDI0RI)
02C3: 62 B1 00 MOV   REG[177],0    (0116) 	mov	reg[b1h], 00h		; Row_0_InputSync register (RDI0SYN)
02C6: 62 B2 00 MOV   REG[178],0    (0117) 	mov	reg[b2h], 00h		; Row_0_LogicInputAMux register (RDI0IS)
02C9: 62 B3 33 MOV   REG[179],51   (0118) 	mov	reg[b3h], 33h		; Row_0_LogicSelect_0 register (RDI0LT0)
02CC: 62 B4 33 MOV   REG[180],51   (0119) 	mov	reg[b4h], 33h		; Row_0_LogicSelect_1 register (RDI0LT1)
02CF: 62 B5 00 MOV   REG[181],0    (0120) 	mov	reg[b5h], 00h		; Row_0_OutputDrive_0 register (RDI0SRO0)
02D2: 62 B6 00 MOV   REG[182],0    (0121) 	mov	reg[b6h], 00h		; Row_0_OutputDrive_1 register (RDI0SRO1)
02D5: 62 4A 00 MOV   REG[74],0     (0122) 	mov	reg[4ah], 00h		; USBControl_0 register (USB_CR0)
02D8: 62 4B 00 MOV   REG[75],0     (0123) 	mov	reg[4bh], 00h		; USBIOControl_0 register (USBIO_CR0)
02DB: 62 4C 00 MOV   REG[76],0     (0124) 	mov	reg[4ch], 00h		; USBIOControl_1 register (USBIO_CR1)
                                   (0125) ;  Instance name ADCINC12_1, User Module ADCINC12
                                   (0126) ;       Instance name ADCINC12_1, Block Name ADC(ASC10)
02DE: 62 80 90 MOV   REG[128],144  (0127) 	mov	reg[80h], 90h		;ADCINC12_1_AtoDcr0(ASC10CR0)
02E1: 62 81 00 MOV   REG[129],0    (0128) 	mov	reg[81h], 00h		;ADCINC12_1_AtoDcr1(ASC10CR1)
02E4: 62 82 60 MOV   REG[130],96   (0129) 	mov	reg[82h], 60h		;ADCINC12_1_AtoDcr2(ASC10CR2)
02E7: 62 83 F0 MOV   REG[131],240  (0130) 	mov	reg[83h], f0h		;ADCINC12_1_AtoDcr3(ASC10CR3)
                                   (0131) ;       Instance name ADCINC12_1, Block Name CNT(DBB01)
02EA: 62 27 00 MOV   REG[39],0     (0132) 	mov	reg[27h], 00h		;ADCINC12_1_CounterCR0(DBB01CR0)
02ED: 62 25 00 MOV   REG[37],0     (0133) 	mov	reg[25h], 00h		;ADCINC12_1_CounterDR1(DBB01DR1)
02F0: 62 26 00 MOV   REG[38],0     (0134) 	mov	reg[26h], 00h		;ADCINC12_1_CounterDR2(DBB01DR2)
                                   (0135) ;       Instance name ADCINC12_1, Block Name TMR(DBB00)
02F3: 62 23 00 MOV   REG[35],0     (0136) 	mov	reg[23h], 00h		;ADCINC12_1_TimerCR0(DBB00CR0)
02F6: 62 21 00 MOV   REG[33],0     (0137) 	mov	reg[21h], 00h		;ADCINC12_1_TimerDR1(DBB00DR1)
02F9: 62 22 00 MOV   REG[34],0     (0138) 	mov	reg[22h], 00h		;ADCINC12_1_TimerDR2(DBB00DR2)
                                   (0139) ;  Instance name Counter8_1, User Module Counter8
                                   (0140) ;       Instance name Counter8_1, Block Name CNTR8(DCB03)
02FC: 62 2F 00 MOV   REG[47],0     (0141) 	mov	reg[2fh], 00h		;Counter8_1_CONTROL_REG(DCB03CR0)
02FF: 62 2D FF MOV   REG[45],255   (0142) 	mov	reg[2dh], ffh		;Counter8_1_PERIOD_REG(DCB03DR1)
0302: 62 2E 80 MOV   REG[46],128   (0143) 	mov	reg[2eh], 80h		;Counter8_1_COMPARE_REG(DCB03DR2)
                                   (0144) ;  Instance name I2CHW_1, User Module I2CHW
                                   (0145) ;  Instance name LED7SEG_1, User Module LED7SEG
                                   (0146) ;       Instance name LED7SEG_1, Block Name MPXTMR(DCB02)
0305: 62 2B 04 MOV   REG[43],4     (0147) 	mov	reg[2bh], 04h		;LED7SEG_1_CONTROL_REG(DCB02CR0)
0308: 62 29 3F MOV   REG[41],63    (0148) 	mov	reg[29h], 3fh		;LED7SEG_1_(DCB02DR1)
030B: 62 2A 15 MOV   REG[42],21    (0149) 	mov	reg[2ah], 15h		;LED7SEG_1_(DCB02DR2)
                                   (0150) ;  Instance name PGA_1, User Module PGA
                                   (0151) ;       Instance name PGA_1, Block Name GAIN(ACB00)
030E: 62 71 FE MOV   REG[113],254  (0152) 	mov	reg[71h], feh		;PGA_1_GAIN_CR0(ACB00CR0)
0311: 62 72 21 MOV   REG[114],33   (0153) 	mov	reg[72h], 21h		;PGA_1_GAIN_CR1(ACB00CR1)
0314: 62 73 20 MOV   REG[115],32   (0154) 	mov	reg[73h], 20h		;PGA_1_GAIN_CR2(ACB00CR2)
0317: 62 70 00 MOV   REG[112],0    (0155) 	mov	reg[70h], 00h		;PGA_1_GAIN_CR3(ACB00CR3)
031A: 71 10    OR    F,16          (0156) 	M8C_SetBank1
                                   (0157) ;  Global Register values
031C: 62 61 00 MOV   REG[97],0     (0158) 	mov	reg[61h], 00h		; AnalogClockSelect1 register (CLK_CR1)
031F: 62 69 00 MOV   REG[105],0    (0159) 	mov	reg[69h], 00h		; AnalogClockSelect2 register (CLK_CR2)
0322: 62 60 01 MOV   REG[96],1     (0160) 	mov	reg[60h], 01h		; AnalogColumnClockSelect register (CLK_CR0)
0325: 62 62 00 MOV   REG[98],0     (0161) 	mov	reg[62h], 00h		; AnalogIOControl_0 register (ABF_CR0)
0328: 62 67 33 MOV   REG[103],51   (0162) 	mov	reg[67h], 33h		; AnalogLUTControl0 register (ALT_CR0)
032B: 62 68 00 MOV   REG[104],0    (0163) 	mov	reg[68h], 00h		; AnalogLUTControl1 register (ALT_CR1)
032E: 62 63 00 MOV   REG[99],0     (0164) 	mov	reg[63h], 00h		; AnalogModulatorControl_0 register (AMD_CR0)
0331: 62 66 00 MOV   REG[102],0    (0165) 	mov	reg[66h], 00h		; AnalogModulatorControl_1 register (AMD_CR1)
0334: 62 64 00 MOV   REG[100],0    (0166) 	mov	reg[64h], 00h		; ComparatorGlobalOutEn register (CMP_GO_EN)
0337: 62 64 00 MOV   REG[100],0    (0167) 	mov	reg[64h], 00h		; ComparatorGlobalOutEn1 register (CMP_GO_EN1)
033A: 62 FD 00 MOV   REG[253],0    (0168) 	mov	reg[fdh], 00h		; DAC_Control register (DAC_CR)
033D: 62 C4 00 MOV   REG[196],0    (0169) 	mov	reg[c4h], 00h		; Endpoint1Control register (EP1_CR)
0340: 62 C5 00 MOV   REG[197],0    (0170) 	mov	reg[c5h], 00h		; Endpoint2Control register (EP2_CR)
0343: 62 C6 00 MOV   REG[198],0    (0171) 	mov	reg[c6h], 00h		; Endpoint3Control register (EP3_CR)
0346: 62 C7 00 MOV   REG[199],0    (0172) 	mov	reg[c7h], 00h		; Endpoint4Control register (EP4_CR)
0349: 62 D1 00 MOV   REG[209],0    (0173) 	mov	reg[d1h], 00h		; GlobalDigitalInterconnect_Drive_Even_Input register (GDI_E_IN)
034C: 62 D3 00 MOV   REG[211],0    (0174) 	mov	reg[d3h], 00h		; GlobalDigitalInterconnect_Drive_Even_Output register (GDI_E_OU)
034F: 62 D0 00 MOV   REG[208],0    (0175) 	mov	reg[d0h], 00h		; GlobalDigitalInterconnect_Drive_Odd_Input register (GDI_O_IN)
0352: 62 D2 00 MOV   REG[210],0    (0176) 	mov	reg[d2h], 00h		; GlobalDigitalInterconnect_Drive_Odd_Output register (GDI_O_OU)
0355: 62 E1 F0 MOV   REG[225],240  (0177) 	mov	reg[e1h], f0h		; OscillatorControl_1 register (OSC_CR1)
0358: 62 E2 00 MOV   REG[226],0    (0178) 	mov	reg[e2h], 00h		; OscillatorControl_2 register (OSC_CR2)
035B: 62 DF 09 MOV   REG[223],9    (0179) 	mov	reg[dfh], 09h		; OscillatorControl_3 register (OSC_CR3)
035E: 62 DE 00 MOV   REG[222],0    (0180) 	mov	reg[deh], 00h		; OscillatorControl_4 register (OSC_CR4)
0361: 62 DD 00 MOV   REG[221],0    (0181) 	mov	reg[ddh], 00h		; OscillatorGlobalBusEnableControl register (OSC_GO_EN)
0364: 62 D8 00 MOV   REG[216],0    (0182) 	mov	reg[d8h], 00h		; Port_0_MUXBusCtrl register (MUX_CR0)
0367: 62 D9 00 MOV   REG[217],0    (0183) 	mov	reg[d9h], 00h		; Port_1_MUXBusCtrl register (MUX_CR1)
036A: 62 DA 00 MOV   REG[218],0    (0184) 	mov	reg[dah], 00h		; Port_2_MUXBusCtrl register (MUX_CR2)
036D: 62 DB 00 MOV   REG[219],0    (0185) 	mov	reg[dbh], 00h		; Port_3_MUXBusCtrl register (MUX_CR3)
0370: 62 EC 01 MOV   REG[236],1    (0186) 	mov	reg[ech], 01h		; Port_4_MUXBusCtrl register (MUX_CR4)
0373: 62 ED 00 MOV   REG[237],0    (0187) 	mov	reg[edh], 00h		; Port_5_MUXBusCtrl register (MUX_CR5)
0376: 62 E7 00 MOV   REG[231],0    (0188) 	mov	reg[e7h], 00h		; Type2Decimator_Control register (DEC_CR2)
0379: 62 C1 00 MOV   REG[193],0    (0189) 	mov	reg[c1h], 00h		; USBControl_1 register (USB_CR1)
                                   (0190) ;  Instance name ADCINC12_1, User Module ADCINC12
                                   (0191) ;       Instance name ADCINC12_1, Block Name ADC(ASC10)
                                   (0192) ;       Instance name ADCINC12_1, Block Name CNT(DBB01)
037C: 62 24 21 MOV   REG[36],33    (0193) 	mov	reg[24h], 21h		;ADCINC12_1_CounterFN(DBB01FN)
037F: 62 25 45 MOV   REG[37],69    (0194) 	mov	reg[25h], 45h		;ADCINC12_1_CounterSL(DBB01IN)
0382: 62 26 40 MOV   REG[38],64    (0195) 	mov	reg[26h], 40h		;ADCINC12_1_CounterOS(DBB01OU)
                                   (0196) ;       Instance name ADCINC12_1, Block Name TMR(DBB00)
0385: 62 20 20 MOV   REG[32],32    (0197) 	mov	reg[20h], 20h		;ADCINC12_1_TimerFN(DBB00FN)
0388: 62 21 15 MOV   REG[33],21    (0198) 	mov	reg[21h], 15h		;ADCINC12_1_TimerSL(DBB00IN)
038B: 62 22 40 MOV   REG[34],64    (0199) 	mov	reg[22h], 40h		;ADCINC12_1_TimerOS(DBB00OU)
                                   (0200) ;  Instance name Counter8_1, User Module Counter8
                                   (0201) ;       Instance name Counter8_1, Block Name CNTR8(DCB03)
038E: 62 2C 21 MOV   REG[44],33    (0202) 	mov	reg[2ch], 21h		;Counter8_1_FUNC_REG(DCB03FN)
0391: 62 2D 11 MOV   REG[45],17    (0203) 	mov	reg[2dh], 11h		;Counter8_1_INPUT_REG(DCB03IN)
0394: 62 2E 40 MOV   REG[46],64    (0204) 	mov	reg[2eh], 40h		;Counter8_1_OUTPUT_REG(DCB03OU)
                                   (0205) ;  Instance name I2CHW_1, User Module I2CHW
                                   (0206) ;  Instance name LED7SEG_1, User Module LED7SEG
                                   (0207) ;       Instance name LED7SEG_1, Block Name MPXTMR(DCB02)
0397: 62 28 20 MOV   REG[40],32    (0208) 	mov	reg[28h], 20h		;LED7SEG_1_(DCB02FN)
039A: 62 29 17 MOV   REG[41],23    (0209) 	mov	reg[29h], 17h		;LED7SEG_1_(DCB02IN)
039D: 62 2A 40 MOV   REG[42],64    (0210) 	mov	reg[2ah], 40h		;LED7SEG_1_(DCB02OU)
                                   (0211) ;  Instance name PGA_1, User Module PGA
                                   (0212) ;       Instance name PGA_1, Block Name GAIN(ACB00)
03A0: 70 EF    AND   F,239         (0213) 	M8C_SetBank0
03A2: 7F       RET                 (0214) 	ret

FILE: lib\psocconfig.asm
                                   (0001) ; Generated by PSoC Designer ver 4.4  b1884 : 14 Jan, 2007
                                   (0002) ;
                                   (0003) ;==========================================================================
                                   (0004) ;  PSoCConfig.asm
                                   (0005) ;  @PSOC_VERSION
                                   (0006) ;
                                   (0007) ;  Version: 0.85
                                   (0008) ;  Revised: June 22, 2004
                                   (0009) ;  Copyright Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0010) ;
                                   (0011) ;  This file is generated by the Device Editor on Application Generation.
                                   (0012) ;  It contains code which loads the configuration data table generated in
                                   (0013) ;  the file PSoCConfigTBL.asm
                                   (0014) ;
                                   (0015) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                   (0016) ;  Edits to this file will not be preserved.
                                   (0017) ;==========================================================================
                                   (0018) ;
                                   (0019) include "m8c.inc"
                                   (0020) include "memory.inc"
                                   (0021) include "GlobalParams.inc"
                                   (0022) 
                                   (0023) export LoadConfigInit
                                   (0024) export _LoadConfigInit
                                   (0025) export LoadConfig_radyopnl
                                   (0026) export _LoadConfig_radyopnl
                                   (0027) export Port_0_Data_SHADE
                                   (0028) export _Port_0_Data_SHADE
                                   (0029) 
                                   (0030) 
                                   (0031) export NO_SHADOW
                                   (0032) export _NO_SHADOW
                                   (0033) 
                                   (0034) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
                                   (0035) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
                                   (0036) 
                                   (0037) AREA psoc_config(rom, rel)
                                   (0038) 
                                   (0039) 
                                   (0040) ;---------------------------------------------------------------------------
                                   (0041) ; LoadConfigInit - Establish the start-up configuration (except for a few
                                   (0042) ;                  parameters handled by boot code, like CPU speed). This
                                   (0043) ;                  function can be called from user code, but typically it
                                   (0044) ;                  is only called from boot.
                                   (0045) ;
                                   (0046) ;       INPUTS: None.
                                   (0047) ;      RETURNS: Nothing.
                                   (0048) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
                                   (0049) ;               In the large memory model currently only the page
                                   (0050) ;               pointer registers listed below are modified.  This does
                                   (0051) ;               not guarantee that in future implementations of this
                                   (0052) ;               function other page pointer registers will not be
                                   (0053) ;               modified.
                                   (0054) ;          
                                   (0055) ;               Page Pointer Registers Modified: 
                                   (0056) ;               CUR_PP
                                   (0057) ;
                                   (0058) _LoadConfigInit:
                                   (0059)  LoadConfigInit:
                                   (0060)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0061)     
03A3: 55 00 00 MOV   [0],0         (0062) 	mov		[Port_0_Data_SHADE], 0h
                                   (0063) 
03A6: 7C 03 AA LCALL 0x03AA        (0064) 	lcall	LoadConfig_radyopnl
                                   (0065) 
                                   (0066) 
                                   (0067)     RAM_EPILOGUE RAM_USE_CLASS_4
03A9: 7F       RET                 (0068)     ret
                                   (0069) 
                                   (0070) ;---------------------------------------------------------------------------
                                   (0071) ; Load Configuration radyopnl
                                   (0072) ;
                                   (0073) ;    Load configuration registers for radyopnl.
                                   (0074) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (0075) ;
                                   (0076) ;       INPUTS: None.
                                   (0077) ;      RETURNS: Nothing.
                                   (0078) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                   (0079) ;               modified as may the Page Pointer registers!
                                   (0080) ;               In the large memory model currently only the page
                                   (0081) ;               pointer registers listed below are modified.  This does
                                   (0082) ;               not guarantee that in future implementations of this
                                   (0083) ;               function other page pointer registers will not be
                                   (0084) ;               modified.
                                   (0085) ;          
                                   (0086) ;               Page Pointer Registers Modified: 
                                   (0087) ;               CUR_PP
                                   (0088) ;
                                   (0089) _LoadConfig_radyopnl:
                                   (0090)  LoadConfig_radyopnl:
                                   (0091)     RAM_PROLOGUE RAM_USE_CLASS_4
03AA: 7C 01 A2 LCALL 0x01A2        (0092)     lcall   LoadConfigTBL_radyopnl            ; Call load config table routine
                                   (0093) 
                                   (0094) 
03AD: 70 EF    AND   F,239         (0095)     M8C_SetBank0                    ; Force return to bank 0
                                   (0096)     RAM_EPILOGUE RAM_USE_CLASS_4
03AF: 7F       RET                 (0097)     ret

FILE: lib\pga_1.asm
                                   (0001) ;;*****************************************************************************
                                   (0002) ;;*****************************************************************************
                                   (0003) ;;  FILENAME:   PGA_1.asm  ( PGA )
                                   (0004) ;;  Version: 3.2, Updated on 2006/01/14 at 16:06:54
                                   (0005) ;;  Generated by PSoC Designer ver 4.4  b1884 : 14 Jan, 2007
                                   (0006) ;;
                                   (0007) ;;  DESCRIPTION:  PGA User Module software implementation file for the
                                   (0008) ;;                22/24/27/29xxx PSoC family of devices.
                                   (0009) ;;
                                   (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0012) ;;        This means it is the caller's responsibility to preserve any values
                                   (0013) ;;        in the X and A registers that are still needed after the API functions
                                   (0014) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0018) ;;-----------------------------------------------------------------------------
                                   (0019) ;;  Copyright (c) Cypress MicroSystems 2004. All Rights Reserved.
                                   (0020) ;;*****************************************************************************
                                   (0021) ;;*****************************************************************************
                                   (0022) 
                                   (0023) ;; -----------------------------------------------------------------
                                   (0024) ;;                         Register Definitions
                                   (0025) ;;
                                   (0026) ;; Uses 1 Continuous Time Block configured as shown.
                                   (0027) ;;
                                   (0028) ;; * For a Mask/Val pair, this indicates that the value is
                                   (0029) ;;   determined by the user either through config-time parameteriza-
                                   (0030) ;;   tion or run-time manipulation.
                                   (0031) ;;
                                   (0032) ;; BIT FIELD             Mask/Val Function
                                   (0033) ;; -----------------            -----   --------------------
                                   (0034) ;; GAIN_CR0.RES_RATIO_T2B       F0/*    User Parameter (by table)
                                   (0035) ;; GAIN_CR0.GAIN_ATTEN          08/*    Gain (by table)
                                   (0036) ;; GAIN_CR0.RES_SOURCE          04/1    Res source to output
                                   (0037) ;; GAIN_CR0.RES_REF             03/*    Res ref
                                   (0038) ;;
                                   (0039) ;; GAIN_CR1.A_OUT               80/*    User Parameter (Output bus)
                                   (0040) ;; GAIN_CR1.COMP_EN             40/0    Comparator bus disabled
                                   (0041) ;; GAIN_CR1.CT_NEG_INPUT_MUX    38/4    Neg mux to analog f.b. tap
                                   (0042) ;; GAIN_CR1.CT_POS_INPUT_MUX    07/*    Pos mux, typically to col. input mux
                                   (0043) ;;
                                   (0044) ;; GAIN_CR2.CP_COMP             80/0    Latch transparent on PH1
                                   (0045) ;; GAIN_CR2.CK_COMP             40/0    Latch transparent
                                   (0046) ;; GAIN_CR2.CC_COMP             20/1    Mode OP-AMP (not comparator)
                                   (0047) ;; GAIN_CR2.BYPASS_OBUS         1C/0    Bypass OFF
                                   (0048) ;; GAIN_CR2.PWR_SELECT          03/*    Power OFF (0h) at start-up
                                   (0049) ;;
                                   (0050) ;; --------------------------------------------------------------------
                                   (0051) 
                                   (0052) include "PGA_1.inc"
                                   (0053) include "m8c.inc"
                                   (0054) include "memory.inc"
                                   (0055) 
                                   (0056) 
                                   (0057) ;-----------------------------------------------
                                   (0058) ;  Global Symbols
                                   (0059) ;-----------------------------------------------
                                   (0060) export  PGA_1_Start
                                   (0061) export _PGA_1_Start
                                   (0062) export  PGA_1_SetPower
                                   (0063) export _PGA_1_SetPower
                                   (0064) 
                                   (0065) export  PGA_1_SetGain
                                   (0066) export _PGA_1_SetGain
                                   (0067) 
                                   (0068) export  PGA_1_Stop
                                   (0069) export _PGA_1_Stop
                                   (0070) 
                                   (0071) ;-----------------------------------------------
                                   (0072) ;  EQUATES
                                   (0073) ;-----------------------------------------------
                                   (0074) POWERMASK:     equ 03h
                                   (0075) GAINREGMASK:   equ f8h
                                   (0076) GAINMASK:      equ fCh
                                   (0077) HIGHGAIN:      equ 04h
                                   (0078) HIGHGAINMASK:  equ 18h
                                   (0079) EXGAIN:        equ 01h
                                   (0080) 
                                   (0081) AREA UserModules (ROM, REL)
                                   (0082) .SECTION
                                   (0083) ;-----------------------------------------------------------------------------
                                   (0084) ;  FUNCTION NAME: PGA_1_Start
                                   (0085) ;  FUNCTION NAME: PGA_1_SetPower
                                   (0086) ;
                                   (0087) ;  DESCRIPTION:
                                   (0088) ;    Applies power setting to the module's PSoC block.
                                   (0089) ;-----------------------------------------------------------------------------
                                   (0090) ;
                                   (0091) ;  ARGUMENTS:
                                   (0092) ;  A  Contains the power settings 0=Off, 1=Low, 2=Med, and 3=High
                                   (0093) ;
                                   (0094) ;  RETURNS:  NA
                                   (0095) ;
                                   (0096) ;  SIDE EFFECTS:
                                   (0097) ;    The A and X registers may be modified by this or future implementations
                                   (0098) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0099) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0100) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0101) ;    functions.
                                   (0102) ;
                                   (0103)  PGA_1_Start:
                                   (0104) _PGA_1_Start:
                                   (0105)  PGA_1_SetPower:
                                   (0106) _PGA_1_SetPower:
                                   (0107) 
                                   (0108)    RAM_PROLOGUE RAM_USE_CLASS_2
03B0: 21 03    AND   A,3           (0109)    and  A, POWERMASK                                 ; mask A to protect unchanged bits
03B2: 4F       MOV   X,SP          (0110)    mov  X, SP                                        ; define temp store location
                                   (0111) ;
03B3: 08       PUSH  A             (0112)    push A                                            ; put power value in temp store
03B4: 5D 73    MOV   A,REG[115]    (0113)    mov  A, reg[PGA_1_GAIN_CR2]                             ; read power value
03B6: 21 FC    AND   A,252         (0114)    and  A, ~POWERMASK                                ; clear power bits in A
03B8: 2B 00    OR    A,[X+0]       (0115)    or   A, [X]                                       ; combine power value with balance of reg.
03BA: 60 73    MOV   REG[115],A    (0116)    mov  reg[PGA_1_GAIN_CR2], A                        ; move complete value back to register
03BC: 18       POP   A             (0117)    pop  A
03BD: 70 3F    AND   F,63
03BF: 71 C0    OR    F,192         (0118)    RAM_EPILOGUE RAM_USE_CLASS_2
03C1: 7F       RET                 (0119)    ret
                                   (0120) .ENDSECTION
                                   (0121) 
                                   (0122) .SECTION
                                   (0123) ;-----------------------------------------------------------------------------
                                   (0124) ;  FUNCTION NAME: PGA_1_SetGain
                                   (0125) ;
                                   (0126) ;  DESCRIPTION:
                                   (0127) ;    This function sets the Gain/Atten of the amplifier.  Valid gain settings
                                   (0128) ;    are defined in the .inc file.
                                   (0129) ;
                                   (0130) ;-----------------------------------------------------------------------------
                                   (0131) ;
                                   (0132) ;  ARGUMENTS:
                                   (0133) ;    A  Contains gain settings.
                                   (0134) ;
                                   (0135) ;    Gain values shown are for example. (See .inc file for gain equates)
                                   (0136) ;
                                   (0137) ;  RETURNS:  NA
                                   (0138) ;
                                   (0139) ;  SIDE EFFECTS:
                                   (0140) ;    The A and X registers may be modified by this or future implementations
                                   (0141) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0142) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0143) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0144) ;    functions.
                                   (0145) ;
                                   (0146)  PGA_1_SetGain:
                                   (0147) _PGA_1_SetGain:
                                   (0148) 
                                   (0149)    RAM_PROLOGUE RAM_USE_CLASS_2
03C2: 21 FC    AND   A,252         (0150)    and  A, GAINMASK                                       ; mask A to protect unchanged bits
03C4: 4F       MOV   X,SP          (0151)    mov  X, SP                                             ; define temp store location
                                   (0152) ;
03C5: 08       PUSH  A             (0153)    push A                                                 ; put gain value in temp store
03C6: 5D 71    MOV   A,REG[113]    (0154)    mov  A, reg[PGA_1_GAIN_CR0]                             ; read mux settings
03C8: 21 07    AND   A,7           (0155)    and  A, ~GAINREGMASK                                   ; clear gain bits in A
03CA: 48 00 04 TST   [X+0],4       (0156)    tst  [X],HIGHGAIN                                      ; See if High Gain is set
03CD: B0 0E    JNZ   0x03DC        (0157)    jnz  .SETHIGHGAIN
03CF: 41 70 FE AND   REG[112],254  (0158)    and  reg[PGA_1_GAIN_CR3],~EXGAIN                        ; Clear High Gain bit.
03D2: 2B 00    OR    A,[X+0]       (0159)    or   A, [X]                                            ; combine gain value with balance of reg.
03D4: 60 71    MOV   REG[113],A    (0160)    mov  reg[PGA_1_GAIN_CR0], A                             ; move complete value back to register
03D6: 18       POP   A             (0161)    pop  A
03D7: 70 3F    AND   F,63
03D9: 71 C0    OR    F,192         (0162)    RAM_EPILOGUE RAM_USE_CLASS_2
03DB: 7F       RET                 (0163)    ret
                                   (0164) 
                                   (0165) .SETHIGHGAIN:
03DC: 27 00 18 AND   [X+0],24      (0166)    and  [X],HIGHGAINMASK                                  ; Make sure we have a valid high gain
03DF: 2B 00    OR    A,[X+0]       (0167)    or   A, [X]                                            ; combine gain value with balance of reg.
03E1: 60 71    MOV   REG[113],A    (0168)    mov  reg[PGA_1_GAIN_CR0], A                             ; move complete value back to register
03E3: 43 70 01 OR    REG[112],1    (0169)    or   reg[PGA_1_GAIN_CR3], EXGAIN                        ; Set High Gain bit.
03E6: 18       POP   A             (0170)    pop  A
03E7: 70 3F    AND   F,63
03E9: 71 C0    OR    F,192         (0171)    RAM_EPILOGUE RAM_USE_CLASS_2
03EB: 7F       RET                 (0172)    ret
                                   (0173) .ENDSECTION
                                   (0174) 
                                   (0175) .SECTION
                                   (0176) ;-----------------------------------------------------------------------------
                                   (0177) ;  FUNCTION NAME: PGA_1_Stop
                                   (0178) ;
                                   (0179) ;  DESCRIPTION:
                                   (0180) ;    Turns off the power to the amplifier.
                                   (0181) ;
                                   (0182) ;-----------------------------------------------------------------------------
                                   (0183) ;
                                   (0184) ;  ARGUMENTS: None
                                   (0185) ;
                                   (0186) ;  RETURNS:  NA
                                   (0187) ;
                                   (0188) ;  SIDE EFFECTS:
                                   (0189) ;    The A and X registers may be modified by this or future implementations
                                   (0190) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0191) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0192) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0193) ;    functions.
                                   (0194) ;
                                   (0195)  PGA_1_Stop:
                                   (0196) _PGA_1_Stop:
                                   (0197) 
                                   (0198)    RAM_PROLOGUE RAM_USE_CLASS_1
03EC: 41 73 FC AND   REG[115],252  (0199)    and REG[PGA_1_GAIN_CR2], ~POWERMASK
                                   (0200)    RAM_EPILOGUE RAM_USE_CLASS_1
03EF: 7F       RET                 (0201)    ret

FILE: lib\led7seg_1int.asm
                                   (0001) ;;*****************************************************************************
                                   (0002) ;;*****************************************************************************
                                   (0003) ;;  FILENAME: LED7SEG_1INT.asm
                                   (0004) ;;   Version: 1.0, Updated on 2006/06/14 at 07:47:37
                                   (0005) ;;  Generated by PSoC Designer ver 4.4  b1884 : 14 Jan, 2007
                                   (0006) ;;
                                   (0007) ;;  DESCRIPTION: LED7SEG Interrupt Service Routine
                                   (0008) ;;-----------------------------------------------------------------------------
                                   (0009) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0010) ;;*****************************************************************************
                                   (0011) ;;*****************************************************************************
                                   (0012) 
                                   (0013) include "m8c.inc"
                                   (0014) include "memory.inc"
                                   (0015) include "LED7SEG_1.inc"
                                   (0016) 
                                   (0017) 
                                   (0018) ;-----------------------------------------------
                                   (0019) ;  Global Symbols
                                   (0020) ;-----------------------------------------------
                                   (0021) export  _LED7SEG_1_ISR
                                   (0022) 
                                   (0023) 
                                   (0024) AREA InterruptRAM (RAM,REL,CON)
                                   (0025) 
                                   (0026) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                   (0027) ;---------------------------------------------------
                                   (0028) ; Insert your custom declarations below this banner
                                   (0029) ;---------------------------------------------------
                                   (0030) 
                                   (0031) ;------------------------
                                   (0032) ; Includes
                                   (0033) ;------------------------
                                   (0034) 
                                   (0035) 	
                                   (0036) ;------------------------
                                   (0037) ;  Constant Definitions
                                   (0038) ;------------------------
                                   (0039) 
                                   (0040) 
                                   (0041) ;------------------------
                                   (0042) ; Variable Allocation
                                   (0043) ;------------------------
                                   (0044) 
                                   (0045) 
                                   (0046) ;---------------------------------------------------
                                   (0047) ; Insert your custom declarations above this banner
                                   (0048) ;---------------------------------------------------
                                   (0049) ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0050) 
                                   (0051) 
                                   (0052) AREA UserModules (ROM, REL)
                                   (0053) 
                                   (0054) ;-----------------------------------------------------------------------------
                                   (0055) ;  FUNCTION NAME: _LED7SEG_1_ISR
                                   (0056) ;
                                   (0057) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
                                   (0058) ;
                                   (0059) ;-----------------------------------------------------------------------------
                                   (0060) ;
                                   (0061) 
                                   (0062) _LED7SEG_1_ISR:
                                   (0063) 
03F0: 7C 04 69 LCALL 0x0469        (0064)    lcall  LED7SEG_1_Update   ; A and X are preserved for this call.
                                   (0065) 
                                   (0066)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0067)    ;---------------------------------------------------
                                   (0068)    ; Insert your custom code below this banner
                                   (0069)    ;---------------------------------------------------
                                   (0070)    ;   NOTE: interrupt service routines must preserve
                                   (0071)    ;   the values of the A and X CPU registers.
                                   (0072)    ;---------------------------------------------------
                                   (0073) 
                                   (0074) 
                                   (0075)    ;---------------------------------------------------
                                   (0076)    ; Insert your custom code above this banner
                                   (0077)    ;---------------------------------------------------
                                   (0078)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0079) 
03F3: 7E       RETI                (0080)    reti
03F4: 3F 06    MVI   [6],A
03F6: 5B       MOV   A,X
03F7: 4F       MOV   X,SP
03F8: 66 6D    ASL   [X+109]
03FA: 7D 07 7F LJMP  0x077F
03FD: 6F 77    RRC   [X+119]
03FF: 7C 39 5E LCALL 0x395E
0402: 79       DEC   X
0403: 71 40    OR    F,64
0405: 01 02    ADD   A,2
0407: 04 08    ADD   [8],A
0409: 10       PUSH  X
040A: 20       POP   X
040B: 40       NOP   
040C: 80 00    JMP   0x040D
040E: 01 00    ADD   A,0
0410: 0A 00    ADC   A,[0]
0412: 64       ASL   A
0413: 03 E8    ADD   A,[X-24]
0415: 27 10 70 AND   [X+16],112

FILE: lib\led7seg_1.asm
                                   (0001) ;;*****************************************************************************
                                   (0002) ;;*****************************************************************************
                                   (0003) ;;  FILENAME:   LED7SEG_1.asm
                                   (0004) ;;  Version: 1.0, Updated on 2006/06/14 at 07:47:37
                                   (0005) ;;  Generated by PSoC Designer ver 4.4  b1884 : 14 Jan, 2007
                                   (0006) ;;
                                   (0007) ;;  DESCRIPTION: Seven Segment LCD user module for 22/24/27/29xxx PSoC family of devices.
                                   (0008) ;;
                                   (0009) ;; This set of functions is written to dirve from 1 to 8 seven segment displays.
                                   (0010) ;;
                                   (0011) ;;  LCD connections to PSoC port
                                   (0012) ;;
                                   (0013) ;;    PX.0 ==> LED a                      a
                                   (0014) ;;    PX.1 ==> LED b                    =====
                                   (0015) ;;    PX.2 ==> LED c                   ||   || b
                                   (0016) ;;    PX.3 ==> LED d                 f || g ||
                                   (0017) ;;    PX.4 ==> LED e                    =====
                                   (0018) ;;    PX.5 ==> LED f                   ||   || c
                                   (0019) ;;    PX.6 ==> LED g                 e ||   ||
                                   (0020) ;;    PX.7 ==> LED dp                   =====  # dp
                                   (0021) ;;                                        d     
                                   (0022) ;;    PY.0 ==> Digit 1
                                   (0023) ;;    PY.1 ==> Digit 2
                                   (0024) ;;    PY.2 ==> Digit 3         Digit Number
                                   (0025) ;;    PY.3 ==> Digit 4        +---+---+---+---+---+---+---+---+
                                   (0026) ;;    PY.4 ==> Digit 5        | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
                                   (0027) ;;    PY.5 ==> Digit 6        +---+---+---+---+---+---+---+---+
                                   (0028) ;;    PY.6 ==> Digit 7
                                   (0029) ;;    PY.7 ==> Digit 8
                                   (0030) ;;
                                   (0031) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0032) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0033) ;;        This means it is the caller's responsibility to preserve any values
                                   (0034) ;;        in the X and A registers that are still needed after the API functions
                                   (0035) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0036) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0037) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0038) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0039) ;;-----------------------------------------------------------------------------
                                   (0040) ;;  Copyright (c) Cypress MicroSystems 2001-2004. All Rights Reserved.
                                   (0041) ;;*****************************************************************************
                                   (0042) ;;*****************************************************************************
                                   (0043) 
                                   (0044) include "LED7SEG_1.inc"
                                   (0045) include "memory.inc"
                                   (0046) 
                                   (0047) export _LED7SEG_1_Start
                                   (0048) export  LED7SEG_1_Start
                                   (0049) 
                                   (0050) export _LED7SEG_1_Stop
                                   (0051) export  LED7SEG_1_Stop
                                   (0052) 
                                   (0053) export _LED7SEG_1_Dim
                                   (0054) export  LED7SEG_1_Dim
                                   (0055) 
                                   (0056) export _LED7SEG_1_Update
                                   (0057) export  LED7SEG_1_Update
                                   (0058) 
                                   (0059) export _LED7SEG_1_PutHex
                                   (0060) export  LED7SEG_1_PutHex
                                   (0061) 
                                   (0062) export _LED7SEG_1_PutPattern
                                   (0063) export  LED7SEG_1_PutPattern
                                   (0064) 
                                   (0065) export _LED7SEG_1_DP
                                   (0066) export  LED7SEG_1_DP
                                   (0067) 
                                   (0068) export _LED7SEG_1_DispInt 
                                   (0069) export  LED7SEG_1_DispInt
                                   (0070) 
                                   (0071) export  LED7SEG_1_DigitRAM
                                   (0072) export _LED7SEG_1_DigitRAM
                                   (0073) 
                                   (0074) export  LED7SEG_1_ScanStatus
                                   (0075) export _LED7SEG_1_ScanStatus
                                   (0076) 
                                   (0077) area InterruptRAM(RAM, REL, CON)
                                   (0078) 
                                   (0079)  LED7SEG_1_VarPage:                              ; Dummy label for paging
                                   (0080) 
                                   (0081)  LED7SEG_1_ScanStatus:
                                   (0082) _LED7SEG_1_ScanStatus:                       blk      1
                                   (0083) 
                                   (0084)  LED7SEG_1_DigitRAM:
                                   (0085) _LED7SEG_1_DigitRAM:                         blk      LED7SEG_1_DigitCnt
                                   (0086) 
                                   (0087) AREA UserModules (ROM, REL)
                                   (0088) 
                                   (0089) ;; 
                                   (0090) ;;  char dp g f e   d c b a    Code  Code
                                   (0091) ;;   0    0 0 1 1   1 1 1 1    0x3F  0xC0
                                   (0092) ;;   1    0 0 0 0   0 1 1 0    0x06  0xF9
                                   (0093) ;;   2    0 1 0 1   1 0 1 1    0x5B  0xA4
                                   (0094) ;;   3    0 1 0 0   1 1 1 1    0x4F  0xB0
                                   (0095) ;;   4    0 1 1 0   0 1 1 0    0x66  0x99
                                   (0096) ;;   5    0 1 1 0   1 1 0 1    0x6D  0x92
                                   (0097) ;;   6    0 1 1 1   1 1 0 1    0x7D  0x82
                                   (0098) ;;   7    0 0 0 0   0 1 1 1    0x07  0xF8
                                   (0099) ;;   8    0 1 1 1   1 1 1 1    0x7F  0x80
                                   (0100) ;;   9    0 1 1 0   1 1 1 1    0x6F  0x90
                                   (0101) ;;   A    0 1 1 1   0 1 1 1    0x77  0x88
                                   (0102) ;;   b    0 1 1 1   1 1 0 0    0x7C  0x83
                                   (0103) ;;   C    0 0 1 1   1 0 0 1    0x39  0xC6
                                   (0104) ;;   d    0 1 0 1   1 1 1 0    0x5E  0xA1
                                   (0105) ;;   E    0 1 1 1   1 0 0 1    0x79  0x86
                                   (0106) ;;   F    0 1 1 1   0 0 0 1    0x71  0x8E
                                   (0107) ;;   -    0 1 0 0   0 0 0 0    0x40  0xBF
                                   (0108) 
                                   (0109) 
                                   (0110) 
                                   (0111) .LITERAL
                                   (0112)  LED7SEG_1_HexSegMask:
                                   (0113) 
                                   (0114)      DB   0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07
                                   (0115)      DB   0x7F, 0x6F, 0x77, 0x7C, 0x39, 0x5E, 0x79, 0x71
                                   (0116)      DB   0x40
                                   (0117) 
                                   (0118) 
                                   (0119)  LED7SEG_1_DigitPortMask:
                                   (0120) IF(LED7SEG_1_DigitDrive)  // Active High Digit Drive
                                   (0121)      DB   LED7SEG_1_Dig1Mask
                                   (0122)      DB   LED7SEG_1_Dig2Mask
                                   (0123)      DB   LED7SEG_1_Dig3Mask
                                   (0124)      DB   LED7SEG_1_Dig4Mask
                                   (0125)      DB   LED7SEG_1_Dig5Mask
                                   (0126)      DB   LED7SEG_1_Dig6Mask
                                   (0127)      DB   LED7SEG_1_Dig7Mask
                                   (0128)      DB   LED7SEG_1_Dig8Mask
                                   (0129) ELSE                             // Active Low Digit Drive
                                   (0130)      DB   ~LED7SEG_1_Dig1Mask
                                   (0131)      DB   ~LED7SEG_1_Dig2Mask
                                   (0132)      DB   ~LED7SEG_1_Dig3Mask
                                   (0133)      DB   ~LED7SEG_1_Dig4Mask
                                   (0134)      DB   ~LED7SEG_1_Dig5Mask
                                   (0135)      DB   ~LED7SEG_1_Dig6Mask
                                   (0136)      DB   ~LED7SEG_1_Dig7Mask
                                   (0137)      DB   ~LED7SEG_1_Dig8Mask
                                   (0138) ENDIF
                                   (0139) 
                                   (0140) 
                                   (0141) DEC_TABLE:   ; Used for base10 display
                                   (0142) DW 0x0001, 0x000A, 0x0064, 0x03E8, 0x2710
                                   (0143) ;    1       10     100     1000   10,000
                                   (0144) 
                                   (0145) .ENDLITERAL
                                   (0146) 
                                   (0147) .SECTION
                                   (0148) ;-----------------------------------------------------------------------------
                                   (0149) ;  FUNCTION NAME: LED7SEG_1_Start(void)
                                   (0150) ;
                                   (0151) ;  DESCRIPTION:
                                   (0152) ;     Init state machine and clear buffer memory
                                   (0153) ;
                                   (0154) ;-----------------------------------------------------------------------------
                                   (0155) ;
                                   (0156) ;  ARGUMENTS:
                                   (0157) ;    none
                                   (0158) ;
                                   (0159) ;  RETURNS:  none
                                   (0160) ;
                                   (0161) ;  SIDE EFFECTS:
                                   (0162) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0163) ;
                                   (0164) ;-----------------------------------------------------------------------------
                                   (0165) _LED7SEG_1_Start:
                                   (0166)  LED7SEG_1_Start:
0418: BF 62    JNZ   0x037B        (0167)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0168)    RAM_PROLOGUE RAM_USE_CLASS_4
041A: D3 00    JNC   0x071B        (0169)    RAM_SETPAGE_IDX >LED7SEG_1_VarPage
041C: 62 D0 00 MOV   REG[208],0    (0170)    RAM_SETPAGE_CUR >LED7SEG_1_VarPage
041F: 10       PUSH  X             (0171)    push   X
                                   (0172)    ; Initialize digit RAM
0420: 57 07    MOV   X,7           (0173)    mov    X,(LED7SEG_1_DigitCnt-1)
                                   (0174) .ClearLoop:
0422: 56 02 00 MOV   [X+2],0       (0175)    mov    [X+LED7SEG_1_DigitRAM],LED7SEG_1_SegmentInit
0425: 79       DEC   X             (0176)    dec    X
0426: DF FB    JNC   0x0422        (0177)    jnc    .ClearLoop
                                   (0178) 
                                   (0179)    ; Set scan bit
0428: 55 01 80 MOV   [1],128       (0180)    mov   [LED7SEG_1_ScanStatus],LED7SEG_1_ScanFlag  
                                   (0181) 
                                   (0182) 
042B: 71 10    OR    F,16          (0183)    M8C_SetBank1
042D: 43 00 FF OR    REG[0],255    (0184)    or    reg[LED7SEG_1_DigitPortDM0],LED7SEG_1_DigitMask
0430: 41 01 00 AND   REG[1],0      (0185)    and   reg[LED7SEG_1_DigitPortDM1],~LED7SEG_1_DigitMask
0433: 70 EF    AND   F,239         (0186)    M8C_SetBank0
0435: 41 03 00 AND   REG[3],0      (0187)    and   reg[LED7SEG_1_DigitPortDM2],~LED7SEG_1_DigitMask
                                   (0188) 
0438: 20       POP   X             (0189)    pop   X
                                   (0190) 
                                   (0191) IF (LED7SEG_1_TIMER_PRESENT)
0439: 43 2B 01 OR    REG[43],1     (0192)    or    reg[LED7SEG_1_CONTROL_REG],  LED7SEG_1_CONTROL_REG_START_BIT
043C: 43 E1 04 OR    REG[225],4    (0193)    M8C_EnableIntMask LED7SEG_1_INT_REG, LED7SEG_1_INT_MASK
043F: 70 3F    AND   F,63
                                   (0194) ENDIF
                                   (0195) 
                                   (0196)    RAM_EPILOGUE RAM_USE_CLASS_4
0441: 71 C0    OR    F,192         (0197)    RAM_EPILOGUE RAM_USE_CLASS_3
0443: 7F       RET                 (0198)    ret
                                   (0199) .ENDSECTION
                                   (0200) 
                                   (0201) 
                                   (0202) .SECTION
                                   (0203) ;-----------------------------------------------------------------------------
                                   (0204) ;  FUNCTION NAME: LED7SEG_1_Stop(void)
                                   (0205) ;
                                   (0206) ;  DESCRIPTION:
                                   (0207) ;     Stops scanning and turn off all digits
                                   (0208) ;
                                   (0209) ;-----------------------------------------------------------------------------
                                   (0210) ;
                                   (0211) ;  ARGUMENTS:
                                   (0212) ;    none
                                   (0213) ;
                                   (0214) ;  RETURNS:  none
                                   (0215) ;
                                   (0216) ;  SIDE EFFECTS:
                                   (0217) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0218) ;
                                   (0219) ;-----------------------------------------------------------------------------
                                   (0220) _LED7SEG_1_Stop:
                                   (0221)  LED7SEG_1_Stop:
                                   (0222)    RAM_PROLOGUE RAM_USE_CLASS_4
0444: 62 D0 00 MOV   REG[208],0    (0223)    RAM_SETPAGE_CUR >LED7SEG_1_VarPage
                                   (0224) 
0447: 08       PUSH  A             (0225)    push A
                                   (0226)    ; Turn off scan
0448: 55 01 00 MOV   [1],0         (0227)    mov   [LED7SEG_1_ScanStatus],0x00 
                                   (0228) 
                                   (0229)    ; Turn off all digits
                                   (0230) IF(1)                                            ; Active High Digit Drive
044B: 26 00 00 AND   [0],0         (0231)    and  [Port_0_Data_SHADE],~LED7SEG_1_DigitMask
                                   (0232) ELSE                                             ; Active Low Digit Drive
                                   (0233)    or   [Port_0_Data_SHADE],LED7SEG_1_DigitMask
                                   (0234) ENDIF
044E: 51 00    MOV   A,[0]         (0235)    mov  A,[Port_0_Data_SHADE]    
0450: 60 00    MOV   REG[0],A      (0236)    mov  reg[LED7SEG_1_DigitPortDR],A
0452: 18       POP   A             (0237)    pop  A
                                   (0238) 
                                   (0239) IF (LED7SEG_1_TIMER_PRESENT)
0453: 41 E1 FB AND   REG[225],251  (0240)    M8C_DisableIntMask LED7SEG_1_INT_REG, LED7SEG_1_INT_MASK
0456: 41 2B FE AND   REG[43],254   (0241)    and   reg[LED7SEG_1_CONTROL_REG], ~LED7SEG_1_CONTROL_REG_START_BIT
                                   (0242) ENDIF
                                   (0243) 
                                   (0244)    RAM_EPILOGUE RAM_USE_CLASS_4
0459: 7F       RET                 (0245)    ret
                                   (0246) .ENDSECTION
                                   (0247) 
                                   (0248) 
                                   (0249) 
                                   (0250) .SECTION
                                   (0251) ;-----------------------------------------------------------------------------
                                   (0252) ;  FUNCTION NAME: LED7SEG_1_Dim(Byte bDim)
                                   (0253) ;
                                   (0254) ;  DESCRIPTION:
                                   (0255) ;     Init state machine and clear buffer memory
                                   (0256) ;
                                   (0257) ;-----------------------------------------------------------------------------
                                   (0258) ;
                                   (0259) ;  ARGUMENTS:
                                   (0260) ;    A => bDim   ( Dim Off = 0,  Dim On = 1)
                                   (0261) ;
                                   (0262) ;  RETURNS:  none
                                   (0263) ;
                                   (0264) ;  SIDE EFFECTS:
                                   (0265) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0266) ;
                                   (0267) ;-----------------------------------------------------------------------------
                                   (0268) _LED7SEG_1_Dim:
                                   (0269)  LED7SEG_1_Dim:
                                   (0270)   
                                   (0271)    RAM_PROLOGUE RAM_USE_CLASS_4
045A: 62 D0 00 MOV   REG[208],0    (0272)    RAM_SETPAGE_CUR >LED7SEG_1_VarPage
                                   (0273) 
045D: 21 01    AND   A,1           (0274)    and    A,0x01
045F: A0 05    JZ    0x0465        (0275)    jz     .DimOff
                                   (0276) 
                                   (0277) .DimOn:
0461: 2E 01 40 OR    [1],64        (0278)    or     [LED7SEG_1_ScanStatus],LED7SEG_1_DimEnable
                                   (0279)    RAM_EPILOGUE RAM_USE_CLASS_4
0464: 7F       RET                 (0280)    ret
                                   (0281) 
                                   (0282) .DimOff:
0465: 26 01 BF AND   [1],191       (0283)    and    [LED7SEG_1_ScanStatus],~LED7SEG_1_DimEnable
                                   (0284)    RAM_EPILOGUE RAM_USE_CLASS_4
0468: 7F       RET                 (0285)    ret
                                   (0286) 
                                   (0287) .ENDSECTION
                                   (0288) 
                                   (0289) .SECTION
                                   (0290) ;-----------------------------------------------------------------------------
                                   (0291) ;  FUNCTION NAME: LED7SEG_1_Update(void)
                                   (0292) ;
                                   (0293) ;  DESCRIPTION:
                                   (0294) ;     Advance and display next digit from array.  This function is designed
                                   (0295) ;     to be called from an ISR, although it could be called in the mainline
                                   (0296) ;     of your program.
                                   (0297) ;
                                   (0298) ;     To call this function from a non Large Memory Model (LMM) device,
                                   (0299) ;     in an ISR use the following.
                                   (0300) ;
                                   (0301) ;     lcall LED7SEG_1_Update
                                   (0302) ;
                                   (0303) ;     If using a LMM part, and calling from an ISR, make sure the processor
                                   (0304) ;     is either in page mode 0, or in native page mode.  
                                   (0305) ;
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;
                                   (0308) ;  ARGUMENTS:
                                   (0309) ;    none
                                   (0310) ;
                                   (0311) ;  RETURNS:  none
                                   (0312) ;
                                   (0313) ;  SIDE EFFECTS:
                                   (0314) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0315) ;
                                   (0316) ;  How It Works:
                                   (0317) ;    *  Check if Scan is on
                                   (0318) ;    *  Blank display, Turn off common drive
                                   (0319) ;    *  Load Segment register
                                   (0320) ;    *  Set proper digit, (Turn on common drive)
                                   (0321) ;    *  Adance counter to next digit
                                   (0322) ;-----------------------------------------------------------------------------
                                   (0323) _LED7SEG_1_Update:
                                   (0324)  LED7SEG_1_Update:
                                   (0325)    RAM_PROLOGUE RAM_USE_CLASS_4
0469: 70 BF    AND   F,191         (0326)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0327) 
046B: 08       PUSH  A             (0328)    push  A
046C: 10       PUSH  X             (0329)    push  X
046D: 5D D3    MOV   A,REG[211]
                                   (0330)    IF (SYSTEM_LARGE_MEMORY_MODEL)
046F: 08       PUSH  A             (0331)       REG_PRESERVE IDX_PP
0470: 5D D0    MOV   A,REG[208]
0472: 08       PUSH  A             (0332)       REG_PRESERVE CUR_PP
                                   (0333)    ENDIF
                                   (0334) 
0473: 62 D3 00 MOV   REG[211],0    (0335)    RAM_SETPAGE_IDX >LED7SEG_1_VarPage
0476: 62 D0 00 MOV   REG[208],0    (0336)    RAM_SETPAGE_CUR >LED7SEG_1_VarPage
                                   (0337) 
0479: 47 01 80 TST   [1],128       (0338)    tst   [LED7SEG_1_ScanStatus],LED7SEG_1_ScanFlag  // Test if scanning is enabled
047C: A0 3B    JZ    0x04B8        (0339)    jz    .Update_End
                                   (0340) 
                                   (0341)    ; Turn off display briefly
                                   (0342) IF(1)                                            ; Active High Digit Drive
047E: 26 00 00 AND   [0],0         (0343)    and  [Port_0_Data_SHADE],~LED7SEG_1_DigitMask
                                   (0344) ELSE                                             ; Active Low Digit Drive
                                   (0345)    or   [Port_0_Data_SHADE],LED7SEG_1_DigitMask
                                   (0346) ENDIF
0481: 51 00    MOV   A,[0]         (0347)    mov   A,[Port_0_Data_SHADE]    
0483: 60 00    MOV   REG[0],A      (0348)    mov   reg[LED7SEG_1_DigitPortDR],A
                                   (0349) 
                                   (0350)    ; Get the segment value, and write it to the segment port
0485: 51 01    MOV   A,[1]         (0351)    mov   A,[LED7SEG_1_ScanStatus]
0487: 21 0F    AND   A,15          (0352)    and   A,LED7SEG_1_CntMask                     ; Mask off all but scan position
0489: 4B       SWAP  A,X           (0353)    swap  A,X
                                   (0354) 
                                   (0355)    ; Check for Dim flag
048A: 47 01 20 TST   [1],32        (0356)    tst   [LED7SEG_1_ScanStatus],LED7SEG_1_DimFlag   ; If set skip update
048D: B0 0E    JNZ   0x049C        (0357)    jnz   .IncDigit
                                   (0358) 
048F: 52 02    MOV   A,[X+2]       (0359)    mov   A,[X+LED7SEG_1_DigitRAM]
                                   (0360) 
                                   (0361) ; Invert here if Active Low segment drive
                                   (0362) IF(1)                                            ; Active Low Segment Drive
                                   (0363)    ; Do nothing
                                   (0364) ELSE
                                   (0365)    cpl   A
                                   (0366) ENDIF
0491: 60 14    MOV   REG[20],A     (0367)    mov   reg[LED7SEG_1_SegmentPortDR],A
                                   (0368) 
                                   (0369)    ; Turn digit back on
                                   (0370) 
0493: 5B       MOV   A,X           (0371)    mov   A,X                                     ; Copy index into A
0494: FF 6F    INDEX 0x0405        (0372)    index LED7SEG_1_DigitPortMask                 ; Digit mask into A
                                   (0373) 
                                   (0374) IF(1)                                            ; Active High Digit Drive
0496: 2C 00    OR    [0],A         (0375)    or   [Port_0_Data_SHADE],A
                                   (0376) ELSE                                             ; Active Low Digit Drive
                                   (0377)    and  [Port_0_Data_SHADE],A
                                   (0378) ENDIF
0498: 51 00    MOV   A,[0]         (0379)    mov  A,[Port_0_Data_SHADE]
049A: 60 00    MOV   REG[0],A      (0380)    mov  reg[LED7SEG_1_DigitPortDR],A
                                   (0381) 
                                   (0382) 
                                   (0383)    ; Calculate next digit
                                   (0384) .IncDigit:
049C: 4B       SWAP  A,X           (0385)    swap  A,X                                     ; Put current digit into A
049D: 74       INC   A             (0386)    inc   A                                       ; Advance to next
049E: 76 01    INC   [1]           (0387)    inc   [LED7SEG_1_ScanStatus]
04A0: 11 08    SUB   A,8           (0388)    sub   A,LED7SEG_1_DigitCnt
04A2: A0 05    JZ    0x04A8        (0389)    jz    .Reset_Count
04A4: D0 03    JNC   0x04A8        (0390)    jnc   .Reset_Count
04A6: 80 11    JMP   0x04B8        (0391)    jmp   .Update_End
                                   (0392) 
                                   (0393) .Reset_Count:
04A8: 26 01 F0 AND   [1],240       (0394)    and   [LED7SEG_1_ScanStatus],~LED7SEG_1_CntMask    ; Reset count to zero  
04AB: 47 01 40 TST   [1],64        (0395)    tst   [LED7SEG_1_ScanStatus],LED7SEG_1_DimEnable   ; If set skip update
04AE: A0 06    JZ    0x04B5        (0396)    jz    .Update_End_DimOff
04B0: 36 01 20 XOR   [1],32        (0397)    xor   [LED7SEG_1_ScanStatus],LED7SEG_1_DimFlag   
04B3: 80 04    JMP   0x04B8        (0398)    jmp   .Update_End
                                   (0399) 
                                   (0400) .Update_End_DimOff:                              ; Make sure Dim is off
04B5: 26 01 DF AND   [1],223       (0401)    and   [LED7SEG_1_ScanStatus],~LED7SEG_1_DimFlag    ; Make sure dim flag off
04B8: 18       POP   A
                                   (0402) 
                                   (0403) .Update_End:
                                   (0404)    IF (SYSTEM_LARGE_MEMORY_MODEL)  
04B9: 60 D0    MOV   REG[208],A    (0405)       REG_RESTORE CUR_PP
04BB: 18       POP   A
04BC: 60 D3    MOV   REG[211],A    (0406)       REG_RESTORE IDX_PP
                                   (0407)    ENDIF
                                   (0408) 
04BE: 20       POP   X             (0409)    pop   X
04BF: 18       POP   A             (0410)    pop   A
04C0: 70 3F    AND   F,63
                                   (0411) .Update_Exit:
                                   (0412) 
04C2: 71 C0    OR    F,192         (0413)    RAM_EPILOGUE RAM_USE_CLASS_3
                                   (0414)    RAM_EPILOGUE RAM_USE_CLASS_4
04C4: 7F       RET                 (0415)    ret
                                   (0416) .ENDSECTION
                                   (0417) 
                                   (0418) .SECTION
                                   (0419) ;-----------------------------------------------------------------------------
                                   (0420) ;  FUNCTION NAME: LED7SEG_1_PutHex(BYTE bValue, BYTE bDigit)
                                   (0421) ;
                                   (0422) ;  DESCRIPTION:
                                   (0423) ;     Write hex value to one of the digits
                                   (0424) ;
                                   (0425) ;-----------------------------------------------------------------------------
                                   (0426) ;
                                   (0427) ;  ARGUMENTS:
                                   (0428) ;    A => Value to display
                                   (0429) ;    X => Digit to update  ( 1 to n )
                                   (0430) ;
                                   (0431) ;  RETURNS:  none
                                   (0432) ;
                                   (0433) ;  SIDE EFFECTS:
                                   (0434) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0435) ;
                                   (0436) ;-----------------------------------------------------------------------------
                                   (0437) _LED7SEG_1_PutHex:
                                   (0438)  LED7SEG_1_PutHex:
04C5: 70 BF    AND   F,191         (0439)    RAM_PROLOGUE RAM_USE_CLASS_3  
04C7: 62 D3 00 MOV   REG[211],0    (0440)    RAM_SETPAGE_IDX >LED7SEG_1_VarPage
                                   (0441)   
04CA: FF 28    INDEX 0x03F4        (0442)    index   LED7SEG_1_HexSegMask                  ; Get code
04CC: 79       DEC   X             (0443)    dec     X                                     ; Dec to shift from (1 to N) to (0 to N-1)
04CD: 4B       SWAP  A,X           (0444)    swap    A,X                                   ; Code in X, index in A
04CE: 39 08    CMP   A,8           (0445)    cmp     A,(LED7SEG_1_DigitCnt)
04D0: D0 07    JNC   0x04D8        (0446)    jnc     .putHex_End
                                   (0447) 
04D2: 4B       SWAP  A,X           (0448)    swap    A,X                                   ; Code in A, index in X
04D3: 27 02 80 AND   [X+2],128     (0449)    and     [X+LED7SEG_1_DigitRAM],0x80
04D6: 2D 02    OR    [X+2],A       (0450)    or      [X+LED7SEG_1_DigitRAM],A
04D8: 70 3F    AND   F,63
                                   (0451) .putHex_End:
04DA: 71 C0    OR    F,192         (0452)    RAM_EPILOGUE RAM_USE_CLASS_3
04DC: 7F       RET                 (0453)    ret
                                   (0454) .ENDSECTION
                                   (0455) 
                                   (0456) .SECTION
                                   (0457) ;-----------------------------------------------------------------------------
                                   (0458) ;  FUNCTION NAME: LED7SEG_1_PutPattern(BYTE bPattern, BYTE bDigit)
                                   (0459) ;
                                   (0460) ;  DESCRIPTION:
                                   (0461) ;     Write pattern to 7 segment display
                                   (0462) ;
                                   (0463) ;-----------------------------------------------------------------------------
                                   (0464) ;
                                   (0465) ;  ARGUMENTS:
                                   (0466) ;    A => Pattern to display
                                   (0467) ;    X => Digit to update  ( 1 to n )
                                   (0468) ;
                                   (0469) ;  RETURNS:  none
                                   (0470) ;
                                   (0471) ;  SIDE EFFECTS:
                                   (0472) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0473) ;
                                   (0474) ;-----------------------------------------------------------------------------
                                   (0475) _LED7SEG_1_PutPattern:
                                   (0476)  LED7SEG_1_PutPattern:
04DD: 70 BF    AND   F,191         (0477)    RAM_PROLOGUE RAM_USE_CLASS_3  
04DF: 62 D3 00 MOV   REG[211],0    (0478)    RAM_SETPAGE_IDX >LED7SEG_1_VarPage
                                   (0479)   
04E2: 79       DEC   X             (0480)    dec     X                                     ; Dec to shift from (1 to N) to (0 to N-1)
04E3: 4B       SWAP  A,X           (0481)    swap    A,X                                   ; Code in X, index in A
04E4: 39 08    CMP   A,8           (0482)    cmp     A,(LED7SEG_1_DigitCnt)
04E6: D0 04    JNC   0x04EB        (0483)    jnc     .putPat_End
                                   (0484) 
04E8: 4B       SWAP  A,X           (0485)    swap    A,X                                   ; Code in A, index in X
04E9: 54 02    MOV   [X+2],A       (0486)    mov     [X+LED7SEG_1_DigitRAM],A
04EB: 70 3F    AND   F,63
                                   (0487) .putPat_End:
04ED: 71 C0    OR    F,192         (0488)    RAM_EPILOGUE RAM_USE_CLASS_3
04EF: 7F       RET                 (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: LED7SEG_1_DP(BYTE bDpOnOff, BYTE bDigit)
                                   (0495) ;
                                   (0496) ;  DESCRIPTION:
                                   (0497) ;     Set the decimal point with the given mask.
                                   (0498) ;
                                   (0499) ;-----------------------------------------------------------------------------
                                   (0500) ;
                                   (0501) ;  ARGUMENTS:
                                   (0502) ;    A => DP ON/OFF (0 = DP Off, 1 = DP On)
                                   (0503) ;    X => Digit  (1 to N)
                                   (0504) ;
                                   (0505) ;  RETURNS:  none
                                   (0506) ;
                                   (0507) ;  SIDE EFFECTS:
                                   (0508) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0509) ;
                                   (0510) ;-----------------------------------------------------------------------------
                                   (0511) _LED7SEG_1_DP:
                                   (0512)  LED7SEG_1_DP:
04F0: 70 BF    AND   F,191         (0513)    RAM_PROLOGUE RAM_USE_CLASS_3  
04F2: 62 D3 00 MOV   REG[211],0    (0514)    RAM_SETPAGE_IDX >LED7SEG_1_VarPage
04F5: 79       DEC   X             (0515)    dec    X                                      ; noramlize from 1 - N, to 0 to N-1
04F6: 4B       SWAP  A,X           (0516)    swap   A,X
04F7: 39 08    CMP   A,8           (0517)    cmp    A,(LED7SEG_1_DigitCnt)
04F9: D0 0E    JNC   0x0508        (0518)    jnc    .DP_End
                                   (0519)    
04FB: 4B       SWAP  A,X           (0520)    swap   A,X
04FC: 39 00    CMP   A,0           (0521)    cmp    A,0x00                                 ; Is flag set
04FE: A0 06    JZ    0x0505        (0522)    jz     .DPOff
                                   (0523) 
0500: 2F 02 80 OR    [X+2],128     (0524)    or     [X+LED7SEG_1_DigitRAM],0x80            ; Set DP
0503: 80 04    JMP   0x0508        (0525)    jmp    .DP_End
                                   (0526) .DPOff:
0505: 27 02 7F AND   [X+2],127     (0527)    and    [X+LED7SEG_1_DigitRAM],0x7F            ; Clear DP
0508: 70 3F    AND   F,63
                                   (0528) 
                                   (0529) .DP_End:
050A: 71 C0    OR    F,192         (0530)    RAM_EPILOGUE RAM_USE_CLASS_3
050C: 7F       RET                 (0531)    ret
050D: 70 3F    AND   F,63
                                   (0532) .ENDSECTION
                                   (0533) 
                                   (0534) 
                                   (0535) .SECTION
                                   (0536) ;-----------------------------------------------------------------------------
                                   (0537) ;  FUNCTION NAME: LED7SEG_1_DispInt(int iValue, BYTE bPos, BYTE bLSD)
                                   (0538) ;
                                   (0539) ;  DESCRIPTION:
                                   (0540) ;     Display integer on 7-Segment display
                                   (0541) ;
                                   (0542) ;-----------------------------------------------------------------------------
                                   (0543) ;
                                   (0544) ;  ARGUMENTS:
                                   (0545) ;          [SP-3] => iValue[7:0]   Value to convert
                                   (0546) ;          [SP-4] => iValue[15:8]  
                                   (0547) ;          [SP-5] => bPos[7:0]     Digit starting position
                                   (0548) ;          [SP-6] => bLSD[7:0]     Digits to display
                                   (0549) ;
                                   (0550) ;
                                   (0551) ;  RETURNS:  none
                                   (0552) ;
                                   (0553) ;  SIDE EFFECTS:
                                   (0554) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0555) ;
                                   (0556) ;-----------------------------------------------------------------------------
                                   (0557) ;
                                   (0558) DI_ValueLSB:   equ   -3
                                   (0559) DI_ValueMSB:   equ   -4
                                   (0560) DI_POS:        equ   -5
                                   (0561) DI_LSD:        equ   -6
                                   (0562) DI_DECPTR:     equ    0
                                   (0563) DI_RESULT:     equ    1
                                   (0564) DI_TMP:        equ    2
                                   (0565) DI_STACKSIZE:  equ    3
                                   (0566) 
                                   (0567) _LED7SEG_1_DispInt:
                                   (0568)  LED7SEG_1_DispInt:
050F: 71 C0    OR    F,192         (0569)    RAM_EPILOGUE RAM_USE_CLASS_2
                                   (0570)    
0511: 4F       MOV   X,SP          (0571)    mov   X,SP                                    ; Get copy of the stack pointer
0512: 38 03    ADD   SP,3          (0572)    add   SP,DI_STACKSIZE                         ; Make some extra room for vars
                                   (0573) 
                                   (0574)    ; Testing only
0514: 52 FC    MOV   A,[X-4]       (0575)    mov   A,[X+DI_ValueMSB]
0516: 52 FD    MOV   A,[X-3]       (0576)    mov   A,[X+DI_ValueLSB]
0518: 52 FB    MOV   A,[X-5]       (0577)    mov   A,[X+DI_POS]
051A: 7B FA    DEC   [X-6]         (0578)    dec   [X+DI_LSD]                              ; shift count from [1 to N] to [0 to N-1]
                                   (0579) 
051C: 56 00 04 MOV   [X+0],4       (0580)    mov   [X+DI_DECPTR],4                         ; Load dec ptr with 10000 value
                                   (0581) 
                                   (0582) 
                                   (0583)    ; Comapare input value to decade
                                   (0584) .DEC_LOOP_TOP:
051F: 56 01 00 MOV   [X+1],0       (0585)    mov   [X+DI_RESULT],0                         ; Reset result
                                   (0586) .DEC_LOOP:
                                   (0587)    ; Compare MSB
0522: 52 00    MOV   A,[X+0]       (0588)    mov   A,[X+DI_DECPTR]
0524: 64       ASL   A             (0589)    asl   A                                       ; Index it for 2 (word) bytes ber value
0525: FE E6    INDEX 0x040D        (0590)    index DEC_TABLE
0527: 3B FC    CMP   A,[X-4]       (0591)    cmp   A,[X+DI_ValueMSB]                       ; Is 10^x > Value  (10^x - value)
0529: C0 0F    JC    0x0539        (0592)    jc    .DO_INC_SUB                             ; If value is still bigger, increment and subtract
052B: B0 24    JNZ   0x0550        (0593)    jnz   .TRY_NEXT_DEC
                                   (0594) 
                                   (0595)    ; Compare LSB only if MSB values were equal
052D: 52 00    MOV   A,[X+0]       (0596)    mov   A,[X+DI_DECPTR]                         ; Get LSB of DEC value
052F: 64       ASL   A             (0597)    asl   A                                       ; Index it for 2 bytes per value
0530: 74       INC   A             (0598)    inc   A                                       ; Advance to LSB value
0531: FE DA    INDEX 0x040D        (0599)    index DEC_TABLE
0533: 3B FD    CMP   A,[X-3]       (0600)    cmp   A,[X+DI_ValueLSB]                       ; Is 10^x > Value  (10^x - value)
0535: C0 03    JC    0x0539        (0601)    jc    .DO_INC_SUB                             ; If value is still bigger, increment and subtract
0537: B0 18    JNZ   0x0550        (0602)    jnz   .TRY_NEXT_DEC
                                   (0603)                                                  ; If it fell through, they are equal
                                   (0604) .DO_INC_SUB:
0539: 77 01    INC   [X+1]         (0605)    inc   [X+DI_RESULT]                           ; Increment the result counter
                                   (0606)    ; Subtract DEC value from Value
053B: 52 00    MOV   A,[X+0]       (0607)    mov   A,[X+DI_DECPTR]
053D: 64       ASL   A             (0608)    asl   A                                       ; Index it for 2 bytes per value
053E: FE CD    INDEX 0x040D        (0609)    index DEC_TABLE
0540: 54 02    MOV   [X+2],A       (0610)    mov   [X+DI_TMP],A                            ; Store this value for a moment  
                                   (0611) 
0542: 52 00    MOV   A,[X+0]       (0612)    mov   A,[X+DI_DECPTR]                         ; Get LSB of DEC value
0544: 64       ASL   A             (0613)    asl   A                                       ; Index it for 2 bytes per value
0545: 74       INC   A             (0614)    inc   A                                       ; Advance to LSB value
0546: FE C5    INDEX 0x040D        (0615)    index DEC_TABLE
0548: 15 FD    SUB   [X-3],A       (0616)    sub   [X+DI_ValueLSB],A                       ; Is 10^x > Value  (10^x - value)
054A: 52 02    MOV   A,[X+2]       (0617)    mov   A,[X+DI_TMP]
054C: 1D FC    SBB   [X-4],A       (0618)    sbb   [X+DI_ValueMSB],A
054E: 8F D3    JMP   0x0522        (0619)    jmp   .DEC_LOOP                               ; Keep subtracting until less than.
                                   (0620)    
                                   (0621) .TRY_NEXT_DEC:                                   ; Completed last decade
                                   (0622) 
0550: 52 FA    MOV   A,[X-6]       (0623)    mov   A,[X+DI_LSD]                            ; Get first position
0552: 3B 00    CMP   A,[X+0]       (0624)    cmp   A,[X+DI_DECPTR]      
0554: C0 11    JC    0x0566        (0625)    jc    .SkipPrint                              ; Not ready skip the print
                                   (0626) 
                                   (0627) 
                                   (0628)    ; Figure if digit should be displayed
0556: 52 01    MOV   A,[X+1]       (0629)    mov   A,[X+DI_RESULT]                         ; Get result
0558: 10       PUSH  X             (0630)    push  X
0559: 59 FB    MOV   X,[X-5]       (0631)    mov   X,[X+DI_POS]                            ; Load Position
                                   (0632) 
055B: 71 C0    OR    F,192         (0633)    RAM_SET_NATIVE_PAGING
055D: 9F 66    CALL  0x04C5        (0634)    call  LED7SEG_1_PutHex
055F: 70 3F    AND   F,63
0561: 71 C0    OR    F,192         (0635)    RAM_EPILOGUE RAM_USE_CLASS_2                  ; Restore system to class 2 memory mode
0563: 20       POP   X             (0636)    pop   X
0564: 77 FB    INC   [X-5]         (0637)    inc   [X+DI_POS]                              ; Next time print to the right
                                   (0638) 
                                   (0639) .SkipPrint:
0566: 56 01 00 MOV   [X+1],0       (0640)    mov   [X+DI_RESULT],0
0569: 7B 00    DEC   [X+0]         (0641)    dec   [X+DI_DECPTR]
056B: BF B6    JNZ   0x0522        (0642)    jnz   .DEC_LOOP
                                   (0643) 
056D: 52 FD    MOV   A,[X-3]       (0644)    mov   A,[X+DI_ValueLSB]                       ; Is 10^x > Value  (10^x - value)
056F: 59 FB    MOV   X,[X-5]       (0645)    mov   X,[X+DI_POS]                            ; Load Position
                                   (0646) 
0571: 71 C0    OR    F,192         (0647)    RAM_SET_NATIVE_PAGING
0573: 9F 50    CALL  0x04C5        (0648)    call  LED7SEG_1_PutHex
0575: 70 3F    AND   F,63
0577: 71 C0    OR    F,192         (0649)    RAM_EPILOGUE RAM_USE_CLASS_2                  ; Restore system to class 2 memory mode
                                   (0650) 
                                   (0651) .DispInt_End:
0579: 38 FD    ADD   SP,253        (0652)    add   SP,-DI_STACKSIZE                        ; Restore stack
057B: 70 3F    AND   F,63
057D: 71 C0    OR    F,192         (0653)    RAM_EPILOGUE RAM_USE_CLASS_2
057F: 7F       RET                 (0654)    ret

FILE: lib\i2chw_1rsrcinits.asm
                                   (0001) ;;*****************************************************************************
                                   (0002) ;;*****************************************************************************
                                   (0003) ;;  FILENAME: I2CHW_1.asm
                                   (0004) ;;   Version: 1.5, Updated on 2006/06/06 at 13:39:08
                                   (0005) ;;  Generated by PSoC Designer ver 4.4  b1884 : 14 Jan, 2007
                                   (0006) ;;
                                   (0007) ;;  DESCRIPTION: I2Cs User Module software implementation file
                                   (0008) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0009) ;;
                                   (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0012) ;;        This means it is the caller's responsibility to preserve any values
                                   (0013) ;;        in the X and A registers that are still needed after the API functions
                                   (0014) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0018) ;;-----------------------------------------------------------------------------
                                   (0019) ;;  Copyright (c) Cypress MicroSystems 2002-2006. All Rights Reserved.
                                   (0020) ;;*****************************************************************************
                                   (0021) ;;*****************************************************************************
                                   (0022) 
                                   (0023) include "m8c.inc"
                                   (0024) include "memory.inc"
                                   (0025) include "I2CHW_1Common.inc"
                                   (0026) 
                                   (0027) ;-----------------------------------------------
                                   (0028) ; include instance specific register definitions
                                   (0029) ;-----------------------------------------------
                                   (0030) 
                                   (0031) ;-----------------------------------------------
                                   (0032) ;  Global Symbols
                                   (0033) ;-----------------------------------------------
                                   (0034) ;-------------------------------------------------------------------
                                   (0035) ;  Declare the functions global for both assembler and C compiler.
                                   (0036) ;
                                   (0037) ;  Note that there are two names for each API. First name is
                                   (0038) ;  assembler reference. Name with underscore is name refence for
                                   (0039) ;  C compiler.  Calling function in C source code does not require
                                   (0040) ;  the underscore.
                                   (0041) ;-------------------------------------------------------------------
                                   (0042) 
                                   (0043) export    I2CHW_1_EnableInt
                                   (0044) export   _I2CHW_1_EnableInt
                                   (0045) export    I2CHW_1_EnableSlave
                                   (0046) export   _I2CHW_1_EnableSlave
                                   (0047) export    I2CHW_1_EnableMstr
                                   (0048) export   _I2CHW_1_EnableMstr
                                   (0049) export    I2CHW_1_Start
                                   (0050) export   _I2CHW_1_Start
                                   (0051) export    I2CHW_1_DisableInt
                                   (0052) export   _I2CHW_1_DisableInt
                                   (0053) export    I2CHW_1_DisableSlave
                                   (0054) export   _I2CHW_1_DisableSlave
                                   (0055) export    I2CHW_1_DisableMstr
                                   (0056) export   _I2CHW_1_DisableMstr
                                   (0057) export    I2CHW_1_Stop
                                   (0058) export   _I2CHW_1_Stop
                                   (0059) 
                                   (0060) 
                                   (0061) AREA UserModules (ROM, REL)
                                   (0062) 
                                   (0063) .SECTION
                                   (0064) 
                                   (0065) ;-----------------------------------------------------------------------------
                                   (0066) ;  FUNCTION NAME: I2CHW_1_Start
                                   (0067) ;
                                   (0068) ;  DESCRIPTION:
                                   (0069) ;   Initialize the I2CHW_1 I2C bus interface.
                                   (0070) ;
                                   (0071) ;-----------------------------------------------------------------------------
                                   (0072) ;
                                   (0073) ;  ARGUMENTS:
                                   (0074) ;
                                   (0075) ;  RETURNS: none
                                   (0076) ;
                                   (0077) ;  SIDE EFFECTS:
                                   (0078) ;    The A and X registers may be modified by this or future implementations
                                   (0079) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0080) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0081) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0082) ;    functions.
                                   (0083) ;          
                                   (0084)  I2CHW_1_Start:
                                   (0085) _I2CHW_1_Start:
                                   (0086)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0087)     RAM_EPILOGUE RAM_USE_CLASS_1
0580: 7F       RET                 (0088)     ret
                                   (0089) .ENDSECTION
                                   (0090) 
                                   (0091) .SECTION
                                   (0092) ;-----------------------------------------------------------------------------
                                   (0093) ;  FUNCTION NAME: I2CHW_1_EnableInt
                                   (0094) ;
                                   (0095) ;  DESCRIPTION:
                                   (0096) ;     Enables SDA interrupt allowing start condition detection. Remember to call the
                                   (0097) ;     global interrupt enable function by using the macro: M8C_EnableGInt.
                                   (0098) ;
                                   (0099) ;-----------------------------------------------------------------------------
                                   (0100) ;
                                   (0101) ;  ARGUMENTS: none
                                   (0102) ;
                                   (0103) ;  RETURNS: none
                                   (0104) ;
                                   (0105) ;  SIDE EFFECTS:
                                   (0106) ;    The A and X registers may be modified by this or future implementations
                                   (0107) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0108) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0109) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0110) ;    functions.
                                   (0111) ;          
                                   (0112)  I2CHW_1_EnableInt:
                                   (0113) _I2CHW_1_EnableInt:
                                   (0114)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0115)     ;first clear any pending interrupts
0581: 08       PUSH  A             (0116)     push A
0582: 5D DD    MOV   A,REG[221]    (0117)     mov A, reg[INT_CLR3]
0584: 21 FE    AND   A,254         (0118)     and A, ~I2CHW_1_INT_MASK
0586: 60 DD    MOV   REG[221],A    (0119)     mov reg[INT_CLR3], A
0588: 43 DE 01 OR    REG[222],1    (0120)     M8C_EnableIntMask I2CHW_1_INT_REG, I2CHW_1_INT_MASK
058B: 18       POP   A             (0121)     pop A
                                   (0122)     RAM_EPILOGUE RAM_USE_CLASS_1
058C: 7F       RET                 (0123)     ret
                                   (0124) 
                                   (0125) .ENDSECTION
                                   (0126) 
                                   (0127) .SECTION
                                   (0128) ;-----------------------------------------------------------------------------
                                   (0129) ;  FUNCTION NAME: I2CHW_1_EnableMstr
                                   (0130) ;
                                   (0131) ;  DESCRIPTION:
                                   (0132) ;     Enables SDA interrupt allowing start condition detection. Remember to call the
                                   (0133) ;     global interrupt enable function by using the macro: M8C_EnableGInt.
                                   (0134) ;
                                   (0135) ;-----------------------------------------------------------------------------
                                   (0136) ;
                                   (0137) ;  ARGUMENTS: none
                                   (0138) ;
                                   (0139) ;  RETURNS: none
                                   (0140) ;
                                   (0141) ;  SIDE EFFECTS:
                                   (0142) ;    The A and X registers may be modified by this or future implementations
                                   (0143) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0144) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0145) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0146) ;    functions.
                                   (0147) ;          
                                   (0148)  I2CHW_1_EnableMstr:
                                   (0149) _I2CHW_1_EnableMstr:
                                   (0150)     RAM_PROLOGUE RAM_USE_CLASS_1
058D: 43 D6 02 OR    REG[214],2    (0151)     BitSetI2CHW_1_CFG I2C_M_EN                                       ;Enable SDA interupt
                                   (0152)     RAM_EPILOGUE RAM_USE_CLASS_1
0590: 7F       RET                 (0153)     ret
                                   (0154) 
                                   (0155) .ENDSECTION
                                   (0156) 
                                   (0157) .SECTION
                                   (0158) ;-----------------------------------------------------------------------------
                                   (0159) ;  FUNCTION NAME: I2CHW_1_EnableSlave
                                   (0160) ;
                                   (0161) ;  DESCRIPTION:
                                   (0162) ;     Enables SDA interrupt allowing start condition detection. Remember to call the
                                   (0163) ;     global interrupt enable function by using the macro: M8C_EnableGInt.
                                   (0164) ;
                                   (0165) ;-----------------------------------------------------------------------------
                                   (0166) ;
                                   (0167) ;  ARGUMENTS: none
                                   (0168) ;
                                   (0169) ;  RETURNS: none
                                   (0170) ;
                                   (0171) ;  SIDE EFFECTS:
                                   (0172) ;    The A and X registers may be modified by this or future implementations
                                   (0173) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0174) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0175) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0176) ;    functions.
                                   (0177) ;          
                                   (0178)  I2CHW_1_EnableSlave:
                                   (0179) _I2CHW_1_EnableSlave:
                                   (0180)     RAM_PROLOGUE RAM_USE_CLASS_1
0591: 43 D6 01 OR    REG[214],1    (0181)     BitSetI2CHW_1_CFG I2C_S_EN                                       ;Enable SDA interupt
                                   (0182)     RAM_EPILOGUE RAM_USE_CLASS_1
0594: 7F       RET                 (0183)     ret
                                   (0184) 
                                   (0185) .ENDSECTION
                                   (0186) 
                                   (0187) .SECTION
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;  FUNCTION NAME: I2CHW_1_DisableInt
                                   (0190) ;  FUNCTION NAME: I2CHW_1_Stop
                                   (0191) ;
                                   (0192) ;  DESCRIPTION:
                                   (0193) ;     Disables I2CHW_1 slave by disabling SDA interrupt
                                   (0194) ;
                                   (0195) ;-----------------------------------------------------------------------------
                                   (0196) ;
                                   (0197) ;  ARGUMENTS: none
                                   (0198) ;
                                   (0199) ;  RETURNS: none
                                   (0200) ;
                                   (0201) ;  SIDE EFFECTS:
                                   (0202) ;    The A and X registers may be modified by this or future implementations
                                   (0203) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0204) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0205) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0206) ;    functions.
                                   (0207) ;          
                                   (0208)  I2CHW_1_DisableInt:
                                   (0209) _I2CHW_1_DisableInt:
                                   (0210)  I2CHW_1_Stop:
                                   (0211) _I2CHW_1_Stop:
                                   (0212)     RAM_PROLOGUE RAM_USE_CLASS_1
0595: 41 DE FE AND   REG[222],254  (0213)     M8C_DisableIntMask I2CHW_1_INT_REG, I2CHW_1_INT_MASK
                                   (0214)     RAM_EPILOGUE RAM_USE_CLASS_1
0598: 7F       RET                 (0215)     ret
                                   (0216) 
                                   (0217) .ENDSECTION
                                   (0218) 
                                   (0219) .SECTION
                                   (0220) ;-----------------------------------------------------------------------------
                                   (0221) ;  FUNCTION NAME: I2CHW_1_DisableSlave
                                   (0222) ;
                                   (0223) ;  DESCRIPTION:
                                   (0224) ;     Disables I2CHW_1 slave by disabling SDA interrupt
                                   (0225) ;
                                   (0226) ;-----------------------------------------------------------------------------
                                   (0227) ;
                                   (0228) ;  ARGUMENTS: none
                                   (0229) ;
                                   (0230) ;  RETURNS: none
                                   (0231) ;
                                   (0232) ;  SIDE EFFECTS:
                                   (0233) ;    The A and X registers may be modified by this or future implementations
                                   (0234) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0235) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0236) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0237) ;    functions.
                                   (0238) ;          
                                   (0239)  I2CHW_1_DisableSlave:
                                   (0240) _I2CHW_1_DisableSlave:
                                   (0241)     RAM_PROLOGUE RAM_USE_CLASS_1
0599: 41 D6 FE AND   REG[214],254  (0242)     BitClrI2CHW_1_CFG I2C_S_EN                                       ;Disable the Slave
                                   (0243)     RAM_EPILOGUE RAM_USE_CLASS_1
059C: 7F       RET                 (0244)     ret
                                   (0245) 
                                   (0246) .ENDSECTION
                                   (0247) 
                                   (0248) .SECTION
                                   (0249) ;-----------------------------------------------------------------------------
                                   (0250) ;  FUNCTION NAME: I2CHW_1_DisableMstr
                                   (0251) ;
                                   (0252) ;  DESCRIPTION:
                                   (0253) ;     Disables I2CHW_1 slave by disabling SDA interrupt
                                   (0254) ;
                                   (0255) ;-----------------------------------------------------------------------------
                                   (0256) ;
                                   (0257) ;  ARGUMENTS: none
                                   (0258) ;
                                   (0259) ;  RETURNS: none
                                   (0260) ;
                                   (0261) ;  SIDE EFFECTS:
                                   (0262) ;    The A and X registers may be modified by this or future implementations
                                   (0263) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0264) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0265) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0266) ;    functions.
                                   (0267) ;          
                                   (0268)  I2CHW_1_DisableMstr:
                                   (0269) _I2CHW_1_DisableMstr:
                                   (0270)     RAM_PROLOGUE RAM_USE_CLASS_1
059D: 41 D6 FD AND   REG[214],253  (0271)     BitClrI2CHW_1_CFG I2C_M_EN                                       ;Disable the Master
                                   (0272)     RAM_EPILOGUE RAM_USE_CLASS_1
05A0: 7F       RET                 (0273)    ret

FILE: lib\i2chw_1int.asm
                                   (0001) ;;*****************************************************************************
                                   (0002) ;;*****************************************************************************
                                   (0003) ;;  FILENAME: I2CHW_1INT.asm
                                   (0004) ;;   Version: 1.5, Updated on 2006/06/06 at 13:39:08
                                   (0005) ;;  Generated by PSoC Designer ver 4.4  b1884 : 14 Jan, 2007
                                   (0006) ;;
                                   (0007) ;;  DESCRIPTION: I2CHW (Slave) Interrupt Service Routine for the 
                                   (0008) ;;               22/24/27/29xxx PSoC family of devices.
                                   (0009) ;;  This is the interrupt seveice routine for the Slave I2C function.
                                   (0010) ;;-----------------------------------------------------------------------------
                                   (0011) ;;  Copyright (c) Cypress MicroSystems 2000-2006. All Rights Reserved.
                                   (0012) ;;*****************************************************************************
                                   (0013) ;;*****************************************************************************
                                   (0014) include "m8c.inc"
                                   (0015) include "memory.inc"
                                   (0016) include "I2CHW_1Slave.inc"
                                   (0017) include "I2CHW_1Common.inc"
                                   (0018) 
                                   (0019) 
                                   (0020) ;-----------------------------------------------
                                   (0021) ;  Global Symbols
                                   (0022) ;-----------------------------------------------
                                   (0023) export     I2CHW_1_RsrcStatus                                        ; upper (7x) bits write status, lower 3 bits read status
                                   (0024) export    _I2CHW_1_RsrcStatus                                        ; upper (7x) bits write status, lower 3 bits read status
                                   (0025) export     I2CHW_1_Read_Count
                                   (0026) export    _I2CHW_1_Read_Count
                                   (0027) export     I2CHW_1_Write_Count
                                   (0028) export    _I2CHW_1_Write_Count
                                   (0029) export    pI2CHW_1_Read_BufLO
                                   (0030) export   _pI2CHW_1_Read_BufLO
                                   (0031) export    pI2CHW_1_Write_BufLO
                                   (0032) export   _pI2CHW_1_Write_BufLO
                                   (0033) export   _I2CHW_1_bStatus
                                   (0034) export    I2CHW_1_bStatus
                                   (0035) 
                                   (0036) ;-----------------------------------------------
                                   (0037) ; WARNING: The variables below are deprecated
                                   (0038) ; and have been replaced with Read_BufLO
                                   (0039) ; and Write_BufLO
                                   (0040) ;-----------------------------------------------
                                   (0041) export    pI2CHW_1_Read_Buf
                                   (0042) export   _pI2CHW_1_Read_Buf
                                   (0043) export    pI2CHW_1_Write_Buf
                                   (0044) export   _pI2CHW_1_Write_Buf
                                   (0045) ;-----------------------------------------------
                                   (0046) ; END WARNING
                                   (0047) ;-----------------------------------------------
                                   (0048) 
                                   (0049) area InterruptRAM(RAM, REL, CON)	 
                                   (0050) 
                                   (0051) ;-----------------------------------------------
                                   (0052) ; Variable Allocation
                                   (0053) ;-----------------------------------------------
                                   (0054) 
                                   (0055)  _I2CHW_1_bStatus:
                                   (0056)   I2CHW_1_bStatus:                           blk 1
                                   (0057)   I2CHW_1_RsrcStatus:
                                   (0058)  _I2CHW_1_RsrcStatus:                        blk     1
                                   (0059)   I2CHW_1_Write_Count:
                                   (0060)  _I2CHW_1_Write_Count:                       blk    1
                                   (0061) IF SYSTEM_LARGE_MEMORY_MODEL
                                   (0062) export    pI2CHW_1_Write_BufHI
                                   (0063) export   _pI2CHW_1_Write_BufHI
                                   (0064) 
                                   (0065)  pI2CHW_1_Write_BufHI:
                                   (0066) _pI2CHW_1_Write_BufHI:                       blk     1
                                   (0067) ENDIF
                                   (0068) ;-----------------------------------------------
                                   (0069) ; WARNING: The variable below is deprecated
                                   (0070) ; and has been replaced Write_BufLO
                                   (0071) ;-----------------------------------------------
                                   (0072)  pI2CHW_1_Write_Buf:
                                   (0073) _pI2CHW_1_Write_Buf:
                                   (0074) ;-----------------------------------------------
                                   (0075) ; END WARNING
                                   (0076) ;-----------------------------------------------
                                   (0077)  pI2CHW_1_Write_BufLO:
                                   (0078) _pI2CHW_1_Write_BufLO:                       blk      1
                                   (0079) 
                                   (0080) IF I2CHW_1_READ_FLASH
                                   (0081) export    pI2CHW_1_Read_BufHI
                                   (0082) export   _pI2CHW_1_Read_BufHI
                                   (0083) 
                                   (0084)  pI2CHW_1_Read_BufHI:
                                   (0085) _pI2CHW_1_Read_BufHI:                        blk     1
                                   (0086) ELSE
                                   (0087) IF SYSTEM_LARGE_MEMORY_MODEL
                                   (0088) export    pI2CHW_1_Read_BufHI
                                   (0089) export   _pI2CHW_1_Read_BufHI
                                   (0090) 
                                   (0091)  pI2CHW_1_Read_BufHI:
                                   (0092) _pI2CHW_1_Read_BufHI:                        blk     1
                                   (0093) ENDIF
                                   (0094) ENDIF
                                   (0095) 
                                   (0096) ;-----------------------------------------------
                                   (0097) ; WARNING: The variable below is deprecated
                                   (0098) ; and has been replaced Read_BufLO
                                   (0099) ;-----------------------------------------------
                                   (0100)  pI2CHW_1_Read_Buf:
                                   (0101) _pI2CHW_1_Read_Buf:
                                   (0102) ;-----------------------------------------------
                                   (0103) ; END WARNING
                                   (0104) ;-----------------------------------------------
                                   (0105)  pI2CHW_1_Read_BufLO:
                                   (0106) _pI2CHW_1_Read_BufLO:                        blk       1
                                   (0107) 
                                   (0108) IF I2CHW_1_READ_FLASH
                                   (0109) export    I2CHW_1_Read_CountHI
                                   (0110) export   _I2CHW_1_Read_CountHI
                                   (0111) 
                                   (0112)  I2CHW_1_Read_CountHI:
                                   (0113) _I2CHW_1_Read_CountHI:                       blk    1
                                   (0114) ENDIF
                                   (0115) 
                                   (0116)  I2CHW_1_Read_Count:
                                   (0117) _I2CHW_1_Read_Count:                         blk      1
                                   (0118) 
                                   (0119) 
                                   (0120) IF I2CHW_1_POLLED_PROCESS
                                   (0121) 
                                   (0122) I2CHW_1_Poll_Status:                             blk      1  ;internal variable used for polled operation
                                   (0123) ;bit 0 - Write transaction started begin looking for the STOP state to terminate the transaction
                                   (0124) I2C_WRITE_STARTED:       equ     0x01
                                   (0125) ;bit 1 - Undefined
                                   (0126) ;bit 2 - Undefined
                                   (0127) ;bit 3 - Undefined
                                   (0128) ;bit 4 - Undefined
                                   (0129) ;bit 5 - Undefined
                                   (0130) ;bit 6 - Undefined
                                   (0131) ;bit 7 - Undefined
                                   (0132) 
                                   (0133) ENDIF
                                   (0134) 
                                   (0135) 
                                   (0136) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                   (0137) ;---------------------------------------------------
                                   (0138) ; Insert your custom declarations below this banner
                                   (0139) ;---------------------------------------------------
                                   (0140) 
                                   (0141) ;------------------------
                                   (0142) ; Includes
                                   (0143) ;------------------------
                                   (0144) 
                                   (0145) 	
                                   (0146) ;------------------------
                                   (0147) ;  Constant Definitions
                                   (0148) ;------------------------
                                   (0149) 
                                   (0150) 
                                   (0151) ;------------------------
                                   (0152) ; Variable Allocation
                                   (0153) ;------------------------
                                   (0154) 
                                   (0155) 
                                   (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations above this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0160) 
                                   (0161) 
                                   (0162) 
                                   (0163) 
                                   (0164) AREA UserModules (ROM, REL)
                                   (0165) 
                                   (0166) export _I2CHW_1_ISR
                                   (0167) export _I2CHW_1_Poll
                                   (0168) export  I2CHW_1_Poll
                                   (0169) 
                                   (0170) ;;****************************************************
                                   (0171) ;; I2C_ISR  main entry point from vector 60h
                                   (0172) ;;
                                   (0173) ;;****************************************************
                                   (0174) 
                                   (0175) IF I2CHW_1_POLLED_PROCESS
                                   (0176) 
                                   (0177) _I2CHW_1_ISR:
                                   (0178)     reti ; stub out the ISR if this is going to be a polled function
                                   (0179) 
                                   (0180)  
                                   (0181)  
                                   (0182)  I2CHW_1_Poll:
                                   (0183) _I2CHW_1_Poll:
                                   (0184) ;    cases are:
                                   (0185) ;    1. Stop state after a Master write to this slave
                                   (0186) ;    2. possible Stop condition COMBINED with a new transaction is not a problem since the Stop will only flag that the 
                                   (0187) ;       previous write has been completed. (so just call the I2CA_Process routine for this case and let the process routine take
                                   (0188) ;       care of it.
                                   (0189)     ;case 1
                                   (0190)     RAM_SETPAGE_CUR	( >I2CHW_1_Poll_Status )
                                   (0191) 
                                   (0192)     tst [I2CHW_1_Poll_Status], I2C_WRITE_STARTED
                                   (0193)     jz  NOT_I2C_Write
                                   (0194)     tst reg[ I2CHW_1_SCR], I2C_STOP_ST
                                   (0195)     jz  NOT_I2C_Write
                                   (0196)     ;make sure the pushes and pops 'line up' or die horribly
                                   (0197)     push A
                                   (0198)     push X
                                   (0199) IF SYSTEM_LARGE_MEMORY_MODEL
                                   (0200)     REG_PRESERVE IDX_PP
                                   (0201) ENDIF
                                   (0202)     jmp STOPTRAP
                                   (0203)     
                                   (0204) NOT_I2C_Write:    
                                   (0205)     tst reg[ I2CHW_1_SCR], I2C_BYTE_COMPL
                                   (0206)     jnz  I2CHW_1_Process   ;if no other critical eventa are in evidence, process an I2C byte if it's done
                                   (0207)     ret
                                   (0208) 
                                   (0209)  I2CHW_1_Process:
                                   (0210) _I2CHW_1_Process:  ;don't need to export user will call I2CA_POLL which will call the I2CA_Process routine if necessary
                                   (0211) 
                                   (0212) 
                                   (0213) 
                                   (0214) ELSE
                                   (0215) ;; STUB for polling function when it's un-defined
                                   (0216)  I2CHW_1_Poll:
                                   (0217) _I2CHW_1_Poll:
05A1: 7F       RET                 (0218)     ret
                                   (0219) 
                                   (0220) 
                                   (0221) ;;*****************************************************************************************
                                   (0222) ;;                 I2C_MASTER  main entry point from vector 60h
                                   (0223) ;;*****************************************************************************************
                                   (0224) 
                                   (0225) _I2CHW_1_ISR:
                                   (0226) ENDIF
05A2: 08       PUSH  A             (0227)     push A
05A3: 10       PUSH  X             (0228)     push X
05A4: 5D D3    MOV   A,REG[211]
                                   (0229) 
                                   (0230) IF SYSTEM_LARGE_MEMORY_MODEL
05A6: 08       PUSH  A             (0231)     REG_PRESERVE IDX_PP
                                   (0232) ENDIF
                                   (0233) 
                                   (0234) Process_REENTRY:
                                   (0235) 
                                   (0236) ;******************************************************************************************
                                   (0237) ;Before doing anything else check for the presence of a STOP_ST in combination with the
                                   (0238) ;STOP Interrupt Enable (STOPIE).  If this is what happened set appropriate bits, 
                                   (0239) ;clear and reset the main I2CHW interrupt to assure that we haven't missed a BYTE_COMPLETE
                                   (0240) ;interrupt and exit the interrupt.  If a BYTE_COMPLETE interrupt is concurrent with the STOP 
                                   (0241) ;interrupt the next entry to this interrupt will be immediate and the STOPIE bit will now be 
                                   (0242) ;cleared.  This removes the possibility of trying to process two different events within one 
                                   (0243) ;interrupt.
                                   (0244) ;          
                                   (0245) ;******************************************************************************************
                                   (0246) ; Check the Stop Bit in SCR only if the Stop Interrupt is enabled.    
                                   (0247) 
05A7: 49 D6 10 TST   REG[214],16   (0248)     tst reg[I2CHW_1_CFG],I2C_STOPIE
05AA: A0 06    JZ    0x05B1        (0249)     jz  ByteComplProcess
05AC: 49 D7 20 TST   REG[215],32   (0250)     tst reg[I2CHW_1_SCR],I2C_STOP_ST                         ; Test if the Interrupt is due to Stop Condition
                                   (0251) ;conditions that must be met here are Slave-enabled, STOP int enabled (STOPIE), and STOP_ST (status bit set)
05AF: B0 EB    JNZ   0x069B        (0252)     jnz STOPTRAP                                       ; If yes process Stop Trap
                                   (0253) 
                                   (0254) ByteComplProcess:
                                   (0255) ;*********END TEST OF STOP STATUS**********************************************************       
                                   (0256) 
                                   (0257) ;       file stored in Slave directory of user module
                                   (0258) ;program flow would likely be to first determine what 'mode' the device is in.  I.e. is Master and Slave mode enabled?
                                   (0259) ; control of program flow must take more into account when all more modes are enabled.
                                   (0260) ;
                                   (0261) ;* Slave only
                                   (0262)     ;very first thing to test is the I2C_ADDRIN bit.  If set then we are getting an address after a START
05B1: 49 D7 08 TST   REG[215],8    (0263)     tst reg[I2CHW_1_SCR], I2C_ADDRIN
05B4: B0 74    JNZ   0x0629        (0264)     jnz I2C_EvaluateADDRIN
                                   (0265) 
                                   (0266)     ; if slave didn't recieve an address, then this must be data for it to deal with
05B6: 49 D7 04 TST   REG[215],4    (0267)     tst reg[I2CHW_1_SCR], I2C_TX  ;if set we are transmitting => this is at end of byte to eval the ACK
05B9: B0 BE    JNZ   0x0678        (0268)     jnz I2C_EvaluateACKIN
                                   (0269)     ; if slave NOT transmitting and NOT an address then data is being recieved
                                   (0270)     ; ack it and process it.
                                   (0271) 
                                   (0272)     ;UNLESS the stop bit turns out to have been set...
05BB: 49 D7 20 TST   REG[215],32   (0273)     tst reg[I2CHW_1_SCR], I2C_STOP_ST
05BE: B0 DC    JNZ   0x069B        (0274)     jnz STOPTRAP
                                   (0275)     ; if slave NOT transmitting and NOT an address and Master is NOT terminating the then data is being recieved
                                   (0276)     ; ack it and process it.
                                   (0277) 
                                   (0278) ;;code snipped from old SW I2C below
                                   (0279) ;
                                   (0280) ; MASTER WRITE to SLAVE
                                   (0281) ;
                                   (0282) ;@PSoC_UserCode_BODY1@ (Do not change this line.)
                                   (0283) ;---------------------------------------------------
                                   (0284) ; Insert your custom code below this banner
                                   (0285) ;---------------------------------------------------
                                   (0286) ; By modifying the section from here down to the next comment block
                                   (0287) ; a user could process data for a custom I2C WRITE application
                                   (0288) ; NOTE: I2C handshakes (ACK/NAK may be effected by any introduced bugs)
                                   (0289) ;********************************************************
05C0: 47 0A 04 TST   [10],4        (0290)    tst   [I2CHW_1_bStatus], fI2C_NAKnextWr
05C3: B0 14    JNZ   0x05D8        (0291)    jnz   WrStoreData
                                   (0292)    ;
                                   (0293)    ;process write data here
                                   (0294)    ;
05C5: 7A 0C    DEC   [12]          (0295)    dec   [I2CHW_1_Write_Count]
05C7: C0 39    JC    0x0601        (0296)    jc    I2CHW_1_WriteOverflow                                       ; carry set if value became -1
                                   (0297)    ;jz    WrStoreData
05C9: 3C 0C 00 CMP   [12],0        (0298)    cmp   [I2CHW_1_Write_Count], 00                                   ;set nak flag, dec count, and store data
05CC: A0 03    JZ    0x05D0        (0299)    jz    WrNakNextByte
05CE: 80 06    JMP   0x05D5        (0300)    jmp   WrNotBufEnd
                                   (0301) WrNakNextByte:                                                       ;set the nakflag in I2CHW_1_bStatus
05D0: 2E 0A 04 OR    [10],4        (0302)    or    [I2CHW_1_bStatus], fI2C_NAKnextWr
05D3: 80 04    JMP   0x05D8        (0303)    jmp   WrStoreData
                                   (0304) WrNotBufEnd:
05D5: 26 0A FB AND   [10],251      (0305)    and   [I2CHW_1_bStatus], ~fI2C_NAKnextWr                          ;clear the nak flag in case it was set from a previous operation
                                   (0306) WrStoreData:
                                   (0307)    ;This is the ONLY place this bit is set  This bit should never be cleared by the isr ONLY by the API ClrWrStatus()
05D8: 2E 0B 10 OR    [11],16       (0308)    or    [I2CHW_1_RsrcStatus], I2CHW_WR_NOERR                        ;set current status
                                   (0309) IF SYSTEM_LARGE_MEMORY_MODEL
05DB: 51 0D    MOV   A,[13]        (0310)    mov   A, [pI2CHW_1_Write_BufHI]
                                   (0311) ENDIF
05DD: 60 D3    MOV   REG[211],A    (0312)    RAM_SETPAGE_IDX A
05DF: 58 0E    MOV   X,[14]        (0313)    mov   X, [pI2CHW_1_Write_BufLO]
05E1: 5D D8    MOV   A,REG[216]    (0314)    mov   A, reg[I2CHW_1_DR]
05E3: 70 3F    AND   F,63
05E5: 71 80    OR    F,128         (0315)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
05E7: 54 00    MOV   [X+0],A       (0316)    mov   [X], A
05E9: 70 3F    AND   F,63
05EB: 71 00    OR    F,0           (0317)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
05ED: 76 0E    INC   [14]          (0318)    inc   [pI2CHW_1_Write_BufLO]
                                   (0319) 
05EF: 47 0A 04 TST   [10],4        (0320)    tst   [I2CHW_1_bStatus], fI2C_NAKnextWr
05F2: B0 16    JNZ   0x0609        (0321)    jnz   NAK_this_one
                                   (0322) 
                                   (0323) 
                                   (0324) ;---------------------------------------------------
                                   (0325) ; End user I2C WRITE Customization
                                   (0326) ; Insert your custom code above this banner
                                   (0327) ;---------------------------------------------------
                                   (0328) ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0329) ;;code snipped form SW I2C to maintain api compatibility above
                                   (0330) 
                                   (0331) ;
                                   (0332) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                   (0333) ;
05F4: 62 D7 10 MOV   REG[215],16   (0334)     SetI2CHW_1_SCR  (I2C_ACKOUT )
05F7: 18       POP   A
                                   (0335) 
                                   (0336) 
                                   (0337) IF SYSTEM_LARGE_MEMORY_MODEL
05F8: 60 D3    MOV   REG[211],A    (0338)     REG_RESTORE IDX_PP
                                   (0339) ENDIF
05FA: 20       POP   X             (0340)     pop X
05FB: 18       POP   A             (0341)     pop A
05FC: 70 3F    AND   F,63
05FE: 71 C0    OR    F,192         (0342)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
0600: 7E       RETI                (0343)     I2CHW_1_SERVICE_RETURN
                                   (0344) 
                                   (0345) 
                                   (0346) ;
                                   (0347) ;ram-write-overflow label here, just rewrite the last location in the buffer
                                   (0348) ;    and set the overflow flag
                                   (0349) ;
                                   (0350) I2CHW_1_WriteOverflow:
0601: 2E 0B 20 OR    [11],32       (0351)    or    [I2CHW_1_RsrcStatus], I2CHW_WR_OVERFLOW                     ; flag the overflow
0604: 26 0B EF AND   [11],239      (0352)    and   [I2CHW_1_RsrcStatus], ~I2CHW_WR_NOERR
0607: 76 0C    INC   [12]          (0353)    inc   [I2CHW_1_Write_Count]                                       ; put it back to zero
                                   (0354)    ;If data is to be Nak'ed
                                   (0355) NAK_this_one:
0609: 26 0A FB AND   [10],251      (0356)    and   [I2CHW_1_bStatus], ~fI2C_NAKnextWr                          ;clear the nak flag in case it was set from a previous operation
                                   (0357) 
                                   (0358) ;
                                   (0359) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                   (0360) ;
060C: 62 D7 00 MOV   REG[215],0    (0361)     SetI2CHW_1_SCR ( 0 )
060F: 18       POP   A
                                   (0362) 
                                   (0363) 
                                   (0364) IF SYSTEM_LARGE_MEMORY_MODEL
0610: 60 D3    MOV   REG[211],A    (0365)     REG_RESTORE IDX_PP
                                   (0366) ENDIF
0612: 20       POP   X             (0367)     pop X
0613: 18       POP   A             (0368)     pop A
0614: 70 3F    AND   F,63
0616: 71 C0    OR    F,192         (0369)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
0618: 7E       RETI                (0370)     I2CHW_1_SERVICE_RETURN                                                              ;return and wait for the next interrupt (on data)
                                   (0371) 
                                   (0372) 
                                   (0373) ;********************************************************
                                   (0374) ; Treat the case where the Slave will be continuing to
                                   (0375) ; receive data after receiving the address
                                   (0376) ;********************************************************
                                   (0377) I2C_AckAddr_RXdata:
                                   (0378) IF I2CHW_1_POLLED_PROCESS
                                   (0379)     or [I2CHW_1_Poll_Status], I2C_WRITE_STARTED
                                   (0380) ELSE
0619: 43 D6 10 OR    REG[214],16   (0381)     BitSetI2CHW_1_CFG ( I2C_STOPIE )
                                   (0382) ENDIF
                                   (0383) 
                                   (0384) ;
                                   (0385) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                   (0386) ;
061C: 62 D7 10 MOV   REG[215],16   (0387)     SetI2CHW_1_SCR ( I2C_ACKOUT )
061F: 18       POP   A
                                   (0388) 
                                   (0389) 
                                   (0390) IF SYSTEM_LARGE_MEMORY_MODEL
0620: 60 D3    MOV   REG[211],A    (0391)     REG_RESTORE IDX_PP
                                   (0392) ENDIF
0622: 20       POP   X             (0393)     pop X
0623: 18       POP   A             (0394)     pop A
0624: 70 3F    AND   F,63
0626: 71 C0    OR    F,192         (0395)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
0628: 7E       RETI                (0396)     I2CHW_1_SERVICE_RETURN
                                   (0397) 
                                   (0398) ;********************************************************
                                   (0399) ; Look to see if the address is us or someone else
                                   (0400) ; use the carry flag to idendify a READ or WRITE address
                                   (0401) ;********************************************************
                                   (0402) I2C_EvaluateADDRIN:
0629: 51 0B    MOV   A,[11]        (0403)     mov A, [I2CHW_1_RsrcStatus]
062B: 21 30    AND   A,48          (0404)     and A, (I2CHW_WR_NOERR | I2CHW_WR_OVERFLOW)
062D: A0 07    JZ    0x0635        (0405)     jz  NewADDRNotSet                                                                                             ;set new addr only if previous data appears to be in buffer
062F: 2E 0B 40 OR    [11],64       (0406)     or  [I2CHW_1_RsrcStatus], I2CHW_WR_COMPLETE                      ;Same bit as I2CHW_ISR_NEW_ADDR
                                   (0407) 
                                   (0408) IF I2CHW_1_POLLED_PROCESS						                              ;if a new addr was received it's OK to terminate stop detection
                                   (0409)     and [I2CHW_1_Poll_Status], ~I2C_WRITE_STARTED            ;used to determine the end of a Master write to a slave.
                                   (0410) ELSE													                                            ;A REPEAT START could have terminated the transaction without a STOP
0632: 41 D6 EF AND   REG[214],239  (0411)     BitClrI2CHW_1_CFG I2C_STOPIE
                                   (0412) ENDIF
                                   (0413)                                                                                                                                           ;SET WR_COMPL bit if it appears there was write taking place just previous
                                   (0414) NewADDRNotSet:                                                       ;may use as a way to tag the end of a master write to slave
                                   (0415) ;@PSoC_UserCode_BODY4@ (Do not change this line.)
                                   (0416) ;---------------------------------------------------
                                   (0417) ; Insert your custom code below this banner
                                   (0418) ;---------------------------------------------------
                                   (0419) ; By replacing the section from here down to the next block
                                   (0420) ; a user could process I2C addresses differently
                                   (0421) ;********************************************************
                                   (0422)                                                                                                                                           ;to this new address by looking at the status bits
                                   (0423)     ;inc [rec_cnt]
0635: 5D D8    MOV   A,REG[216]    (0424)     mov A, reg[I2CHW_1_DR]
0637: 70 F9    AND   F,249         (0425)     and F, 0xF9                                                      ;clear Carry (C) AND Zero (Z) in Flag reg
0639: 6D       RRC   A             (0426)     rrc A                                                            ;carry now holds bit 0 (r/~w) from addr byte
063A: 31 0D    XOR   A,13          (0427)     xor A,  I2CHW_1_SLAVE_ADDR                                       ;for an equate
                                   (0428) 
063C: B0 4E    JNZ   0x068B        (0429)     jnz I2C_Terminate
063E: 2E 0B 80 OR    [11],128      (0430)     or [I2CHW_1_RsrcStatus], I2CHW_ISR_ACTIVE
                                   (0431) 
                                   (0432) ;********************************************************
                                   (0433) ; User could modify this section to allow the I2C routine
                                   (0434) ; to respond to multiple addresses, ram addresses, i/o pin
                                   (0435) ; based addresses, etc.
                                   (0436) ;********************************************************
                                   (0437) ;---------------------------------------------------
                                   (0438) ; End user I2C ADDR Compare Customization
                                   (0439) ; Insert your custom code above this banner
                                   (0440) ;---------------------------------------------------
                                   (0441) ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0442) 
                                   (0443) I2CHW_1_send_ack:                                                    ;slave send adress ack
                                   (0444) 
                                   (0445) 
                                   (0446)     ;OK so the addreses were the same was it a read (c=1) or a write (c=0)
0641: DF D7    JNC   0x0619        (0447)     jnc I2C_AckAddr_RXdata ;(Master Write/Slave Receive) for this case we receive data and ack it
                                   (0448) 
                                   (0449) ;********************************************************
                                   (0450) ;Master Read (Master Read/Slave Transmit) Ack the address too.
                                   (0451) ;for this case the master has just sent us OUR read address which must be Ack'ed and will
                                   (0452) ;subsequently be reading from us (which the master will Ack.  So for the first bit we must
                                   (0453) ; set the I2C_TX AND the ACK bits in the I2C_SCR (first byte only)
                                   (0454) ; THEN we'll just be reading the ACK from the master as it reads our data
                                   (0455) ;********************************************************
                                   (0456) 
0643: 26 0B FB AND   [11],251      (0457)     and [I2CHW_1_RsrcStatus], ~I2CHW_RD_COMPLETE                     ;Master will NAK us at the end of transaction
                                   (0458) 
0646: 50 14    MOV   A,20          (0459)     mov A, (I2C_ACKOUT | I2C_TX)
0648: 08       PUSH  A             (0460)     push A
                                   (0461) 
                                   (0462) 
                                   (0463) ;
                                   (0464) ;MASTER is READING FROM SLAVE (ram or flash buffer)
                                   (0465) ;
                                   (0466) ;;code snipped from old SW I2C below
                                   (0467) 
                                   (0468) I2C_ObtainReadData:
                                   (0469) 
                                   (0470) ;********************************************************
                                   (0471) ; here we need to get the next data to output (master-read)
                                   (0472) ; also set the status byte for use on exit
                                   (0473) ;********************************************************
                                   (0474) IF I2CHW_1_READ_FLASH
                                   (0475) ;@PSoC_UserCode_BODY2@ (Do not change this line.)
                                   (0476) ;---------------------------------------------------
                                   (0477) ; Insert your custom code below this banner
                                   (0478) ; User flash read customization could take place within
                                   (0479) ; this area
                                   (0480) ;---------------------------------------------------
                                   (0481)     tst  [I2CHW_1_RsrcStatus],I2CHW_READFLASH
                                   (0482)     jz   ReadRamData
                                   (0483) 
                                   (0484)     ;
                                   (0485)     ;get the data
                                   (0486)     ;
                                   (0487)     mov  X, [pI2CHW_1_Read_BufLO]
                                   (0488)     mov  A, [pI2CHW_1_Read_BufHI]
                                   (0489)     romx
                                   (0490)     mov  reg[I2CHW_1_DR],A
                                   (0491)     dec  [I2CHW_1_Read_Count]                                        ;calc addr lsb
                                   (0492)     jnc  NoDecHighCount
                                   (0493)     dec  [I2CHW_1_Read_CountHI]
                                   (0494)     jc   FlashRdOverflow
                                   (0495) 
                                   (0496) NoDecHighCount:
                                   (0497) 
                                   (0498)     inc  [pI2CHW_1_Read_BufLO]                                       ;set the next flash address to read
                                   (0499)     jnc  NoIncHiAddr
                                   (0500)     inc  [pI2CHW_1_Read_BufHI]
                                   (0501) NoIncHiAddr:
                                   (0502)    jmp   I2CNormalRead
                                   (0503) 
                                   (0504) FlashRdOverflow:
                                   (0505)     ;deal with the over flow cond by resending last data byte (dec the low order addr byte)
                                   (0506) 
                                   (0507)    or    [I2CHW_1_RsrcStatus], I2CHW_RD_OVERFLOW
                                   (0508)    and   [I2CHW_1_RsrcStatus], ~I2CHW_RD_NOERR
                                   (0509)    ;set count back to 0
                                   (0510)    mov   [I2CHW_1_Read_CountHI], 0                                   ;functionally the same as incrementing ffff and less instructions
                                   (0511)    mov   [I2CHW_1_Read_Count], 0
                                   (0512)    jmp   I2CNormalRead
                                   (0513) ;---------------------------------------------------
                                   (0514) ; Insert your custom code above this banner
                                   (0515) ; END User flash read customization
                                   (0516) ;---------------------------------------------------
                                   (0517) ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0518) ENDIF
                                   (0519) ;@PSoC_UserCode_BODY3@ (Do not change this line.)
                                   (0520) ;---------------------------------------------------
                                   (0521) ; Insert your custom code below this banner
                                   (0522) ;---------------------------------------------------
                                   (0523) ; By replacing the section from here down to the next block
                                   (0524) ; a user could process data for a custom I2C READ application
                                   (0525) ;********************************************************
                                   (0526) ReadRamData:
                                   (0527)    ;read the current data byte
                                   (0528) IF SYSTEM_LARGE_MEMORY_MODEL
0649: 51 0F    MOV   A,[15]        (0529)    mov   A, [pI2CHW_1_Read_BufHI]
                                   (0530) ENDIF
064B: 60 D3    MOV   REG[211],A    (0531)    RAM_SETPAGE_IDX A
064D: 58 10    MOV   X,[16]        (0532)    mov   X, [pI2CHW_1_Read_BufLO]
064F: 70 3F    AND   F,63
0651: 71 80    OR    F,128         (0533)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b
0653: 52 00    MOV   A,[X+0]       (0534)    mov   A, [X]
0655: 70 3F    AND   F,63
0657: 71 00    OR    F,0           (0535)    RAM_CHANGE_PAGE_MODE FLAG_PGMODE_00b
0659: 60 D8    MOV   REG[216],A    (0536)    mov   reg[I2CHW_1_DR], A
065B: 7A 11    DEC   [17]          (0537)    dec   [I2CHW_1_Read_Count]
065D: C0 05    JC    0x0663        (0538)    jc    I2CHW_1_readOverflow
065F: 76 10    INC   [16]          (0539)    inc   [pI2CHW_1_Read_BufLO]
0661: 80 09    JMP   0x066B        (0540)    jmp   I2CNormalRead
                                   (0541) ;
                                   (0542) ;ram read overflow detected here, just resend the last location in the buffer
                                   (0543) ;
                                   (0544) I2CHW_1_readOverflow:
0663: 2E 0B 02 OR    [11],2        (0545)    or    [I2CHW_1_RsrcStatus], I2CHW_RD_OVERFLOW
0666: 26 0B FE AND   [11],254      (0546)    and   [I2CHW_1_RsrcStatus], ~I2CHW_RD_NOERR
0669: 76 11    INC   [17]          (0547)    inc   [I2CHW_1_Read_Count]                                        ; set back to zero
                                   (0548) 
                                   (0549) ;********************************************************
                                   (0550) ; End user I2C READ customization section
                                   (0551) ;********************************************************
                                   (0552) ; Insert your custom code above this banner
                                   (0553) ;---------------------------------------------------
                                   (0554) ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0555) 
                                   (0556) ;;code snipped form SW I2C to maintain api compatibility above
                                   (0557) I2CNormalRead:
                                   (0558) 
                                   (0559)         ;load the bits to set in the I2C_ISR from the stack, The proper bit pattern was previously determined
                                   (0560)         ;and place there based on whether or not the previous transmission was our I2C address.
066B: 18       POP   A             (0561)         pop A
                                   (0562) 
                                   (0563) ;
                                   (0564) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                   (0565) ;
066C: 60 D7    MOV   REG[215],A    (0566)     SetI2CHW_1_SCR A     ;set read bit as (bit0) and Addr bit (bit7)in the I2C_SCR
066E: 18       POP   A
                                   (0567) 
                                   (0568) 
                                   (0569) IF SYSTEM_LARGE_MEMORY_MODEL
066F: 60 D3    MOV   REG[211],A    (0570)     REG_RESTORE IDX_PP
                                   (0571) ENDIF
0671: 20       POP   X             (0572)     pop X
0672: 18       POP   A             (0573)     pop A
0673: 70 3F    AND   F,63
0675: 71 C0    OR    F,192         (0574)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
0677: 7E       RETI                (0575)     I2CHW_1_SERVICE_RETURN ;return and wait for the next interrupt (on data)
                                   (0576) 
                                   (0577) 
                                   (0578) 
                                   (0579) I2C_EvaluateACKIN:
                                   (0580) 
0678: 49 D7 02 TST   REG[215],2    (0581)     tst reg[I2CHW_1_SCR], I2C_LST_BIT
067B: B0 06    JNZ   0x0682        (0582)     jnz I2C_LastByteToMstr  ;NAK recd on TX so this is the end set mode to interrup only on ADDR IN
                                   (0583)     ; got here we were ACK'ed so send another byte
067D: 50 04    MOV   A,4           (0584)     mov A, ( I2C_TX )
                                   (0585)         ;load the bits to set in the I2C_ISR from the stack, The proper bit pattern was previously determined
                                   (0586)         ;and place there based on whether or not the previous transmission was our I2C address.
067F: 08       PUSH  A             (0587)         push A
0680: 8F C8    JMP   0x0649        (0588)         jmp I2C_ObtainReadData
                                   (0589) 
                                   (0590) 
                                   (0591) I2C_LastByteToMstr:
0682: 2E 0B 01 OR    [11],1        (0592)     or  [I2CHW_1_RsrcStatus], I2CHW_RD_NOERR                         ;Master NAK'ed us at the end of transaction
0685: 2E 0B 04 OR    [11],4        (0593)     or  [I2CHW_1_RsrcStatus], I2CHW_RD_COMPLETE
0688: 26 0B 7F AND   [11],127      (0594)     and [I2CHW_1_RsrcStatus], ~I2CHW_ISR_ACTIVE
                                   (0595) 
                                   (0596) I2C_Terminate:
068B: 26 0B 7F AND   [11],127      (0597)     and [I2CHW_1_RsrcStatus], ~I2CHW_ISR_ACTIVE
                                   (0598) 
                                   (0599) ;
                                   (0600) ;;  CONTROL MACRO- writes to the SCR register and accounts for clock speed adjustments if necessary
                                   (0601) ;
068E: 62 D7 00 MOV   REG[215],0    (0602)     SetI2CHW_1_SCR 0     ;the default mode to wait for an address
0691: 18       POP   A
                                   (0603) 
                                   (0604) 
                                   (0605) IF SYSTEM_LARGE_MEMORY_MODEL
0692: 60 D3    MOV   REG[211],A    (0606)     REG_RESTORE IDX_PP
                                   (0607) ENDIF
0694: 20       POP   X             (0608)     pop X
0695: 18       POP   A             (0609)     pop A
0696: 70 3F    AND   F,63
0698: 71 C0    OR    F,192         (0610)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
069A: 7E       RETI                (0611)     I2CHW_1_SERVICE_RETURN
                                   (0612) 
                                   (0613) STOPTRAP:
                                   (0614)     ;I2C stop detected
                                   (0615) ;
                                   (0616) ; set a flag to indicate END OF TRANSMISSION
                                   (0617) ;
069B: 2E 0B 40 OR    [11],64       (0618)     or  [I2CHW_1_RsrcStatus], I2CHW_WR_COMPLETE                      ;only SET by ISR USER must clear.
069E: 26 0B 7F AND   [11],127      (0619)     and [I2CHW_1_RsrcStatus], ~I2CHW_ISR_ACTIVE
                                   (0620) 
                                   (0621) IF I2CHW_1_POLLED_PROCESS
                                   (0622)     and [I2CHW_1_Poll_Status], ~I2C_WRITE_STARTED
                                   (0623) 	jmp ExitISR
                                   (0624) ELSE
06A1: 41 D6 EF AND   REG[214],239  (0625)     BitClrI2CHW_1_CFG I2C_STOPIE
06A4: 49 D7 01 TST   REG[215],1    (0626)     tst reg[I2CHW_1_SCR], I2C_BYTE_COMPL
                                   (0627) ;;if BYTE_COMPL is set, there's an excellent chance to lose an ISR.  Because of the way they are
                                   (0628) ;; latched into the INT_MSK.  Therefore clear the applicable bit (STOPIE) and jump directly to the 
                                   (0629) ;; top of this routing since the bus is currently stalled.  Just in case the ISR is properly latched,
                                   (0630) ;; clear the mask bit since it's is serviced manually.
06A7: A0 06    JZ    0x06AE        (0631)     jz ExitISR
06A9: 41 DD FE AND   REG[221],254  (0632)     and  reg[INT_CLR3], ~0x01                                ;clear the I2C interrupt
                                   (0633) ENDIF
                                   (0634) 
06AC: 8E FA    JMP   0x05A7        (0635) 	jmp Process_REENTRY
06AE: 18       POP   A
                                   (0636) 
                                   (0637) ExitISR:
                                   (0638) 
                                   (0639) IF SYSTEM_LARGE_MEMORY_MODEL
06AF: 60 D3    MOV   REG[211],A    (0640)     REG_RESTORE IDX_PP
                                   (0641) ENDIF
06B1: 20       POP   X             (0642)     pop X
06B2: 18       POP   A             (0643)     pop A
06B3: 70 3F    AND   F,63
06B5: 71 C0    OR    F,192         (0644)     RAM_RESTORE_NATIVE_PAGING      		;has no effect if this is an ISR
06B7: 7E       RETI                (0645)     I2CHW_1_SERVICE_RETURN

FILE: lib\i2chw_1common.asm
                                   (0001) ;;*****************************************************************************
                                   (0002) ;;*****************************************************************************
                                   (0003) ;;  FILENAME: I2CHW_1Common.asm
                                   (0004) ;;   Version: 1.5, Updated on 2006/06/06 at 13:39:08
                                   (0005) ;;  Generated by PSoC Designer ver 4.4  b1884 : 14 Jan, 2007
                                   (0006) ;;
                                   (0007) ;;  DESCRIPTION: I2Cs User Module software implementation file
                                   (0008) ;;               for the (22/24/27/29xxx) PSoC family of devices
                                   (0009) ;;
                                   (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0012) ;;        This means it is the caller's responsibility to preserve any values
                                   (0013) ;;        in the X and A registers that are still needed after the API functions
                                   (0014) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0018) ;;-----------------------------------------------------------------------------
                                   (0019) ;;  Copyright (c) Cypress MicroSystems 2002-2006. All Rights Reserved.
                                   (0020) ;;*****************************************************************************
                                   (0021) ;;*****************************************************************************
                                   (0022) 
                                   (0023) include "m8c.inc"
                                   (0024) include "memory.inc"
                                   (0025) include "I2CHW_1Common.inc"
                                   (0026) 
                                   (0027) ;-----------------------------------------------
                                   (0028) ; include instance specific register definitions
                                   (0029) ;-----------------------------------------------
                                   (0030) 
                                   (0031) ;-----------------------------------------------
                                   (0032) ;  Global Symbols
                                   (0033) ;-----------------------------------------------
                                   (0034) ;-------------------------------------------------------------------
                                   (0035) ;  Declare the functions global for both assembler and C compiler.
                                   (0036) ;
                                   (0037) ;  Note that there are two names for each API. First name is
                                   (0038) ;  assembler reference. Name with underscore is name refence for
                                   (0039) ;  C compiler.  Calling function in C source code does not require
                                   (0040) ;  the underscore.
                                   (0041) ;-------------------------------------------------------------------
                                   (0042) 
                                   (0043) export    I2CHW_1_InitWrite
                                   (0044) export   _I2CHW_1_InitWrite
                                   (0045) export    I2CHW_1_InitRamRead
                                   (0046) export   _I2CHW_1_InitRamRead
                                   (0047) export    I2CHW_1_InitFlashRead
                                   (0048) export   _I2CHW_1_InitFlashRead
                                   (0049) export    I2CHW_1_bReadI2CStatus
                                   (0050) export   _I2CHW_1_bReadI2CStatus
                                   (0051) export    I2CHW_1_ClrRdStatus
                                   (0052) export   _I2CHW_1_ClrRdStatus
                                   (0053) export    I2CHW_1_ClrWrStatus
                                   (0054) export   _I2CHW_1_ClrWrStatus
                                   (0055) 
                                   (0056) 
                                   (0057) AREA UserModules (ROM, REL)
                                   (0058) 
                                   (0059) 
                                   (0060) .SECTION
                                   (0061) ;-----------------------------------------------------------------------------
                                   (0062) ;  FUNCTION NAME: I2CHW_1_InitWrite
                                   (0063) ;
                                   (0064) ;  DESCRIPTION:
                                   (0065) ;     Initializes a data buffer pointer for the slave to use to deposit data, and
                                   (0066) ;     zeroes the value of a count byte for the same buffer.
                                   (0067) ;
                                   (0068) ;-----------------------------------------------------------------------------
                                   (0069) ;
                                   (0070) ;  ARGUMENTS:  [SP-5]   -- count of bytes to write
                                   (0071) ;              [SP-4]   -- Hi order part of address Wrbuf
                                   (0072) ;              [SP-3]   -- Low order part of the address Wrbuf 
                                   (0073) ;
                                   (0074) ;  RETURNS:  none
                                   (0075) ;
                                   (0076) ;    Write Status bits are cleared
                                   (0077) ;
                                   (0078) ;  SIDE EFFECTS:
                                   (0079) ;    The A and X registers may be modified by this or future implementations
                                   (0080) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0081) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0082) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0083) ;    functions.
                                   (0084) ;          
                                   (0085) ;    Currently only the page pointer registers listed below are modified: 
                                   (0086) ;          CUR_PP
                                   (0087) ;
                                   (0088) ;    Write Status bits are cleared
                                   (0089) ;
                                   (0090) ;  THEORY of OPERATION or PROCEDURE:
                                   (0091) ;     The C compiler will always place a 0 (the upper order byte of the address pointer) in
                                   (0092) ;     the accumulator.  X register is the low order pointer.
                                   (0093) ;     IF a one byte buffer is established, set a flag to NAK the first written data byte.
                                   (0094) ;
                                   (0095) 
                                   (0096)  I2CHW_1_InitWrite:
                                   (0097) _I2CHW_1_InitWrite:
                                   (0098) 
                                   (0099) WrCnt:   equ -5
                                   (0100) WrBufHi: equ -4
                                   (0101) WrBufLo: equ -3
                                   (0102) 
                                   (0103) 	RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0104)     RAM_PROLOGUE RAM_USE_CLASS_2
06B8: 10       PUSH  X             (0105) 	push  X
06B9: 4F       MOV   X,SP          (0106) 	mov   X, SP
06BA: 79       DEC   X             (0107)     dec   X                                                          ;set up the pointer for correct param access
06BB: 08       PUSH  A             (0108)     push  A
06BC: 5D DE    MOV   A,REG[222]    (0109)     mov   A, reg[INT_MSK3]
06BE: 08       PUSH  A             (0110)     push  A                                                           ;preserve flags prior to disabling int
06BF: 41 DE FE AND   REG[222],254  (0111)     M8C_DisableIntMask INT_MSK3, INT_MSK3_I2C
                                   (0112) 
06C2: 62 D0 00 MOV   REG[208],0    (0113)     RAM_SETPAGE_CUR >I2CHW_1_bStatus						                           ;Set the Page Pointer for LMM
06C5: 26 0A FB AND   [10],251      (0114)     and    [I2CHW_1_bStatus], ~fI2C_NAKnextWr                        ;reset the nak-next-written-byte flag.
                                   (0115) IF SYSTEM_LARGE_MEMORY_MODEL
06C8: 52 FC    MOV   A,[X-4]       (0116)     mov   A, [X + WrBufHi]                                           ;move wrbuf addr to A
06CA: 53 0D    MOV   [13],A        (0117)     mov   [pI2CHW_1_Write_BufHI], A
                                   (0118) ENDIF
06CC: 52 FD    MOV   A,[X-3]       (0119)     mov   A, [X + WrBufLo]                                           ;move wrbuf addr to A
06CE: 53 0E    MOV   [14],A        (0120)     mov   [pI2CHW_1_Write_BufLO], A
06D0: 52 FB    MOV   A,[X-5]       (0121)     mov   A, [X + WrCnt]                                               ;move Write_count to A
06D2: 53 0C    MOV   [12],A        (0122)     mov   [I2CHW_1_Write_Count], A
06D4: 39 01    CMP   A,1           (0123)     cmp   A, 01                                                        ;if data buffer is one byte long or less
06D6: A0 08    JZ    0x06DF        (0124)     jz    I2CHW_1_SetNak
06D8: C0 06    JC    0x06DF        (0125)     jc    I2CHW_1_SetNak
06DA: 26 0B 8F AND   [11],143      (0126)     and   [I2CHW_1_RsrcStatus], ~0x70                                ;clear the 0x10, 0x20 (Write status bits)
06DD: 80 09    JMP   0x06E7        (0127)     jmp   I2Cs_1_ResetFlgs
                                   (0128) 
                                   (0129) I2CHW_1_SetNak:
06DF: 2E 0A 04 OR    [10],4        (0130)     or    [I2CHW_1_bStatus], fI2C_NAKnextWr                          ;set the nak-next-written-byte flag.
06E2: 26 0B 8F AND   [11],143      (0131)     and   [I2CHW_1_RsrcStatus], ~0x70                                ; clear the 0x10, 0x20 (Write status bits)
06E5: 80 01    JMP   0x06E7        (0132)     jmp   I2Cs_1_ResetFlgs
                                   (0133) 
                                   (0134) I2Cs_1_ResetFlgs:
06E7: 18       POP   A             (0135)     pop A
06E8: 21 01    AND   A,1           (0136)     and A, INT_MSK3_I2C                                                ; Only enable if it was previously enabled
06EA: A0 04    JZ    0x06EF        (0137)     jz  . + 5
06EC: 43 DE 01 OR    REG[222],1    (0138)     M8C_EnableIntMask INT_MSK3, INT_MSK3_I2C
06EF: 18       POP   A             (0139)     pop A
06F0: 20       POP   X             (0140)     pop X
06F1: 70 3F    AND   F,63
                                   (0141) 	RAM_EPILOGUE RAM_USE_CLASS_4
06F3: 71 C0    OR    F,192         (0142)     RAM_EPILOGUE RAM_USE_CLASS_2
06F5: 7F       RET                 (0143)     ret
                                   (0144) 
                                   (0145) .ENDSECTION
                                   (0146) 
                                   (0147) .SECTION
                                   (0148) ;-----------------------------------------------------------------------------
                                   (0149) ;  FUNCTION NAME: I2CHW_1_InitRamRead
                                   (0150) ;
                                   (0151) ;  DESCRIPTION:
                                   (0152) ;     Initializes a data buffer pointer for the slave to use to retrieve data from,
                                   (0153) ;     and zeroes the value of a count byte for the same buffer.
                                   (0154) ;
                                   (0155) ;-----------------------------------------------------------------------------
                                   (0156) ;
                                   (0157) ;  ARGUMENTS:  [SP-5]  -- count of bytes to read
                                   (0158) ;              [SP-4]  -- Hi order part of addr to ReadBuf
                                   (0159) ;              [SP-3]  -- Low order part of the address to ReadBuf
                                   (0160) ;
                                   (0161) ;  RETURNS: none
                                   (0162) ;
                                   (0163) ;  SIDE EFFECTS:
                                   (0164) ;    The A and X registers may be modified by this or future implementations
                                   (0165) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0166) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0167) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0168) ;    functions.
                                   (0169) ;          
                                   (0170) ;    Currently only the page pointer registers listed below are modified: 
                                   (0171) ;          CUR_PP
                                   (0172) ;
                                   (0173) ;     Read Status bits are cleared
                                   (0174) ;
                                   (0175) ;  THEORY of OPERATION or PROCEDURE:
                                   (0176) ;     The C compiler will always place a 0 (the upper order byte of the address pointer) in
                                   (0177) ;     the accumulator.  X register is the low order pointer.
                                   (0178) ;
                                   (0179) 
                                   (0180)  I2CHW_1_InitRamRead:
                                   (0181) _I2CHW_1_InitRamRead:
                                   (0182) 
                                   (0183) RdCnt:     equ   -5
                                   (0184) RdBufHi:   equ   -4
                                   (0185) RdBufLo:   equ   -3
                                   (0186) 
                                   (0187)     RAM_PROLOGUE RAM_USE_CLASS_2
                                   (0188) 	RAM_PROLOGUE RAM_USE_CLASS_4
06F6: 62 D0 00 MOV   REG[208],0    (0189) 	RAM_SETPAGE_CUR >I2CHW_1_Read_Count
06F9: 10       PUSH  X             (0190)     push  X
06FA: 4F       MOV   X,SP          (0191) 	mov   X, SP
06FB: 79       DEC   X             (0192)     dec   X                                                          ;set up the pointer for correct param access
06FC: 08       PUSH  A             (0193)     push  A
06FD: 5D DE    MOV   A,REG[222]    (0194)     mov   A, reg[INT_MSK3]
06FF: 08       PUSH  A             (0195)     push  A                                                            ;preserve flags prior to disabling int
0700: 41 DE FE AND   REG[222],254  (0196)     M8C_DisableIntMask INT_MSK3, INT_MSK3_I2C
                                   (0197) 
                                   (0198) IF SYSTEM_LARGE_MEMORY_MODEL
0703: 52 FC    MOV   A,[X-4]       (0199)     mov   A, [X + RdBufHi]                                           ;move wrbuf addr to A
0705: 53 0F    MOV   [15],A        (0200)     mov   [pI2CHW_1_Read_BufHI], A
                                   (0201) ENDIF
0707: 52 FD    MOV   A,[X-3]       (0202)     mov   A, [X + RdBufLo]                                             ; move rdbuf addr to A
0709: 53 10    MOV   [16],A        (0203)     mov   [pI2CHW_1_Read_BufLO], A
070B: 52 FB    MOV   A,[X-5]       (0204)     mov   A, [X + RdCnt]                                               ; move RamRead_count to A
070D: 53 11    MOV   [17],A        (0205)     mov   [I2CHW_1_Read_Count], A
070F: 7A 11    DEC   [17]          (0206)     dec   [I2CHW_1_Read_Count]                                       ; since we decrement through zero...
0711: 26 0B F0 AND   [11],240      (0207)     and   [I2CHW_1_RsrcStatus], ~0x0f                                ; clear the lower 4 (read status bits)
                                   (0208) 
0714: 18       POP   A             (0209)     pop A
0715: 21 01    AND   A,1           (0210)     and A, INT_MSK3_I2C                                                ; Only enable if it was previously enabled
0717: A0 04    JZ    0x071C        (0211)     jz  . + 5
0719: 43 DE 01 OR    REG[222],1    (0212)     M8C_EnableIntMask INT_MSK3, INT_MSK3_I2C
071C: 18       POP   A             (0213)     pop A
071D: 20       POP   X             (0214)     pop X
071E: 70 3F    AND   F,63
                                   (0215) 
                                   (0216)     RAM_EPILOGUE RAM_USE_CLASS_4
0720: 71 C0    OR    F,192         (0217)     RAM_EPILOGUE RAM_USE_CLASS_2
0722: 7F       RET                 (0218)     ret
                                   (0219) 
                                   (0220) .ENDSECTION
                                   (0221) 
                                   (0222) .SECTION
                                   (0223) ;-----------------------------------------------------------------------------
                                   (0224) ;  FUNCTION NAME: I2CHW_1_InitFlashRead
                                   (0225) ;
                                   (0226) ;  DESCRIPTION:
                                   (0227) ;     Initializes a flash data buffer pointer for the slave to use to retrieve
                                   (0228) ;     data from, and zeroes the value of a count byte for the same buffer.
                                   (0229) ;
                                   (0230) ;-----------------------------------------------------------------------------
                                   (0231) ;
                                   (0232) ;  ARGUMENTS:  [SP-6]   -- Hi order part of flash Read count
                                   (0233) ;              [SP-5]   -- Low order part of flashRead counts
                                   (0234) ;              [SP-4]   -- Hi order part of the flash buf address
                                   (0235) ;              [SP-3]   -- Lo order part of flash buf address
                                   (0236) ;
                                   (0237) ;  RETURNS:
                                   (0238) ;
                                   (0239) ;  SIDE EFFECTS:
                                   (0240) ;    The A and X registers may be modified by this or future implementations
                                   (0241) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0242) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0243) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0244) ;    functions.
                                   (0245) ;          
                                   (0246) ;    Currently only the page pointer registers listed below are modified: 
                                   (0247) ;          CUR_PP
                                   (0248) ;
                                   (0249) ;    Read Status bits are cleared
                                   (0250) ;
                                   (0251) ;  THEORY of OPERATION or PROCEDURE:
                                   (0252) ;     The C compiler will place the upper order address of the buffer in Acc.
                                   (0253) ;     X register is the low order pointer.  A user module parameter is used to conserve code
                                   (0254) ;     if flash buffers are un-needed.  The API call is left defined and capable of returning in
                                   (0255) ;     either case
                                   (0256) ;
                                   (0257)  I2CHW_1_InitFlashRead:
                                   (0258) _I2CHW_1_InitFlashRead:
                                   (0259) 
                                   (0260) FlRdCntHI:     equ   -6
                                   (0261) FlRdCntLO:     equ   -5
                                   (0262) FlBufAdrHI:    equ   -4
                                   (0263) FlBufAdrLO:    equ   -3
                                   (0264) 
                                   (0265) IF I2CHW_1_READ_FLASH
                                   (0266)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0267)     RAM_PROLOGUE RAM_USE_CLASS_2
                                   (0268)     RAM_SETPAGE_CUR >pI2CHW_1_Read_BufLO   
                                   (0269) 	push  X
                                   (0270) 	mov   X, SP
                                   (0271)     dec   X                                                            ;set up the pointer for correct param access
                                   (0272)     push  A
                                   (0273)     mov   A, reg[INT_MSK3]
                                   (0274)     push  A                                                            ;preserve flags prior to disabling int
                                   (0275)     M8C_DisableIntMask INT_MSK3, INT_MSK3_I2C
                                   (0276) 
                                   (0277)     mov   A, [X + FlBufAdrLO]                                          ; move flrdbuf LOaddr to A
                                   (0278)     mov   [pI2CHW_1_Read_BufLO], A
                                   (0279)     mov   A, [X + FlBufAdrHI]                                          ; move flrdbuf HIaddr to A
                                   (0280)     mov   [pI2CHW_1_Read_BufHI], A
                                   (0281)     mov   A, [X + FlRdCntLO]                                           ; move flrdbuf LOcount to A
                                   (0282)     mov   [I2CHW_1_Read_Count], A
                                   (0283)     mov   A, [X + FlRdCntHI]                                           ; move flrdbuf HIcount to A
                                   (0284)     mov   [I2CHW_1_Read_CountHI], A
                                   (0285) 
                                   (0286)     dec   [I2CHW_1_Read_Count]                                       ; since this will count throu zero
                                   (0287)     jnc    . + 4                                                       ; only Read_CountHI if Read_Count rolled to 0xff
                                   (0288)     dec   [I2CHW_1_Read_CountHI]
                                   (0289) 
                                   (0290)     and   [I2CHW_1_RsrcStatus], ~0x07                                ; clear the lower 3 (read status bits)
                                   (0291)     or    [I2CHW_1_RsrcStatus],I2CHW_READFLASH                       ; set the flash status bit
                                   (0292) 
                                   (0293)     pop A
                                   (0294)     and A, INT_MSK3_I2C                                                ; Only enable if it was previously enabled
                                   (0295)     jz  . + 5
                                   (0296)     M8C_EnableIntMask INT_MSK3, INT_MSK3_I2C
                                   (0297)     pop A
                                   (0298) 	pop X
                                   (0299)     RAM_EPILOGUE RAM_USE_CLASS_2
                                   (0300) 	RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0301) ENDIF
0723: 7F       RET                 (0302)     ret
                                   (0303) 
                                   (0304) .ENDSECTION
                                   (0305) 
                                   (0306) .SECTION
                                   (0307) ;-----------------------------------------------------------------------------
                                   (0308) ;  FUNCTION NAME: I2CHW_1_bReadI2CStatus
                                   (0309) ;
                                   (0310) ;  DESCRIPTION:
                                   (0311) ;     Returns the value in the the RsrcStatus variable.
                                   (0312) ;
                                   (0313) ;-----------------------------------------------------------------------------
                                   (0314) ;
                                   (0315) ;  ARGUMENTS:
                                   (0316) ;
                                   (0317) ;  RETURNS:
                                   (0318) ;     BYTE  bI2CStatus -  status data.  Use the following defined bits
                                   (0319) ;     returned in A.
                                   (0320) ;         I2CHW_RD_NOERR:                   equ 1
                                   (0321) ;         I2CHW_RD_OVERFLOW:                equ 2
                                   (0322) ;         I2CHW_RD_INCOMPLETE:              equ 4
                                   (0323) ;         I2CHW_READFLASH:                  equ 8
                                   (0324) ;         I2CHW_WR_NOERR:                   equ 10h
                                   (0325) ;         I2CHW_WR_OVERFLOW:                equ 20h
                                   (0326) ;         I2CHW_WR_COMPLETE:                equ 40h
                                   (0327) ;         I2CHW_ISR_ACTIVE:                 equ 80h
                                   (0328) ;
                                   (0329) ;  SIDE EFFECTS:
                                   (0330) ;    The A and X registers may be modified by this or future implementations
                                   (0331) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0332) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0333) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0334) ;    functions.
                                   (0335) ;          
                                   (0336) ;    Currently only the page pointer registers listed below are modified: 
                                   (0337) ;          CUR_PP
                                   (0338) ;          
                                   (0339)  I2CHW_1_bReadI2CStatus:
                                   (0340) _I2CHW_1_bReadI2CStatus:
                                   (0341)     RAM_PROLOGUE RAM_USE_CLASS_4
0724: 62 D0 00 MOV   REG[208],0    (0342) 	RAM_SETPAGE_CUR >I2CHW_1_RsrcStatus
0727: 51 0B    MOV   A,[11]        (0343)     mov   A, [I2CHW_1_RsrcStatus]                                    ;return the status in A
                                   (0344)     RAM_EPILOGUE RAM_USE_CLASS_4
0729: 7F       RET                 (0345)     ret
                                   (0346) 
                                   (0347) .ENDSECTION
                                   (0348) 
                                   (0349) .SECTION
                                   (0350) ;-----------------------------------------------------------------------------
                                   (0351) ;  FUNCTION NAME: I2CHW_1_ClrRdStatus
                                   (0352) ;
                                   (0353) ;  DESCRIPTION:
                                   (0354) ;     Clears the Status bits in the Control/Status register, doesn't alter buffer
                                   (0355) ;     addresses or counts, leaves the Flash/Ram Read bit alone too
                                   (0356) ;
                                   (0357) ;-----------------------------------------------------------------------------
                                   (0358) ;
                                   (0359) ;  ARGUMENTS: none
                                   (0360) ;
                                   (0361) ;  RETURNS: none
                                   (0362) ;
                                   (0363) ;  SIDE EFFECTS:
                                   (0364) ;    The A and X registers may be modified by this or future implementations
                                   (0365) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0366) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0367) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0368) ;    functions.
                                   (0369) ;          
                                   (0370) ;    Currently only the page pointer registers listed below are modified: 
                                   (0371) ;          CUR_PP
                                   (0372) ;          
                                   (0373)  I2CHW_1_ClrRdStatus:
                                   (0374) _I2CHW_1_ClrRdStatus:
                                   (0375)     RAM_PROLOGUE RAM_USE_CLASS_4
072A: 62 D0 00 MOV   REG[208],0    (0376) 	RAM_SETPAGE_CUR >I2CHW_1_RsrcStatus
072D: 26 0B F8 AND   [11],248      (0377)     and   [I2CHW_1_RsrcStatus], ~0x07                                ; clear the lower 3 (read status bits)
                                   (0378)     RAM_EPILOGUE RAM_USE_CLASS_4
0730: 7F       RET                 (0379)     ret
                                   (0380) 
                                   (0381) .ENDSECTION
                                   (0382) 
                                   (0383) .SECTION
                                   (0384) ;-----------------------------------------------------------------------------
                                   (0385) ;  FUNCTION NAME: I2CHW_1_ClrWrStatus
                                   (0386) ;
                                   (0387) ;  DESCRIPTION:
                                   (0388) ;     Clears the Status bits in the Control/Status register, doesn't alter buffer
                                   (0389) ;     addresses or counts, leaves the Flash/Ram Read bit alone too
                                   (0390) ;
                                   (0391) ;-----------------------------------------------------------------------------
                                   (0392) ;
                                   (0393) ;  ARGUMENTS: none
                                   (0394) ;
                                   (0395) ;  RETURNS: none
                                   (0396) ;
                                   (0397) ;  SIDE EFFECTS:
                                   (0398) ;    The A and X registers may be modified by this or future implementations
                                   (0399) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0400) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0401) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0402) ;    functions.
                                   (0403) ;          
                                   (0404) ;    Currently only the page pointer registers listed below are modified: 
                                   (0405) ;          CUR_PP
                                   (0406) ;          
                                   (0407)  I2CHW_1_ClrWrStatus:
                                   (0408) _I2CHW_1_ClrWrStatus:
                                   (0409)     RAM_PROLOGUE RAM_USE_CLASS_4
0731: 62 D0 00 MOV   REG[208],0    (0410) 	RAM_SETPAGE_CUR >I2CHW_1_RsrcStatus
0734: 26 0B 8F AND   [11],143      (0411)     and   [I2CHW_1_RsrcStatus], ~0x70                                ; clear bits 10,20 (write status bits)
                                   (0412)     RAM_EPILOGUE RAM_USE_CLASS_4
0737: 7F       RET                 (0413)     ret

FILE: lib\counter8_1.asm
                                   (0001) ;;*****************************************************************************
                                   (0002) ;;*****************************************************************************
                                   (0003) ;;  FILENAME: Counter8_1.asm
                                   (0004) ;;   Version: 2.5, Updated on 2006/05/15 at 14:57:49
                                   (0005) ;;  Generated by PSoC Designer ver 4.4  b1884 : 14 Jan, 2007
                                   (0006) ;;
                                   (0007) ;;  DESCRIPTION: Counter8 User Module software implementation file
                                   (0008) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0009) ;;
                                   (0010) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0011) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0012) ;;        This means it is the caller's responsibility to preserve any values
                                   (0013) ;;        in the X and A registers that are still needed after the API functions
                                   (0014) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0015) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0016) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0017) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0018) ;;-----------------------------------------------------------------------------
                                   (0019) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0020) ;;*****************************************************************************
                                   (0021) ;;*****************************************************************************
                                   (0022) 
                                   (0023) include "m8c.inc"
                                   (0024) include "memory.inc"
                                   (0025) include "Counter8_1.inc"
                                   (0026) 
                                   (0027) ;-----------------------------------------------
                                   (0028) ;  Global Symbols
                                   (0029) ;-----------------------------------------------
                                   (0030) export  Counter8_1_EnableInt
                                   (0031) export _Counter8_1_EnableInt
                                   (0032) export  Counter8_1_DisableInt
                                   (0033) export _Counter8_1_DisableInt
                                   (0034) export  Counter8_1_Start
                                   (0035) export _Counter8_1_Start
                                   (0036) export  Counter8_1_Stop
                                   (0037) export _Counter8_1_Stop
                                   (0038) export  Counter8_1_WritePeriod
                                   (0039) export _Counter8_1_WritePeriod
                                   (0040) export  Counter8_1_WriteCompareValue
                                   (0041) export _Counter8_1_WriteCompareValue
                                   (0042) export  Counter8_1_bReadCompareValue
                                   (0043) export _Counter8_1_bReadCompareValue
                                   (0044) export  Counter8_1_bReadCounter
                                   (0045) export _Counter8_1_bReadCounter
                                   (0046) 
                                   (0047) ; The following functions are deprecated and subject to omission in future releases
                                   (0048) ;
                                   (0049) export  bCounter8_1_ReadCompareValue  ; deprecated
                                   (0050) export _bCounter8_1_ReadCompareValue  ; deprecated
                                   (0051) export  bCounter8_1_ReadCounter       ; deprecated
                                   (0052) export _bCounter8_1_ReadCounter       ; deprecated
                                   (0053) 
                                   (0054) 
                                   (0055) AREA radyopnl_RAM (RAM,REL)
                                   (0056) 
                                   (0057) ;-----------------------------------------------
                                   (0058) ;  Constant Definitions
                                   (0059) ;-----------------------------------------------
                                   (0060) 
                                   (0061) INPUT_REG_NULL:                equ 0x00    ; Clear the input register
                                   (0062) 
                                   (0063) 
                                   (0064) ;-----------------------------------------------
                                   (0065) ; Variable Allocation
                                   (0066) ;-----------------------------------------------
                                   (0067) 
                                   (0068) 
                                   (0069) AREA UserModules (ROM, REL)
                                   (0070) 
                                   (0071) .SECTION
                                   (0072) ;-----------------------------------------------------------------------------
                                   (0073) ;  FUNCTION NAME: Counter8_1_EnableInt
                                   (0074) ;
                                   (0075) ;  DESCRIPTION:
                                   (0076) ;     Enables this counter's interrupt by setting the interrupt enable mask bit
                                   (0077) ;     associated with this User Module. This function has no effect until and
                                   (0078) ;     unless the global interrupts are enabled (for example by using the
                                   (0079) ;     macro M8C_EnableGInt).
                                   (0080) ;-----------------------------------------------------------------------------
                                   (0081) ;
                                   (0082) ;  ARGUMENTS:    None.
                                   (0083) ;  RETURNS:      Nothing.
                                   (0084) ;  SIDE EFFECTS: 
                                   (0085) ;    The A and X registers may be modified by this or future implementations
                                   (0086) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0087) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0088) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0089) ;    functions.
                                   (0090) ;
                                   (0091)  Counter8_1_EnableInt:
                                   (0092) _Counter8_1_EnableInt:
                                   (0093)    RAM_PROLOGUE RAM_USE_CLASS_1
0738: 43 E1 08 OR    REG[225],8    (0094)    Counter8_1_EnableInt_M
                                   (0095)    RAM_EPILOGUE RAM_USE_CLASS_1
073B: 7F       RET                 (0096)    ret
                                   (0097) 
                                   (0098) .ENDSECTION
                                   (0099) 
                                   (0100) .SECTION
                                   (0101) ;-----------------------------------------------------------------------------
                                   (0102) ;  FUNCTION NAME: Counter8_1_DisableInt
                                   (0103) ;
                                   (0104) ;  DESCRIPTION:
                                   (0105) ;     Disables this counter's interrupt by clearing the interrupt enable
                                   (0106) ;     mask bit associated with this User Module.
                                   (0107) ;-----------------------------------------------------------------------------
                                   (0108) ;
                                   (0109) ;  ARGUMENTS:    None
                                   (0110) ;  RETURNS:      Nothing
                                   (0111) ;  SIDE EFFECTS: 
                                   (0112) ;    The A and X registers may be modified by this or future implementations
                                   (0113) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0114) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0115) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0116) ;    functions.
                                   (0117) ;
                                   (0118)  Counter8_1_DisableInt:
                                   (0119) _Counter8_1_DisableInt:
                                   (0120)    RAM_PROLOGUE RAM_USE_CLASS_1
073C: 41 E1 F7 AND   REG[225],247  (0121)    Counter8_1_DisableInt_M
                                   (0122)    RAM_EPILOGUE RAM_USE_CLASS_1
073F: 7F       RET                 (0123)    ret
                                   (0124) 
                                   (0125) 
                                   (0126) .ENDSECTION
                                   (0127) 
                                   (0128) .SECTION
                                   (0129) ;-----------------------------------------------------------------------------
                                   (0130) ;  FUNCTION NAME: Counter8_1_Start
                                   (0131) ;
                                   (0132) ;  DESCRIPTION:
                                   (0133) ;     Sets the start bit in the Control register of this user module.  The
                                   (0134) ;     counter will begin counting on the next input clock as soon as the
                                   (0135) ;     enable input is asserted high.
                                   (0136) ;-----------------------------------------------------------------------------
                                   (0137) ;
                                   (0138) ;  ARGUMENTS:    None
                                   (0139) ;  RETURNS:      Nothing
                                   (0140) ;  SIDE EFFECTS: 
                                   (0141) ;    The A and X registers may be modified by this or future implementations
                                   (0142) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0143) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0144) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0145) ;    functions.
                                   (0146) ;
                                   (0147)  Counter8_1_Start:
                                   (0148) _Counter8_1_Start:
                                   (0149)    RAM_PROLOGUE RAM_USE_CLASS_1
0740: 43 2F 01 OR    REG[47],1     (0150)    Counter8_1_Start_M
                                   (0151)    RAM_EPILOGUE RAM_USE_CLASS_1
0743: 7F       RET                 (0152)    ret
                                   (0153) 
                                   (0154) 
                                   (0155) .ENDSECTION
                                   (0156) 
                                   (0157) .SECTION
                                   (0158) ;-----------------------------------------------------------------------------
                                   (0159) ;  FUNCTION NAME: Counter8_1_Stop
                                   (0160) ;
                                   (0161) ;  DESCRIPTION:
                                   (0162) ;     Disables counter operation by clearing the start bit in the Control
                                   (0163) ;     register.
                                   (0164) ;-----------------------------------------------------------------------------
                                   (0165) ;
                                   (0166) ;  ARGUMENTS:    None
                                   (0167) ;  RETURNS:      Nothing
                                   (0168) ;  SIDE EFFECTS: 
                                   (0169) ;    The A and X registers may be modified by this or future implementations
                                   (0170) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0171) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0172) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0173) ;    functions.
                                   (0174) ;
                                   (0175)  Counter8_1_Stop:
                                   (0176) _Counter8_1_Stop:
                                   (0177)    RAM_PROLOGUE RAM_USE_CLASS_1
0744: 41 2F FE AND   REG[47],254   (0178)    Counter8_1_Stop_M
                                   (0179)    RAM_EPILOGUE RAM_USE_CLASS_1
0747: 7F       RET                 (0180)    ret
                                   (0181) 
                                   (0182) 
                                   (0183) .ENDSECTION
                                   (0184) 
                                   (0185) .SECTION
                                   (0186) ;-----------------------------------------------------------------------------
                                   (0187) ;  FUNCTION NAME: Counter8_1_WritePeriod
                                   (0188) ;
                                   (0189) ;  DESCRIPTION:
                                   (0190) ;     Write the 8-bit period value into the Period register (DR1).
                                   (0191) ;-----------------------------------------------------------------------------
                                   (0192) ;
                                   (0193) ;  ARGUMENTS: fastcall16 BYTE bPeriodValue (passed in A)
                                   (0194) ;  RETURNS:   Nothing
                                   (0195) ;  SIDE EFFECTS:
                                   (0196) ;    If the counter user module is stopped, then this value will also be
                                   (0197) ;    latched into the Count register (DR0).
                                   (0198) ;     
                                   (0199) ;    The A and X registers may be modified by this or future implementations
                                   (0200) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0201) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0202) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0203) ;    functions.
                                   (0204) ;
                                   (0205)  Counter8_1_WritePeriod:
                                   (0206) _Counter8_1_WritePeriod:
                                   (0207)    RAM_PROLOGUE RAM_USE_CLASS_1
0748: 60 2D    MOV   REG[45],A     (0208)    mov   reg[Counter8_1_PERIOD_REG], A
                                   (0209)    RAM_EPILOGUE RAM_USE_CLASS_1
074A: 7F       RET                 (0210)    ret
                                   (0211) 
                                   (0212) 
                                   (0213) .ENDSECTION
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: Counter8_1_WriteCompareValue
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Writes compare value into the Compare register (DR2).
                                   (0221) ;-----------------------------------------------------------------------------
                                   (0222) ;
                                   (0223) ;  ARGUMENTS:    fastcall16 BYTE bCompareValue (passed in A)
                                   (0224) ;  RETURNS:      Nothing
                                   (0225) ;  SIDE EFFECTS: 
                                   (0226) ;    The A and X registers may be modified by this or future implementations
                                   (0227) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0228) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0229) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0230) ;    functions.
                                   (0231) ;
                                   (0232)  Counter8_1_WriteCompareValue:
                                   (0233) _Counter8_1_WriteCompareValue:
                                   (0234)    RAM_PROLOGUE RAM_USE_CLASS_1
074B: 60 2E    MOV   REG[46],A     (0235)    mov   reg[Counter8_1_COMPARE_REG], A
                                   (0236)    RAM_EPILOGUE RAM_USE_CLASS_1
074D: 7F       RET                 (0237)    ret
                                   (0238) 
                                   (0239) 
                                   (0240) .ENDSECTION
                                   (0241) 
                                   (0242) .SECTION
                                   (0243) ;-----------------------------------------------------------------------------
                                   (0244) ;  FUNCTION NAME: Counter8_1_bReadCompareValue
                                   (0245) ;
                                   (0246) ;  DESCRIPTION:
                                   (0247) ;     Reads the Compare register.
                                   (0248) ;-----------------------------------------------------------------------------
                                   (0249) ;
                                   (0250) ;  ARGUMENTS:    None
                                   (0251) ;  RETURNS:      fastcall16 BYTE bCompareValue (value of DR2 in the A register)
                                   (0252) ;  SIDE EFFECTS: 
                                   (0253) ;    The A and X registers may be modified by this or future implementations
                                   (0254) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0255) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0256) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0257) ;    functions.
                                   (0258) ;
                                   (0259)  Counter8_1_bReadCompareValue:
                                   (0260) _Counter8_1_bReadCompareValue:
                                   (0261)  bCounter8_1_ReadCompareValue:                   ; this name deprecated
                                   (0262) _bCounter8_1_ReadCompareValue:                   ; this name deprecated
                                   (0263)    RAM_PROLOGUE RAM_USE_CLASS_1
074E: 5D 2E    MOV   A,REG[46]     (0264)    mov   A, reg[Counter8_1_COMPARE_REG]
                                   (0265)    RAM_EPILOGUE RAM_USE_CLASS_1
0750: 7F       RET                 (0266)    ret
                                   (0267) 
                                   (0268) 
                                   (0269) .ENDSECTION
                                   (0270) 
                                   (0271) .SECTION
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;  FUNCTION NAME: Counter8_1_bReadCounter
                                   (0274) ;
                                   (0275) ;  DESCRIPTION:
                                   (0276) ;     Returns the value in the Count register (DR0), preserving the value in
                                   (0277) ;     the compare register (DR2). Interrupts are prevented during the transfer
                                   (0278) ;     from the Count to the Compare registers by holding the clock low in
                                   (0279) ;     the PSoC block.
                                   (0280) ;-----------------------------------------------------------------------------
                                   (0281) ;
                                   (0282) ;  ARGUMENTS: None
                                   (0283) ;  RETURNS:   fastcall16 BYTE bCount (value of DR0 in the A register)
                                   (0284) ;  SIDE EFFECTS:
                                   (0285) ;     1) If running, the user module is stopped momentarily and one or more
                                   (0286) ;        counts may be missed.
                                   (0287) ;     2) The A and X registers may be modified by this or future implementations
                                   (0288) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0289) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0290) ;        responsibility to perserve their values across calls to fastcall16 
                                   (0291) ;        functions.
                                   (0292) ;
                                   (0293)  Counter8_1_bReadCounter:
                                   (0294) _Counter8_1_bReadCounter:
                                   (0295)  bCounter8_1_ReadCounter:                        ; this name deprecated
                                   (0296) _bCounter8_1_ReadCounter:                        ; this name deprecated
                                   (0297) 
                                   (0298)    bOrigCompareValue:      EQU   0               ; Frame offset to temp Compare store
                                   (0299)    bOrigControlReg:        EQU   1               ; Frame offset to temp CR0     store
                                   (0300)    bOrigClockSetting:      EQU   2               ; Frame offset to temp Input   store
                                   (0301)    wCounter:               EQU   3               ; Frame offset to temp Count   store
                                   (0302)    STACK_FRAME_SIZE:       EQU   4               ; max stack frame size is 4 bytes
                                   (0303) 
                                   (0304)    RAM_PROLOGUE RAM_USE_CLASS_2
0751: 4F       MOV   X,SP          (0305)    mov   X, SP                                   ; X <- stack frame pointer
0752: 5D 2E    MOV   A,REG[46]     (0306)    mov   A, reg[Counter8_1_COMPARE_REG]          ; Save the Compare register on the stack
0754: 08       PUSH  A             (0307)    push  A                                       ;
0755: 5D 2F    MOV   A,REG[47]     (0308)    mov   A, reg[Counter8_1_CONTROL_REG]          ; Save CR0 (running or stopped state)
0757: 08       PUSH  A             (0309)    push  A                                       ;
0758: 41 2F FE AND   REG[47],254   (0310)    Counter8_1_Stop_M                             ; Disable (stop) the Counter if running
075B: 71 10    OR    F,16          (0311)    M8C_SetBank1                                  ;
075D: 5D 2D    MOV   A,REG[45]     (0312)    mov   A, reg[Counter8_1_INPUT_REG]            ; save the clock input setting
075F: 08       PUSH  A             (0313)    push  A                                       ;   on the stack (now 2 bytes) and ...
                                   (0314)                                                  ;   hold the clock low:
0760: 62 2D 00 MOV   REG[45],0     (0315)    mov   reg[Counter8_1_INPUT_REG], INPUT_REG_NULL
0763: 70 EF    AND   F,239         (0316)    M8C_SetBank0
                                   (0317)                                                  ; Extract the Count via DR2 register
0765: 5D 2C    MOV   A,REG[44]     (0318)    mov   A, reg[Counter8_1_COUNTER_REG]          ; DR2 <- DR0
0767: 5D 2E    MOV   A,REG[46]     (0319)    mov   A, reg[Counter8_1_COMPARE_REG]          ; Stash the Count on the stack
0769: 08       PUSH  A             (0320)    push  A                                       ;  -stack frame is now 3 bytes
076A: 52 00    MOV   A,[X+0]       (0321)    mov   A, [X+bOrigCompareValue]                ; Restore the Compare register
076C: 60 2E    MOV   REG[46],A     (0322)    mov   reg[Counter8_1_COMPARE_REG], A
076E: 71 10    OR    F,16          (0323)    M8C_SetBank1                                  ; Restore the counter operation:
0770: 52 02    MOV   A,[X+2]       (0324)    mov   A, [X+bOrigClockSetting]                ;   First, the clock setting...
0772: 60 2D    MOV   REG[45],A     (0325)    mov   reg[Counter8_1_INPUT_REG], A            ;
0774: 70 EF    AND   F,239         (0326)    M8C_SetBank0                                  ;   then re-enable (start) the counter
0776: 52 01    MOV   A,[X+1]       (0327)    mov   A, [X+bOrigControlReg]                  ;     if it was running when
0778: 60 2F    MOV   REG[47],A     (0328)    mov   reg[Counter8_1_CONTROL_REG], A          ;     this function was first called
077A: 18       POP   A             (0329)    pop   A                                       ; Setup the return value
077B: 38 FD    ADD   SP,253        (0330)    ADD   SP, -(STACK_FRAME_SIZE-1)               ; Zap remainder of stack frame
077D: 70 3F    AND   F,63
077F: 71 C0    OR    F,192         (0331)    RAM_EPILOGUE RAM_USE_CLASS_2
0781: 7F       RET                 (0332)    ret

FILE: lib\adcinc12_1int.asm
                                   (0001) ;;*****************************************************************************
                                   (0002) ;;*****************************************************************************
                                   (0003) ;;  FILENAME:   ADCINC12_1INT.asm
                                   (0004) ;;  Version: 5.3, Updated on 2006/06/12 at 15:06:52
                                   (0005) ;;  Generated by PSoC Designer ver 4.4  b1884 : 14 Jan, 2007
                                   (0006) ;;
                                   (0007) ;;  DESCRIPTION:
                                   (0008) ;;    Assembler source for interrupt routines the 12 bit Incremential
                                   (0009) ;;    A/D converter.
                                   (0010) ;;-----------------------------------------------------------------------------
                                   (0011) ;;  Copyright (c) Cypress MicroSystems 2002-2003. All Rights Reserved.
                                   (0012) ;;*****************************************************************************
                                   (0013) ;;*****************************************************************************
                                   (0014) 
                                   (0015) include "ADCINC12_1.inc"
                                   (0016) include "m8c.inc"
                                   (0017) include "memory.inc"
                                   (0018) 
                                   (0019) ;-----------------------------------------------
                                   (0020) ;  Global Symbols
                                   (0021) ;-----------------------------------------------
                                   (0022) export _ADCINC12_1_CNT_ISR
                                   (0023) export _ADCINC12_1_TMR_ISR
                                   (0024) export  ADCINC12_1_cTimerU
                                   (0025) export  ADCINC12_1_cCounterU
                                   (0026) export _ADCINC12_1_iIncr
                                   (0027) export  ADCINC12_1_iIncr
                                   (0028) export _ADCINC12_1_fIncr
                                   (0029) export  ADCINC12_1_fIncr
                                   (0030) export  ADCINC12_1_bIncrC
                                   (0031) 
                                   (0032) ;-----------------------------------------------
                                   (0033) ; Variable Allocation
                                   (0034) ;-----------------------------------------------
                                   (0035) AREA InterruptRAM (RAM,REL,CON)
                                   (0036)     ADCINC12_1_cTimerU:   BLK  1                 ;The Upper byte of the Timer
                                   (0037)     ADCINC12_1_cCounterU: BLK  1                 ;The Upper byte of the Counter
                                   (0038)    _ADCINC12_1_iIncr:
                                   (0039)     ADCINC12_1_iIncr:     BLK  2                 ;A/D value
                                   (0040)    _ADCINC12_1_fIncr:
                                   (0041)     ADCINC12_1_fIncr:     BLK  1                 ;Data Valid Flag
                                   (0042)     ADCINC12_1_bIncrC:    BLK  1                 ;# of times to run A/D
                                   (0043) 
                                   (0044) 
                                   (0045) ;@PSoC_UserCode_INIT@ (Do not change this line.)
                                   (0046) ;---------------------------------------------------
                                   (0047) ; Insert your custom declarations below this banner
                                   (0048) ;---------------------------------------------------
                                   (0049) 
                                   (0050) ;------------------------
                                   (0051) ; Includes
                                   (0052) ;------------------------
                                   (0053) 
                                   (0054) 	
                                   (0055) ;------------------------
                                   (0056) ;  Constant Definitions
                                   (0057) ;------------------------
                                   (0058) 
                                   (0059) 
                                   (0060) ;------------------------
                                   (0061) ; Variable Allocation
                                   (0062) ;------------------------
                                   (0063) 
                                   (0064) 
                                   (0065) ;---------------------------------------------------
                                   (0066) ; Insert your custom declarations above this banner
                                   (0067) ;---------------------------------------------------
                                   (0068) ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0069) 
                                   (0070) 
                                   (0071) AREA UserModules (ROM, REL)
                                   (0072) ;-----------------------------------------------
                                   (0073) ;  EQUATES
                                   (0074) ;-----------------------------------------------
                                   (0075) LowByte:   equ 1
                                   (0076) HighByte:  equ 0
                                   (0077) 
                                   (0078) ;-----------------------------------------------------------------------------
                                   (0079) ;  FUNCTION NAME: _ADCINC12_1_CNT_ISR
                                   (0080) ;
                                   (0081) ;  DESCRIPTION:
                                   (0082) ;    Increment the upper (software) half on the counter whenever the
                                   (0083) ;    lower (hardware) half of the counter underflows.
                                   (0084) ;
                                   (0085) ;-----------------------------------------------------------------------------
                                   (0086) ;
                                   (0087) _ADCINC12_1_CNT_ISR:
0782: 76 13    INC   [19]          (0088)    inc [ADCINC12_1_cCounterU]
                                   (0089)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
                                   (0090)    ;---------------------------------------------------
                                   (0091)    ; Insert your custom code below this banner
                                   (0092)    ;---------------------------------------------------
                                   (0093)    ;   NOTE: interrupt service routines must preserve
                                   (0094)    ;   the values of the A and X CPU registers.
                                   (0095) 
                                   (0096)    ;---------------------------------------------------
                                   (0097)    ; Insert your custom code above this banner
                                   (0098)    ;---------------------------------------------------
                                   (0099)    ;@PSoC_UserCode_END@ (Do not change this line.)
0784: 7E       RETI                (0100)    reti
                                   (0101) 
                                   (0102) ;-----------------------------------------------------------------------------
                                   (0103) ;  FUNCTION NAME: _ADCINC12_1_TMR_ISR
                                   (0104) ;
                                   (0105) ;  DESCRIPTION:
                                   (0106) ;    This routine allows the counter to collect data for 64 timer cycles
                                   (0107) ;    This routine then holds the integrater in reset for one cycle while
                                   (0108) ;    the A/D value is calculated.
                                   (0109) ;
                                   (0110) ;-----------------------------------------------------------------------------
                                   (0111) ;
                                   (0112) _ADCINC12_1_TMR_ISR:
0785: 7A 12    DEC   [18]          (0113)    dec [ADCINC12_1_cTimerU]
                                   (0114) ;  if(upper count >0 )
0787: A0 02    JZ    0x078A        (0115)    jz  else1
0789: 7E       RETI                (0116)       reti
                                   (0117)    else1:;(upper count decremented to 0)
078A: 49 83 10 TST   REG[131],16   (0118)       tst reg[ADCINC12_1_AtoDcr3],10h
078D: A0 0F    JZ    0x079D        (0119)       jz   else2
                                   (0120) ;     if(A/D has been in reset mode)
078F: 40       NOP                 (0121)          nop                                     ; Dummy statement to keep time
                                   (0122)                                              ; between turning on and off counter
                                   (0123)                          ; the same.
0790: 62 27 05 MOV   REG[39],5     (0124)          mov reg[ADCINC12_1_CounterCR0],(ADCINC12_1_fDBLK_ENABLE|ADCINC12_1_fPULSE_WIDE)    ; Enable Counter
0793: 41 83 EF AND   REG[131],239  (0125)          and reg[ADCINC12_1_AtoDcr3],~10h        ; Enable Analog Integrator
                                   (0126) IF ADCINC12_1_NoAZ
0796: 41 82 DF AND   REG[130],223  (0127)          and reg[ADCINC12_1_AtoDcr2],~20h
                                   (0128) ENDIF
0799: 55 12 40 MOV   [18],64       (0129)          mov [ADCINC12_1_cTimerU],(1<<(ADCINC12_1_NUMBITS - 6))
                                   (0130)                                                  ; This will be the real counter value
079C: 7E       RETI                (0131)          reti
                                   (0132)       else2:;(A/D has been in integrate mode)
079D: 71 10    OR    F,16          (0133)          M8C_SetBank1
079F: 41 25 0F AND   REG[37],15    (0134)          and reg[ADCINC12_1_CounterSL], 0x0F     ; Disable input to counter
07A2: 70 EF    AND   F,239         (0135)          M8C_SetBank0
                                   (0136) 
07A4: 71 01    OR    F,1           (0137)          or  F,01h                               ;Enable the interrupts
                                   (0138)          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   (0139)          ; Good place to add code to switch inputs for multiplexed input to ADC
                                   (0140)          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   (0141)          ;@PSoC_UserCode_BODY_2@ (Do not change this line.)
                                   (0142)          ;---------------------------------------------------
                                   (0143)          ; Insert your custom code below this banner
                                   (0144)          ;---------------------------------------------------
                                   (0145)          ;   NOTE: interrupt service routines must preserve
                                   (0146)          ;   the values of the A and X CPU registers.
                                   (0147) 
                                   (0148)          ;---------------------------------------------------
                                   (0149)          ; Insert your custom code above this banner
                                   (0150)          ;---------------------------------------------------
                                   (0151)          ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0152) 
                                   (0153) IF ADCINC12_1_NoAZ
07A6: 43 82 20 OR    REG[130],32   (0154)          or  reg[ADCINC12_1_AtoDcr2],20h         ;Reset Integrator
                                   (0155) ENDIF
07A9: 43 83 10 OR    REG[131],16   (0156)          or  reg[ADCINC12_1_AtoDcr3],10h
07AC: 08       PUSH  A             (0157)          push A
07AD: 5D 24    MOV   A,REG[36]     (0158)          mov A, reg[ADCINC12_1_CounterDR0]       ;read Counter
07AF: 5D 26    MOV   A,REG[38]     (0159)          mov A, reg[ADCINC12_1_CounterDR2]       ;now you really read the data
                                   (0160) 
07B1: 62 27 00 MOV   REG[39],0     (0161)          mov reg[ADCINC12_1_CounterCR0],00h      ;disable counter
07B4: 71 10    OR    F,16          (0162)      M8C_SetBank1
07B6: 43 25 40 OR    REG[37],64    (0163)          or  reg[ADCINC12_1_CounterSL],ADCINC12_1_CNTINPUT  ; Reconnect counter to comparitor
07B9: 70 EF    AND   F,239         (0164)      M8C_SetBank0
                                   (0165) 
                                   (0166) 
07BB: 73       CPL   A             (0167)          cpl A
07BC: 3C 13 20 CMP   [19],32       (0168)          cmp [ADCINC12_1_cCounterU],(1<<(ADCINC12_1_NUMBITS - 7))
07BF: B0 05    JNZ   0x07C5        (0169)          jnz endif10
                                   (0170) ;        if(max positive value)
07C1: 7A 13    DEC   [19]          (0171)             dec [ADCINC12_1_cCounterU]
07C3: 50 FF    MOV   A,255         (0172)             mov A,ffh
                                   (0173)          endif10:
07C5: 68 13    ASR   [19]          (0174)          asr [ADCINC12_1_cCounterU]              ; divide by 4
07C7: 6D       RRC   A             (0175)          rrc A
07C8: 68 13    ASR   [19]          (0176)          asr [ADCINC12_1_cCounterU]
07CA: 6D       RRC   A             (0177)          rrc A
                                   (0178) ;
07CB: 5F 14 13 MOV   [20],[19]     (0179)          mov [(ADCINC12_1_iIncr + HighByte)],[ADCINC12_1_cCounterU]
07CE: 53 15    MOV   [21],A        (0180)          mov [(ADCINC12_1_iIncr + LowByte)],A
07D0: 55 16 01 MOV   [22],1        (0181)          mov [ADCINC12_1_fIncr],01h              ;Set AD data flag
07D3: 18       POP   A             (0182)          pop A
                                   (0183)          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   (0184)          ; User code here for interrupt system.
                                   (0185)          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   (0186) 
                                   (0187)          ;@PSoC_UserCode_BODY_3@ (Do not change this line.)
                                   (0188)          ;---------------------------------------------------
                                   (0189)          ; Insert your custom code below this banner
                                   (0190)          ;---------------------------------------------------
                                   (0191)          ;   NOTE: interrupt service routines must preserve
                                   (0192)          ;   the values of the A and X CPU registers.
                                   (0193) 
                                   (0194)          ;---------------------------------------------------
                                   (0195)          ; Insert your custom code above this banner
                                   (0196)          ;---------------------------------------------------
                                   (0197)          ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0198) 
07D4: 3C 17 00 CMP   [23],0        (0199)          cmp [ADCINC12_1_bIncrC],00h
07D7: A0 17    JZ    0x07EF        (0200)          jz  endif3
                                   (0201) ;        if(ADCINC12_1_bIncrC is not zero)
07D9: 7A 17    DEC   [23]          (0202)             dec [ADCINC12_1_bIncrC]
07DB: B0 13    JNZ   0x07EF        (0203)             jnz endif4
                                   (0204) ;           if(ADCINC12_1_bIncrC has decremented down to zero to 0)
07DD: 62 23 00 MOV   REG[35],0     (0205)                mov reg[ADCINC12_1_TimerCR0],00h      ;disable the Timer
07E0: 62 27 00 MOV   REG[39],0     (0206)                mov reg[ADCINC12_1_CounterCR0],00h    ;disable the Counter
07E3: 40       NOP                 (0207)                nop
07E4: 40       NOP                 (0208)                nop
07E5: 41 E1 FC AND   REG[225],252  (0209)                and reg[INT_MSK1],~(ADCINC12_1_TimerMask | ADCINC12_1_CounterMask)
                                   (0210)                                                            ;Disable both interrupts
                                   (0211) IF ADCINC12_1_NoAZ
07E8: 43 82 20 OR    REG[130],32   (0212)                or  reg[ADCINC12_1_AtoDcr2],20h       ;Reset Integrator
                                   (0213) ENDIF
07EB: 43 83 10 OR    REG[131],16   (0214)                or  reg[ADCINC12_1_AtoDcr3],10h
07EE: 7E       RETI                (0215)                reti
                                   (0216)             endif4:;
                                   (0217)          endif3:;
                                   (0218)       endif2:;
07EF: 55 12 01 MOV   [18],1        (0219)       mov [ADCINC12_1_cTimerU],1                     ;Set Timer for one cycle of reset
07F2: 55 13 E0 MOV   [19],224      (0220)       mov [ADCINC12_1_cCounterU],(-(1<<(ADCINC12_1_NUMBITS - 7)))  ;Set Counter hardware for easy enable
07F5: 62 25 FF MOV   REG[37],255   (0221)       mov reg[ADCINC12_1_CounterDR1],ffh
07F8: 7E       RETI                (0222)       reti

FILE: lib\adcinc12_1.asm
                                   (0001) ;;*****************************************************************************
                                   (0002) ;;*****************************************************************************
                                   (0003) ;;  FILENAME:   ADCINC12_1.asm
                                   (0004) ;;  Version: 5.3, Updated on 2006/06/12 at 15:06:52
                                   (0005) ;;  Generated by PSoC Designer ver 4.4  b1884 : 14 Jan, 2007
                                   (0006) ;;
                                   (0007) ;;  DESCRIPTION: ADCINC12 12 bit incremental A/D converter User Module
                                   (0008) ;;               software implementation file for 22/24/25/26/27xxx PSoC
                                   (0009) ;;               family of devices.
                                   (0010) ;;
                                   (0011) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0012) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0013) ;;        This means it is the caller's responsibility to preserve any values
                                   (0014) ;;        in the X and A registers that are still needed after the API functions
                                   (0015) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0016) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0017) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0018) ;;        now, there is no guarantee that will remain the case in future releases.        
                                   (0019) ;;-----------------------------------------------------------------------------
                                   (0020) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0021) ;;*****************************************************************************
                                   (0022) ;;*****************************************************************************
                                   (0023) 
                                   (0024) include "ADCINC12_1.inc"
                                   (0025) include "m8c.inc"
                                   (0026) include "memory.inc"
                                   (0027) 
                                   (0028) ;-----------------------------------------------
                                   (0029) ;  Global Symbols
                                   (0030) ;-----------------------------------------------
                                   (0031) export  ADCINC12_1_Start
                                   (0032) export _ADCINC12_1_Start
                                   (0033) export  ADCINC12_1_SetPower
                                   (0034) export _ADCINC12_1_SetPower
                                   (0035) export  ADCINC12_1_Stop
                                   (0036) export _ADCINC12_1_Stop
                                   (0037) export  ADCINC12_1_GetSamples
                                   (0038) export _ADCINC12_1_GetSamples
                                   (0039) export  ADCINC12_1_StopAD
                                   (0040) export _ADCINC12_1_StopAD
                                   (0041) export  ADCINC12_1_fIsData
                                   (0042) export _ADCINC12_1_fIsData
                                   (0043) export  ADCINC12_1_fIsDataAvailable
                                   (0044) export _ADCINC12_1_fIsDataAvailable
                                   (0045) export  ADCINC12_1_iGetData
                                   (0046) export _ADCINC12_1_iGetData
                                   (0047) export  ADCINC12_1_ClearFlag
                                   (0048) export _ADCINC12_1_ClearFlag
                                   (0049) 
                                   (0050) ;-----------------------------------------------
                                   (0051) ;  EQUATES
                                   (0052) ;-----------------------------------------------
                                   (0053) LowByte:   equ 1
                                   (0054) HighByte:  equ 0
                                   (0055) 
                                   (0056) AREA UserModules (ROM, REL)
                                   (0057) .SECTION
                                   (0058) ;-----------------------------------------------------------------------------
                                   (0059) ;  FUNCTION NAME: ADCINC12_1_Start
                                   (0060) ;  FUNCTION NAME: ADCINC12_1_SetPower
                                   (0061) ;
                                   (0062) ;  DESCRIPTION:
                                   (0063) ;     Applies power setting to the module's analog PSoC block.
                                   (0064) ;
                                   (0065) ;-----------------------------------------------------------------------------
                                   (0066) ;
                                   (0067) ;  ARGUMENTS:
                                   (0068) ;    A  contains the power setting
                                   (0069) ;
                                   (0070) ;  RETURNS: none
                                   (0071) ;
                                   (0072) ;  SIDE EFFECTS:
                                   (0073) ;    The A and X registers may be modified by this or future implementations
                                   (0074) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0075) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0076) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0077) ;    functions.
                                   (0078) ;
                                   (0079)  ADCINC12_1_Start:
                                   (0080) _ADCINC12_1_Start:
                                   (0081)  ADCINC12_1_SetPower:
                                   (0082) _ADCINC12_1_SetPower:
                                   (0083)    RAM_PROLOGUE RAM_USE_CLASS_2
07F9: 10       PUSH  X             (0084)    push X                              ;save X
07FA: 4F       MOV   X,SP          (0085)    mov  X,SP                           ;X will point at next pushed value
07FB: 21 03    AND   A,3           (0086)    and  A,03h
07FD: 08       PUSH  A             (0087)    push A                              ;X points at copy of A
07FE: 5D 83    MOV   A,REG[131]    (0088)    mov  A,reg[ADCINC12_1_AtoDcr3]
0800: 21 FC    AND   A,252         (0089)    and  A,~03h                         ;clear power bits
0802: 2B 00    OR    A,[X+0]       (0090)    or   A,[ X ]
0804: 60 83    MOV   REG[131],A    (0091)    mov  reg[ADCINC12_1_AtoDcr3],A
0806: 18       POP   A             (0092)    pop  A
0807: 20       POP   X             (0093)    pop  X
0808: 70 3F    AND   F,63
080A: 71 C0    OR    F,192         (0094)    RAM_EPILOGUE RAM_USE_CLASS_2
080C: 7F       RET                 (0095)    ret
                                   (0096) .ENDSECTION
                                   (0097) 
                                   (0098) .SECTION
                                   (0099) ;-----------------------------------------------------------------------------
                                   (0100) ;  FUNCTION NAME: ADCINC12_1_Stop
                                   (0101) ;
                                   (0102) ;  DESCRIPTION:
                                   (0103) ;    Removes power from the module's analog PSoC Block
                                   (0104) ;
                                   (0105) ;-----------------------------------------------------------------------------
                                   (0106) ;
                                   (0107) ;  ARGUMENTS: none
                                   (0108) ;
                                   (0109) ;  RETURNS: none
                                   (0110) ;
                                   (0111) ;  SIDE EFFECTS:
                                   (0112) ;    The A and X registers may be modified by this or future implementations
                                   (0113) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0114) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0115) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0116) ;    functions.
                                   (0117) ;
                                   (0118)  ADCINC12_1_Stop:
                                   (0119) _ADCINC12_1_Stop:
                                   (0120)    RAM_PROLOGUE RAM_USE_CLASS_1
080D: 41 83 FC AND   REG[131],252  (0121)    and reg[ADCINC12_1_AtoDcr3], ~03h
                                   (0122)    RAM_EPILOGUE RAM_USE_CLASS_1
0810: 7F       RET                 (0123)    ret
                                   (0124) .ENDSECTION
                                   (0125) 
                                   (0126) .SECTION
                                   (0127) ;-----------------------------------------------------------------------------
                                   (0128) ;  FUNCTION NAME: ADCINC12_1_Get_Samples
                                   (0129) ;
                                   (0130) ;  DESCRIPTION:
                                   (0131) ;    Starts the A/D convertor and will place data is memory.  A flag
                                   (0132) ;    is set whenever a new data value is available.
                                   (0133) ;
                                   (0134) ;-----------------------------------------------------------------------------
                                   (0135) ;
                                   (0136) ;  ARGUMENTS:
                                   (0137) ;    A  passes the number of samples to be taken.  (0 is continous)
                                   (0138) ;
                                   (0139) ;  RETURNS:
                                   (0140) ;
                                   (0141) ;  SIDE EFFECTS:
                                   (0142) ;    The A and X registers may be modified by this or future implementations
                                   (0143) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0144) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0145) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0146) ;    functions.
                                   (0147) ;          
                                   (0148) ;    Currently only the page pointer registers listed below are modified: 
                                   (0149) ;          CUR_PP
                                   (0150) ;
                                   (0151)  ADCINC12_1_GetSamples:
                                   (0152) _ADCINC12_1_GetSamples:
                                   (0153)    RAM_PROLOGUE RAM_USE_CLASS_4
0811: 62 D0 00 MOV   REG[208],0    (0154)    RAM_SETPAGE_CUR >ADCINC12_1_bIncrC
0814: 53 17    MOV   [23],A        (0155)    mov [ADCINC12_1_bIncrC],A                     ;number of samples
0816: 43 E1 01 OR    REG[225],1    (0156)    or  reg[ADCINC12_1_TimerIntReg],ADCINC12_1_TimerMask
0819: 43 E1 02 OR    REG[225],2    (0157)    or  reg[ADCINC12_1_CounterIntReg], ADCINC12_1_CounterMask
                                   (0158)                                                  ;Enable both interrupts
081C: 55 12 01 MOV   [18],1        (0159)    mov [ADCINC12_1_cTimerU],1                    ;Force the Timer to do one cycle of rest
                                   (0160) IF ADCINC12_1_NoAZ
081F: 43 82 20 OR    REG[130],32   (0161)    or  reg[ADCINC12_1_AtoDcr2],20h               ;force the Integrator into reset
                                   (0162) ENDIF
0822: 43 83 10 OR    REG[131],16   (0163)    or  reg[ADCINC12_1_AtoDcr3],10h
0825: 55 13 E0 MOV   [19],224      (0164)    mov [ADCINC12_1_cCounterU],(-(1<<(ADCINC12_1_NUMBITS - 7)));Initialize Counter
0828: 62 21 FF MOV   REG[33],255   (0165)    mov reg[ADCINC12_1_TimerDR1],ffh
082B: 62 25 FF MOV   REG[37],255   (0166)    mov reg[ADCINC12_1_CounterDR1],ffh
082E: 62 23 01 MOV   REG[35],1     (0167)    mov reg[ADCINC12_1_TimerCR0],01h              ;enable the Timer
0831: 55 16 00 MOV   [22],0        (0168)    mov [ADCINC12_1_fIncr],00h                    ;A/D Data Ready Flag is reset
                                   (0169)    RAM_EPILOGUE RAM_USE_CLASS_4
0834: 7F       RET                 (0170)    ret
                                   (0171) .ENDSECTION
                                   (0172) 
                                   (0173) .SECTION
                                   (0174) ;-----------------------------------------------------------------------------
                                   (0175) ;  FUNCTION NAME: ADCINC12_1_StopAD
                                   (0176) ;
                                   (0177) ;  DESCRIPTION:
                                   (0178) ;    Completely shuts down the A/D is an orderly manner.  Both the
                                   (0179) ;    Timer and COunter interrupts are disabled.
                                   (0180) ;
                                   (0181) ;-----------------------------------------------------------------------------
                                   (0182) ;
                                   (0183) ;  ARGUMENTS:  none
                                   (0184) ;
                                   (0185) ;  RETURNS:  none
                                   (0186) ;
                                   (0187) ;  SIDE EFFECTS:
                                   (0188) ;    The A and X registers may be modified by this or future implementations
                                   (0189) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0190) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0191) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0192) ;    functions.
                                   (0193) ;          
                                   (0194) ;    Currently only the page pointer registers listed below are modified: 
                                   (0195) ;          CUR_PP
                                   (0196) ;
                                   (0197)  ADCINC12_1_StopAD:
                                   (0198) _ADCINC12_1_StopAD:
                                   (0199)    RAM_PROLOGUE RAM_USE_CLASS_4
0835: 62 D0 00 MOV   REG[208],0    (0200)    RAM_SETPAGE_CUR >ADCINC12_1_bIncrC   
0838: 62 23 00 MOV   REG[35],0     (0201)    mov reg[ADCINC12_1_TimerCR0],00h              ;disable the Timer
083B: 62 27 00 MOV   REG[39],0     (0202)    mov reg[ADCINC12_1_CounterCR0],00h            ;disable the Counter
083E: 40       NOP                 (0203)    nop
083F: 40       NOP                 (0204)    nop
                                   (0205)    ;Disable both interrupts
0840: 41 E1 FE AND   REG[225],254  (0206)    M8C_DisableIntMask ADCINC12_1_TimerIntReg, ADCINC12_1_TimerMask 
0843: 41 E1 FD AND   REG[225],253  (0207)    M8C_DisableIntMask ADCINC12_1_CounterIntReg, ADCINC12_1_CounterMask )
                                   (0208) IF ADCINC12_1_NoAZ
0846: 43 82 20 OR    REG[130],32   (0209)    or  reg[ADCINC12_1_AtoDcr2],20h               ;reset Integrator
                                   (0210) ENDIF
0849: 43 83 10 OR    REG[131],16   (0211)    or  reg[ADCINC12_1_AtoDcr3],10h
                                   (0212)    RAM_EPILOGUE RAM_USE_CLASS_4
084C: 7F       RET                 (0213)    ret
                                   (0214) .ENDSECTION
                                   (0215) 
                                   (0216) .SECTION
                                   (0217) ;-----------------------------------------------------------------------------
                                   (0218) ;  FUNCTION NAME: ADCINC12_1_fIsDataAvailable
                                   (0219) ;
                                   (0220) ;  DESCRIPTION:
                                   (0221) ;    This function returns a non-zero value when the ADC conversion
                                   (0222) ;    is complete.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS:
                                   (0229) ;    A returns conversion status  A  = 0, conversion not complete
                                   (0230) ;                                 A != 0, Data available
                                   (0231) ;
                                   (0232) ;  SIDE EFFECTS:
                                   (0233) ;    The A and X registers may be modified by this or future implementations
                                   (0234) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0235) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0236) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0237) ;    functions.
                                   (0238) ;          
                                   (0239) ;    Currently only the page pointer registers listed below are modified: 
                                   (0240) ;          CUR_PP
                                   (0241) ;
                                   (0242)  ADCINC12_1_fIsData:
                                   (0243) _ADCINC12_1_fIsData:
                                   (0244)  ADCINC12_1_fIsDataAvailable:
                                   (0245) _ADCINC12_1_fIsDataAvailable:
                                   (0246)    RAM_PROLOGUE RAM_USE_CLASS_4
084D: 62 D0 00 MOV   REG[208],0    (0247)    RAM_SETPAGE_CUR >ADCINC12_1_bIncrC   
0850: 51 16    MOV   A,[22]        (0248)    mov A,[ADCINC12_1_fIncr]
                                   (0249)    RAM_EPILOGUE RAM_USE_CLASS_4
0852: 7F       RET                 (0250)    ret
                                   (0251) .ENDSECTION
                                   (0252) 
                                   (0253) .SECTION
                                   (0254) ;-----------------------------------------------------------------------------
                                   (0255) ;  FUNCTION NAME: ADCINC12_1_iGetData
                                   (0256) ;
                                   (0257) ;  DESCRIPTION:
                                   (0258) ;    Returns the data from the A/D.  Does not check if data is available.
                                   (0259) ;    Is set whenever a new data value is available.
                                   (0260) ;
                                   (0261) ;-----------------------------------------------------------------------------
                                   (0262) ;
                                   (0263) ;  ARGUMENTS: none
                                   (0264) ;
                                   (0265) ;  RETURNS:
                                   (0266) ;    Returns 16 bit ADC result  X contains MSB
                                   (0267) ;                               A contains LSB
                                   (0268) ;
                                   (0269) ;  SIDE EFFECTS:
                                   (0270) ;    The A and X registers may be modified by this or future implementations
                                   (0271) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0272) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0273) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0274) ;    functions.
                                   (0275) ;          
                                   (0276) ;    Currently only the page pointer registers listed below are modified: 
                                   (0277) ;          CUR_PP
                                   (0278) ;
                                   (0279)  ADCINC12_1_iGetData:
                                   (0280) _ADCINC12_1_iGetData:
                                   (0281)    RAM_PROLOGUE RAM_USE_CLASS_4
0853: 62 D0 00 MOV   REG[208],0    (0282)    RAM_SETPAGE_CUR >ADCINC12_1_bIncrC   
0856: 58 14    MOV   X,[20]        (0283)    mov X,[(ADCINC12_1_iIncr + HighByte)]
0858: 51 15    MOV   A,[21]        (0284)    mov A,[(ADCINC12_1_iIncr + LowByte)]
                                   (0285)    RAM_EPILOGUE RAM_USE_CLASS_4
085A: 7F       RET                 (0286)    ret
                                   (0287) .ENDSECTION
                                   (0288) 
                                   (0289) .SECTION
                                   (0290) ;-----------------------------------------------------------------------------
                                   (0291) ;  FUNCTION NAME: ADCINC12_1_ClearFlag
                                   (0292) ;
                                   (0293) ;  DESCRIPTION:
                                   (0294) ;    Clears data ready flag.
                                   (0295) ;
                                   (0296) ;-----------------------------------------------------------------------------
                                   (0297) ;
                                   (0298) ;  ARGUMENTS: none
                                   (0299) ;
                                   (0300) ;  RETURNS:  none
                                   (0301) ;
                                   (0302) ;  SIDE EFFECTS:
                                   (0303) ;    The A and X registers may be modified by this or future implementations
                                   (0304) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0305) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0306) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0307) ;    functions.
                                   (0308) ;          
                                   (0309) ;    Currently only the page pointer registers listed below are modified: 
                                   (0310) ;          CUR_PP
                                   (0311) ;
                                   (0312)  ADCINC12_1_ClearFlag:
                                   (0313) _ADCINC12_1_ClearFlag:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_4
085B: 62 D0 00 MOV   REG[208],0    (0315)    RAM_SETPAGE_CUR >ADCINC12_1_bIncrC   
085E: 55 16 00 MOV   [22],0        (0316)    mov [ADCINC12_1_fIncr],00h
                                   (0317)    RAM_EPILOGUE RAM_USE_CLASS_4
0861: 7F       RET                 (0318)    ret

FILE: .\main.c
(0001) //----------------------------------------------------------------------------
(0002) // Radio Panel 14.May.2009
(0003) //----------------------------------------------------------------------------
(0004) 
(0005) #include <m8c.h>
(0006) #include "PSoCAPI.h"
(0007) #include "hbheader.h"
(0008) #include "stdlib.h"
(0009) 
(0010) #define SLAVE_ADDRESS 13
(0011) 
(0012) BYTE    txBuffer[32];  
(0013) BYTE    rxBuffer[32]; 
(0014) BYTE	lastport;
(0015) BYTE 	adc_res[16] = {0}; 
(0016) BYTE 	iResult;
(0017) BYTE	ekran_res[4] = {0};  // [0]=NAV ACT, [1]=NAV STB
(0018) BYTE	sol_intkisim=0, sol_decisim=0, sag_intkisim=0, sag_decisim=0;
(0019) 
(0020) BYTE    status;  
(0021) BYTE *ptr;
(0022) //char *intRy et;
(0023) char intRet[8];
(0024) 
(0025) WORD cnt;
(0026) WORD acnt;
(0027) WORD Timeout_d;
(0028) void  I2Oku(void), I2Yaz(void);
(0029) void Int_tostring(int val), ADConv(void);
(0030) 
(0031) #pragma interrupt_handler Counter8_1_ISR, encoder_isr
(0032) void Counter8_1_ISR(void); void encoder_isr(void);
(0033) 
(0034) void dly(long int mS), init_environment(void);
(0035) 
(0036) void Counter8_1_ISR() {Counter8_1_DisableInt(); Counter8_1_Stop(); DELAY_CLR;}
__text_start:
_Counter8_1_ISR:
0862: 71 C0    OR    F,192
0864: 08       PUSH  A
0865: 5D D0    MOV   A,REG[208]
0867: 08       PUSH  A
0868: 5D D3    MOV   A,REG[211]
086A: 08       PUSH  A
086B: 5D D4    MOV   A,REG[212]
086D: 08       PUSH  A
086E: 5D D5    MOV   A,REG[213]
0870: 08       PUSH  A
0871: 62 D0 00 MOV   REG[208],0
0874: 51 F6    MOV   A,[__r0]
0876: 08       PUSH  A
0877: 51 F5    MOV   A,[__r1]
0879: 08       PUSH  A
087A: 51 F4    MOV   A,[__r2]
087C: 08       PUSH  A
087D: 51 F3    MOV   A,[__r3]
087F: 08       PUSH  A
0880: 51 F2    MOV   A,[__r4]
0882: 08       PUSH  A
0883: 51 F1    MOV   A,[__r5]
0885: 08       PUSH  A
0886: 51 F0    MOV   A,[__r6]
0888: 08       PUSH  A
0889: 51 EF    MOV   A,[__r7]
088B: 08       PUSH  A
088C: 51 EE    MOV   A,[__r8]
088E: 08       PUSH  A
088F: 51 ED    MOV   A,[__r9]
0891: 08       PUSH  A
0892: 51 EC    MOV   A,[__r10]
0894: 08       PUSH  A
0895: 51 EB    MOV   A,[__r11]
0897: 08       PUSH  A
0898: 51 EA    MOV   A,[__rX]
089A: 08       PUSH  A
089B: 51 E9    MOV   A,[__rY]
089D: 08       PUSH  A
089E: 51 E8    MOV   A,[__rZ]
08A0: 08       PUSH  A
08A1: 10       PUSH  X
08A2: 7C 07 3C LCALL 0x073C
08A5: 7C 07 44 LCALL 0x0744
08A8: 20       POP   X
08A9: 62 D0 01 MOV   REG[208],1
08AC: 51 07    MOV   A,[STATUS+1]
08AE: 21 FE    AND   A,254
08B0: 62 D0 00 MOV   REG[208],0
08B3: 53 F5    MOV   [__r1],A
08B5: 62 D0 01 MOV   REG[208],1
08B8: 51 06    MOV   A,[STATUS]
08BA: 62 D0 00 MOV   REG[208],0
08BD: 53 F6    MOV   [__r0],A
08BF: 51 F5    MOV   A,[__r1]
08C1: 08       PUSH  A
08C2: 51 F6    MOV   A,[__r0]
08C4: 62 D0 01 MOV   REG[208],1
08C7: 53 06    MOV   [STATUS],A
08C9: 18       POP   A
08CA: 53 07    MOV   [STATUS+1],A
08CC: 62 D0 00 MOV   REG[208],0
08CF: 18       POP   A
08D0: 53 E8    MOV   [__rZ],A
08D2: 18       POP   A
08D3: 53 E9    MOV   [__rY],A
08D5: 18       POP   A
08D6: 53 EA    MOV   [__rX],A
08D8: 18       POP   A
08D9: 53 EB    MOV   [__r11],A
08DB: 18       POP   A
08DC: 53 EC    MOV   [__r10],A
08DE: 18       POP   A
08DF: 53 ED    MOV   [__r9],A
08E1: 18       POP   A
08E2: 53 EE    MOV   [__r8],A
08E4: 18       POP   A
08E5: 53 EF    MOV   [__r7],A
08E7: 18       POP   A
08E8: 53 F0    MOV   [__r6],A
08EA: 18       POP   A
08EB: 53 F1    MOV   [__r5],A
08ED: 18       POP   A
08EE: 53 F2    MOV   [__r4],A
08F0: 18       POP   A
08F1: 53 F3    MOV   [__r3],A
08F3: 18       POP   A
08F4: 53 F4    MOV   [__r2],A
08F6: 18       POP   A
08F7: 53 F5    MOV   [__r1],A
08F9: 18       POP   A
08FA: 53 F6    MOV   [__r0],A
08FC: 18       POP   A
08FD: 60 D5    MOV   REG[213],A
08FF: 18       POP   A
0900: 60 D4    MOV   REG[212],A
0902: 18       POP   A
0903: 60 D3    MOV   REG[211],A
0905: 18       POP   A
0906: 60 D0    MOV   REG[208],A
0908: 18       POP   A
0909: 7E       RETI  
(0037) 
(0038) void encoder_isr(void){
(0039) }
_encoder_isr:
090A: 7E       RETI  
(0040) 		
(0041) void init_environment()
(0042) {  	PRT1DR |= 0xA0;		//release et pinleri
_init_environment:
090B: 43 04 A0 OR    REG[4],160
(0043) 	I2CHW_1_Start(); I2CHW_1_EnableSlave(); I2CHW_1_EnableInt();
090E: 10       PUSH  X
090F: 7C 05 80 LCALL 0x0580
0912: 7C 05 91 LCALL 0x0591
0915: 7C 05 81 LCALL 0x0581
(0044) 	I2CHW_1_InitRamRead(txBuffer,32);
0918: 50 20    MOV   A,32
091A: 08       PUSH  A
091B: 50 00    MOV   A,0
091D: 08       PUSH  A
091E: 50 B8    MOV   A,184
0920: 08       PUSH  A
0921: 7C 06 F6 LCALL 0x06F6
0924: 38 FD    ADD   SP,253
(0045)     I2CHW_1_InitWrite(rxBuffer,32);
0926: 50 20    MOV   A,32
0928: 08       PUSH  A
0929: 50 00    MOV   A,0
092B: 08       PUSH  A
092C: 50 98    MOV   A,152
092E: 08       PUSH  A
092F: 7C 06 B8 LCALL 0x06B8
0932: 38 FD    ADD   SP,253
0934: 20       POP   X
(0046) 	M8C_EnableGInt;	M8C_EnableIntMask (INT_MSK0, INT_MSK0_GPIO); LED7SEG_1_Start();
0935: 71 01    OR    F,1
0937: 43 E0 20 OR    REG[224],32
093A: 7C 04 17 LCALL 0x0417
(0047)  	PGA_1_Start(PGA_1_MEDPOWER); ADCINC12_1_Start(ADCINC12_1_MEDPOWER);ADCINC12_1_GetSamples(1);
093D: 10       PUSH  X
093E: 50 02    MOV   A,2
0940: 7C 03 B0 LCALL 0x03B0
0943: 50 02    MOV   A,2
0945: 7C 07 F9 LCALL 0x07F9
0948: 50 01    MOV   A,1
094A: 7C 08 11 LCALL 0x0811
094D: 20       POP   X
(0048)     
(0049)     ekran_res[0]=0; lastport=0;
094E: 62 D0 01 MOV   REG[208],1
0951: 55 00 00 MOV   [ekran_res],0
0954: 62 D0 01 MOV   REG[208],1
0957: 55 0F 00 MOV   [lastport],0
(0050)     ekran_res[1]=0;
095A: 62 D0 01 MOV   REG[208],1
095D: 55 01 00 MOV   [ekran_res+1],0
(0051)     ekran_res[2]=0;
0960: 55 02 00 MOV   [ekran_res+2],0
(0052)     ekran_res[3]=0;
0963: 55 03 00 MOV   [ekran_res+3],0
(0053)     }
0966: 7F       RET   
(0054) 
(0055) void init_delay_counter(long int mSn, long int DC)
(0056) {   Counter8_1_WritePeriod(mSn); Counter8_1_WriteCompareValue(DC); Counter8_1_EnableInt();DELAY_SET; Counter8_1_Start();}
_init_delay_counter:
  DC                   --> X-11
  mSn                  --> X-7
0967: 10       PUSH  X
0968: 4F       MOV   X,SP
0969: 62 D0 00 MOV   REG[208],0
096C: 52 FC    MOV   A,[X-4]
096E: 10       PUSH  X
096F: 7C 07 48 LCALL 0x0748
0972: 20       POP   X
0973: 62 D0 00 MOV   REG[208],0
0976: 52 F8    MOV   A,[X-8]
0978: 10       PUSH  X
0979: 7C 07 4B LCALL 0x074B
097C: 7C 07 38 LCALL 0x0738
097F: 20       POP   X
0980: 62 D0 01 MOV   REG[208],1
0983: 2E 07 01 OR    [STATUS+1],1
0986: 10       PUSH  X
0987: 7C 07 40 LCALL 0x0740
098A: 20       POP   X
098B: 20       POP   X
098C: 7F       RET   
(0057) /* ---------------------------------------------------------------------- */
(0058) 
(0059) void main()
(0060) {
_main:
  dummy1               --> X+0
098D: 10       PUSH  X
098E: 4F       MOV   X,SP
098F: 38 03    ADD   SP,3
(0061) // NAV LIMITS   = 108.00-117.95 (2048--6037)
(0062) // COMM LIMITS  = 118.00-136.97 (6144--13975)
(0063) // XPNDR LIMITS = 0000-7777		(Octal system)
(0064) // ADF LIMITS   = 0100.0-1799.9
(0065) 
(0066) 	init_environment();
0991: 9F 78    CALL  _init_environment
0993: 82 52    JMP   0x0BE6
(0067)  	
(0068)  	while(1)  {
(0069) 			//txBuffer[0]=
(0070) 			BYTE dummy1;
(0071) 			I2Oku();
0995: 92 DC    CALL  _I2Oku
(0072) 
(0073) 
(0074) 			//sayiyaz();
(0075) 			dummy1 = PRT3DR^lastport;	//durumu degisen pin varmi?
0997: 5D 0C    MOV   A,REG[12]
0999: 62 D0 00 MOV   REG[208],0
099C: 53 F6    MOV   [__r0],A
099E: 62 D0 01 MOV   REG[208],1
09A1: 51 0F    MOV   A,[lastport]
09A3: 62 D0 00 MOV   REG[208],0
09A6: 34 F6    XOR   [__r0],A
09A8: 51 F6    MOV   A,[__r0]
09AA: 54 00    MOV   [X+0],A
(0076) 
(0077) 			if (dummy1 & BSET_0) {		//0. pinin durumu degismis
09AC: 48 00 01 TST   [X+0],1
09AF: A0 82    JZ    0x0A32
(0078) 				lastport=PRT3DR;
09B1: 5D 0C    MOV   A,REG[12]
09B3: 62 D0 01 MOV   REG[208],1
09B6: 53 0F    MOV   [lastport],A
(0079) 				switch  (PRT3DR & 0b00000011) {	//bu encoder hangi yone donuyor?
09B8: 5D 0C    MOV   A,REG[12]
09BA: 62 D0 00 MOV   REG[208],0
09BD: 21 03    AND   A,3
09BF: 54 02    MOV   [X+2],A
09C1: 56 01 00 MOV   [X+1],0
09C4: 3D 01 00 CMP   [X+1],0
09C7: B0 06    JNZ   0x09CE
09C9: 3D 02 01 CMP   [X+2],1
09CC: A0 0D    JZ    0x09DA
09CE: 3D 01 00 CMP   [X+1],0
09D1: B0 06    JNZ   0x09D8
09D3: 3D 02 03 CMP   [X+2],3
09D6: A0 30    JZ    0x0A07
09D8: 80 59    JMP   0x0A32
(0080) //						case 0: if (PRT2DR & BSET_7) {
(0081) //									if (ekran_res[2]==7) {ekran_res[2]=0;} else {ekran_res[2]++; }}
(0082) //								else {
(0083) //									if (ekran_res[0]==7) {ekran_res[0]=0;} else {ekran_res[0]++; }}
(0084) //								break;
(0085) //						
(0086) 						case 1: if (PRT7DR & BSET_7) {
09DA: 49 1C 80 TST   REG[28],128
09DD: A0 15    JZ    0x09F3
(0087) 									if (ekran_res[2]==0) {ekran_res[2]=7;} else {ekran_res[2]--; }}
09DF: 62 D0 01 MOV   REG[208],1
09E2: 3C 02 00 CMP   [ekran_res+2],0
09E5: B0 06    JNZ   0x09EC
09E7: 55 02 07 MOV   [ekran_res+2],7
09EA: 80 47    JMP   0x0A32
09EC: 62 D0 01 MOV   REG[208],1
09EF: 7A 02    DEC   [ekran_res+2]
09F1: 80 40    JMP   0x0A32
(0088) 								else {
(0089) 									if (ekran_res[0]==0) {ekran_res[0]=7;} else {ekran_res[0]--; }}
09F3: 62 D0 01 MOV   REG[208],1
09F6: 3C 00 00 CMP   [ekran_res],0
09F9: B0 06    JNZ   0x0A00
09FB: 55 00 07 MOV   [ekran_res],7
09FE: 80 33    JMP   0x0A32
0A00: 62 D0 01 MOV   REG[208],1
0A03: 7A 00    DEC   [ekran_res]
(0090) 								break;
0A05: 80 2C    JMP   0x0A32
(0091) 						
(0092) //						case 2: if (PRT2DR & BSET_7) {
(0093) //									if (ekran_res[2]==0) {ekran_res[2]=7;} else {ekran_res[2]--; }}
(0094) //								else {
(0095) //									if (ekran_res[0]==0) {ekran_res[0]=7;} else {ekran_res[0]--; }}
(0096) //								break;
(0097) //						
(0098) 						case 3: if (PRT7DR & BSET_7) {
0A07: 49 1C 80 TST   REG[28],128
0A0A: A0 15    JZ    0x0A20
(0099) 									if (ekran_res[2]==7) {ekran_res[2]=0;} else {ekran_res[2]++; }}
0A0C: 62 D0 01 MOV   REG[208],1
0A0F: 3C 02 07 CMP   [ekran_res+2],7
0A12: B0 06    JNZ   0x0A19
0A14: 55 02 00 MOV   [ekran_res+2],0
0A17: 80 1A    JMP   0x0A32
0A19: 62 D0 01 MOV   REG[208],1
0A1C: 76 02    INC   [ekran_res+2]
0A1E: 80 13    JMP   0x0A32
(0100) 								else {
(0101) 									if (ekran_res[0]==7) {ekran_res[0]=0;} else {ekran_res[0]++; }}
0A20: 62 D0 01 MOV   REG[208],1
0A23: 3C 00 07 CMP   [ekran_res],7
0A26: B0 06    JNZ   0x0A2D
0A28: 55 00 00 MOV   [ekran_res],0
0A2B: 80 06    JMP   0x0A32
0A2D: 62 D0 01 MOV   REG[208],1
0A30: 76 00    INC   [ekran_res]
(0102) 								break;
(0103) 						
(0104) 						}}
(0105) 			if (dummy1 & BSET_2) {		//2. pinin durumu degismis
0A32: 48 00 04 TST   [X+0],4
0A35: A0 8A    JZ    0x0AC0
(0106) 				lastport=PRT3DR;
0A37: 5D 0C    MOV   A,REG[12]
0A39: 62 D0 01 MOV   REG[208],1
0A3C: 53 0F    MOV   [lastport],A
(0107) 				switch  (PRT3DR & 0b00001100) {	//bu encoder hangi yone donuyor?
0A3E: 5D 0C    MOV   A,REG[12]
0A40: 62 D0 00 MOV   REG[208],0
0A43: 21 0C    AND   A,12
0A45: 54 02    MOV   [X+2],A
0A47: 56 01 00 MOV   [X+1],0
0A4A: 52 02    MOV   A,[X+2]
0A4C: 11 04    SUB   A,4
0A4E: 53 E9    MOV   [__rY],A
0A50: 52 01    MOV   A,[X+1]
0A52: 31 80    XOR   A,128
0A54: 19 80    SBB   A,128
0A56: C0 69    JC    0x0AC0
0A58: 2A E9    OR    A,[__rY]
0A5A: A0 0D    JZ    0x0A68
0A5C: 3D 01 00 CMP   [X+1],0
0A5F: B0 06    JNZ   0x0A66
0A61: 3D 02 0C CMP   [X+2],12
0A64: A0 30    JZ    0x0A95
0A66: 80 59    JMP   0x0AC0
(0108) //						case 0: if (PRT2DR & BSET_6) {
(0109) //									if (ekran_res[3]==7) {ekran_res[3]=0;} else {ekran_res[3]++; }}
(0110) //								else {
(0111) //									if (ekran_res[1]==7) {ekran_res[1]=0;} else {ekran_res[1]++; }}
(0112) //								break;
(0113) //						
(0114) 						case 4: if (PRT7DR & BSET_0) {
0A68: 49 1C 01 TST   REG[28],1
0A6B: A0 15    JZ    0x0A81
(0115) 									if (ekran_res[3]==0) {ekran_res[3]=7;} else {ekran_res[3]--; }}
0A6D: 62 D0 01 MOV   REG[208],1
0A70: 3C 03 00 CMP   [ekran_res+3],0
0A73: B0 06    JNZ   0x0A7A
0A75: 55 03 07 MOV   [ekran_res+3],7
0A78: 80 47    JMP   0x0AC0
0A7A: 62 D0 01 MOV   REG[208],1
0A7D: 7A 03    DEC   [ekran_res+3]
0A7F: 80 40    JMP   0x0AC0
(0116) 								else {
(0117) 									if (ekran_res[1]==0) {ekran_res[1]=7;} else {ekran_res[1]--; }}
0A81: 62 D0 01 MOV   REG[208],1
0A84: 3C 01 00 CMP   [ekran_res+1],0
0A87: B0 06    JNZ   0x0A8E
0A89: 55 01 07 MOV   [ekran_res+1],7
0A8C: 80 33    JMP   0x0AC0
0A8E: 62 D0 01 MOV   REG[208],1
0A91: 7A 01    DEC   [ekran_res+1]
(0118) 								break;
0A93: 80 2C    JMP   0x0AC0
(0119) 						
(0120) //						case 8: if (PRT2DR & BSET_6) {
(0121) //									if (ekran_res[3]==0) {ekran_res[3]=7;} else {ekran_res[3]--; }}
(0122) //								else {
(0123) //									if (ekran_res[1]==0) {ekran_res[1]=7;} else {ekran_res[1]--; }}
(0124) //								break;
(0125) //						
(0126) 						case 12: if (PRT7DR & BSET_0) {
0A95: 49 1C 01 TST   REG[28],1
0A98: A0 15    JZ    0x0AAE
(0127) 									if (ekran_res[3]==7) {ekran_res[3]=0;} else {ekran_res[3]++; }}
0A9A: 62 D0 01 MOV   REG[208],1
0A9D: 3C 03 07 CMP   [ekran_res+3],7
0AA0: B0 06    JNZ   0x0AA7
0AA2: 55 03 00 MOV   [ekran_res+3],0
0AA5: 80 1A    JMP   0x0AC0
0AA7: 62 D0 01 MOV   REG[208],1
0AAA: 76 03    INC   [ekran_res+3]
0AAC: 80 13    JMP   0x0AC0
(0128) 								else {
(0129) 									if (ekran_res[1]==7) {ekran_res[1]=0;} else {ekran_res[1]++; }}
0AAE: 62 D0 01 MOV   REG[208],1
0AB1: 3C 01 07 CMP   [ekran_res+1],7
0AB4: B0 06    JNZ   0x0ABB
0AB6: 55 01 00 MOV   [ekran_res+1],0
0AB9: 80 06    JMP   0x0AC0
0ABB: 62 D0 01 MOV   REG[208],1
0ABE: 76 01    INC   [ekran_res+1]
(0130) 								break;
(0131) 						
(0132) 						}}
(0133) 
(0134) 			txBuffer[0]=ekran_res[0];	//sol asil hane
0AC0: 62 D0 01 MOV   REG[208],1
0AC3: 51 00    MOV   A,[ekran_res]
0AC5: 62 D0 00 MOV   REG[208],0
0AC8: 53 B8    MOV   [txBuffer],A
(0135) 			txBuffer[2]=ekran_res[1];	//sag asil hane
0ACA: 62 D0 01 MOV   REG[208],1
0ACD: 51 01    MOV   A,[ekran_res+1]
0ACF: 62 D0 00 MOV   REG[208],0
0AD2: 53 BA    MOV   [txBuffer+2],A
(0136) 			txBuffer[1]=ekran_res[2];	//sol decimal hane
0AD4: 62 D0 01 MOV   REG[208],1
0AD7: 51 02    MOV   A,[ekran_res+2]
0AD9: 62 D0 00 MOV   REG[208],0
0ADC: 53 B9    MOV   [txBuffer+1],A
(0137) 			txBuffer[3]=ekran_res[3];	//sag decimal hane
0ADE: 62 D0 01 MOV   REG[208],1
0AE1: 51 03    MOV   A,[ekran_res+3]
0AE3: 62 D0 00 MOV   REG[208],0
0AE6: 53 BB    MOV   [txBuffer+3],A
(0138) 
(0139) 			//LED7SEG_1_DispInt(iResult, 1, 4);			
(0140) 			// <=30 STBY
(0141) 			// 30<<40 ALT
(0142) 			// 40<<93 XPNDR
(0143) 			// 93<<160 TA ONLY
(0144) 			// >=161 TA/RA
(0145) 			
(0146) 			if (iResult<=24) {txBuffer[4]=1;}
0AE8: 62 D0 01 MOV   REG[208],1
0AEB: 50 18    MOV   A,24
0AED: 3A 0E    CMP   A,[iResult]
0AEF: C0 07    JC    0x0AF7
0AF1: 62 D0 00 MOV   REG[208],0
0AF4: 55 BC 01 MOV   [188],1
(0147) 			if ((iResult>=25) && (iResult<=60)) {txBuffer[4]=2;}
0AF7: 62 D0 01 MOV   REG[208],1
0AFA: 3C 0E 19 CMP   [iResult],25
0AFD: C0 10    JC    0x0B0E
0AFF: 62 D0 01 MOV   REG[208],1
0B02: 50 3C    MOV   A,60
0B04: 3A 0E    CMP   A,[iResult]
0B06: C0 07    JC    0x0B0E
0B08: 62 D0 00 MOV   REG[208],0
0B0B: 55 BC 02 MOV   [188],2
(0148) 			if ((iResult>=61) && (iResult<=93)) {txBuffer[4]=3;}
0B0E: 62 D0 01 MOV   REG[208],1
0B11: 3C 0E 3D CMP   [iResult],61
0B14: C0 10    JC    0x0B25
0B16: 62 D0 01 MOV   REG[208],1
0B19: 50 5D    MOV   A,93
0B1B: 3A 0E    CMP   A,[iResult]
0B1D: C0 07    JC    0x0B25
0B1F: 62 D0 00 MOV   REG[208],0
0B22: 55 BC 03 MOV   [188],3
(0149) 			if ((iResult>=94) && (iResult<=160)) {txBuffer[4]=4;}
0B25: 62 D0 01 MOV   REG[208],1
0B28: 3C 0E 5E CMP   [iResult],94
0B2B: C0 10    JC    0x0B3C
0B2D: 62 D0 01 MOV   REG[208],1
0B30: 50 A0    MOV   A,160
0B32: 3A 0E    CMP   A,[iResult]
0B34: C0 07    JC    0x0B3C
0B36: 62 D0 00 MOV   REG[208],0
0B39: 55 BC 04 MOV   [188],4
(0150) 			if (iResult>=161)  {txBuffer[4]=5;}
0B3C: 62 D0 01 MOV   REG[208],1
0B3F: 3C 0E A1 CMP   [iResult],161
0B42: C0 07    JC    0x0B4A
0B44: 62 D0 00 MOV   REG[208],0
0B47: 55 BC 05 MOV   [188],5
(0151) 			
(0152) 			if (PRT4DR & BSET_7) {
0B4A: 49 10 80 TST   REG[16],128
0B4D: A0 11    JZ    0x0B5F
(0153) 				if (txBuffer[4]<10)  {txBuffer[4] = txBuffer[4]+100;} }
0B4F: 62 D0 00 MOV   REG[208],0
0B52: 3C BC 0A CMP   [188],10
0B55: D0 1B    JNC   0x0B71
0B57: 62 D0 00 MOV   REG[208],0
0B5A: 06 BC 64 ADD   [188],100
0B5D: 80 13    JMP   0x0B71
(0154) 			else {
(0155) 				if (txBuffer[4]>10)  {txBuffer[4] = txBuffer[4]-100;} }
0B5F: 62 D0 00 MOV   REG[208],0
0B62: 50 0A    MOV   A,10
0B64: 3A BC    CMP   A,[188]
0B66: D0 0A    JNC   0x0B71
0B68: 62 D0 00 MOV   REG[208],0
0B6B: 51 BC    MOV   A,[188]
0B6D: 11 64    SUB   A,100
0B6F: 53 BC    MOV   [188],A
(0156) 				
(0157) 			
(0158) 			
(0159) //			LED7SEG_1_DispInt(txBuffer[4], 1, 4);	
(0160) 			LED7SEG_1_DispInt(ekran_res[0], 1, 1);
0B71: 10       PUSH  X
0B72: 50 01    MOV   A,1
0B74: 08       PUSH  A
0B75: 08       PUSH  A
0B76: 62 D0 01 MOV   REG[208],1
0B79: 51 00    MOV   A,[ekran_res]
0B7B: 62 D0 00 MOV   REG[208],0
0B7E: 53 F5    MOV   [__r1],A
0B80: 50 00    MOV   A,0
0B82: 08       PUSH  A
0B83: 51 F5    MOV   A,[__r1]
0B85: 08       PUSH  A
0B86: 7C 05 0D LCALL 0x050D
0B89: 38 FC    ADD   SP,252
(0161) 			LED7SEG_1_DispInt(ekran_res[2], 2, 1);
0B8B: 50 01    MOV   A,1
0B8D: 08       PUSH  A
0B8E: 50 02    MOV   A,2
0B90: 08       PUSH  A
0B91: 62 D0 01 MOV   REG[208],1
0B94: 51 02    MOV   A,[ekran_res+2]
0B96: 62 D0 00 MOV   REG[208],0
0B99: 53 F5    MOV   [__r1],A
0B9B: 50 00    MOV   A,0
0B9D: 08       PUSH  A
0B9E: 51 F5    MOV   A,[__r1]
0BA0: 08       PUSH  A
0BA1: 7C 05 0D LCALL 0x050D
0BA4: 38 FC    ADD   SP,252
(0162) 			LED7SEG_1_DispInt(ekran_res[1], 3, 1);
0BA6: 50 01    MOV   A,1
0BA8: 08       PUSH  A
0BA9: 50 03    MOV   A,3
0BAB: 08       PUSH  A
0BAC: 62 D0 01 MOV   REG[208],1
0BAF: 51 01    MOV   A,[ekran_res+1]
0BB1: 62 D0 00 MOV   REG[208],0
0BB4: 53 F5    MOV   [__r1],A
0BB6: 50 00    MOV   A,0
0BB8: 08       PUSH  A
0BB9: 51 F5    MOV   A,[__r1]
0BBB: 08       PUSH  A
0BBC: 7C 05 0D LCALL 0x050D
0BBF: 38 FC    ADD   SP,252
(0163) 			LED7SEG_1_DispInt(ekran_res[3], 4, 1);
0BC1: 50 01    MOV   A,1
0BC3: 08       PUSH  A
0BC4: 50 04    MOV   A,4
0BC6: 08       PUSH  A
0BC7: 62 D0 01 MOV   REG[208],1
0BCA: 51 03    MOV   A,[ekran_res+3]
0BCC: 62 D0 00 MOV   REG[208],0
0BCF: 53 F5    MOV   [__r1],A
0BD1: 50 00    MOV   A,0
0BD3: 08       PUSH  A
0BD4: 51 F5    MOV   A,[__r1]
0BD6: 08       PUSH  A
0BD7: 7C 05 0D LCALL 0x050D
0BDA: 38 FC    ADD   SP,252
0BDC: 20       POP   X
(0164) 			
(0165) 			I2Yaz();
0BDD: 90 71    CALL  _I2Yaz
(0166) 				ADCINC12_1_ClearFlag();
0BDF: 10       PUSH  X
0BE0: 7C 08 5B LCALL 0x085B
0BE3: 20       POP   X
(0167) 				ADConv();
0BE4: 90 B0    CALL  _ADConv
0BE6: 8D AE    JMP   0x0995
(0168) 
(0169) 	
(0170) }//while kapa	
(0171) }//main kapa
0BE8: 38 FD    ADD   SP,253
0BEA: 20       POP   X
0BEB: 8F FF    JMP   0x0BEB
(0172) 
(0173) void dly(long int mS){init_delay_counter(mS,mS/2); while (DELAY_INVOKE);{}}
_dly:
  mS                   --> X-7
0BED: 10       PUSH  X
0BEE: 4F       MOV   X,SP
0BEF: 62 D0 00 MOV   REG[208],0
0BF2: 50 00    MOV   A,0
0BF4: 08       PUSH  A
0BF5: 08       PUSH  A
0BF6: 08       PUSH  A
0BF7: 50 02    MOV   A,2
0BF9: 08       PUSH  A
0BFA: 52 F9    MOV   A,[X-7]
0BFC: 08       PUSH  A
0BFD: 52 FA    MOV   A,[X-6]
0BFF: 08       PUSH  A
0C00: 52 FB    MOV   A,[X-5]
0C02: 08       PUSH  A
0C03: 52 FC    MOV   A,[X-4]
0C05: 08       PUSH  A
0C06: 7C 0D 45 LCALL __divmod_32X32_32
0C09: 18       POP   A
0C0A: 53 F3    MOV   [__r3],A
0C0C: 18       POP   A
0C0D: 53 F4    MOV   [__r2],A
0C0F: 18       POP   A
0C10: 53 F5    MOV   [__r1],A
0C12: 18       POP   A
0C13: 38 FC    ADD   SP,252
0C15: 08       PUSH  A
0C16: 51 F5    MOV   A,[__r1]
0C18: 08       PUSH  A
0C19: 51 F4    MOV   A,[__r2]
0C1B: 08       PUSH  A
0C1C: 51 F3    MOV   A,[__r3]
0C1E: 08       PUSH  A
0C1F: 52 F9    MOV   A,[X-7]
0C21: 08       PUSH  A
0C22: 52 FA    MOV   A,[X-6]
0C24: 08       PUSH  A
0C25: 52 FB    MOV   A,[X-5]
0C27: 08       PUSH  A
0C28: 52 FC    MOV   A,[X-4]
0C2A: 08       PUSH  A
0C2B: 9D 3A    CALL  _init_delay_counter
0C2D: 38 F8    ADD   SP,248
0C2F: 62 D0 01 MOV   REG[208],1
0C32: 51 07    MOV   A,[STATUS+1]
0C34: 21 01    AND   A,1
0C36: 62 D0 00 MOV   REG[208],0
0C39: 53 F5    MOV   [__r1],A
0C3B: 62 D0 01 MOV   REG[208],1
0C3E: 51 06    MOV   A,[STATUS]
0C40: 21 00    AND   A,0
0C42: 62 D0 00 MOV   REG[208],0
0C45: 39 00    CMP   A,0
0C47: BF E7    JNZ   0x0C2F
0C49: 3C F5 00 CMP   [__r1],0
0C4C: BF E2    JNZ   0x0C2F
0C4E: 20       POP   X
0C4F: 7F       RET   
(0174) 
(0175) void I2Yaz()
(0176) {
(0177) 		status = I2CHW_1_bReadI2CStatus();
_I2Yaz:
0C50: 10       PUSH  X
0C51: 7C 07 24 LCALL 0x0724
0C54: 20       POP   X
0C55: 62 D0 01 MOV   REG[208],1
0C58: 53 13    MOV   [status],A
(0178) 		if( status & I2CHW_RD_COMPLETE )
0C5A: 47 13 04 TST   [status],4
0C5D: A0 14    JZ    0x0C72
(0179) 		{
(0180) 			I2CHW_1_ClrRdStatus();
0C5F: 10       PUSH  X
0C60: 7C 07 2A LCALL 0x072A
(0181) 			I2CHW_1_InitRamRead(txBuffer,32);}}
0C63: 50 20    MOV   A,32
0C65: 08       PUSH  A
0C66: 50 00    MOV   A,0
0C68: 08       PUSH  A
0C69: 50 B8    MOV   A,184
0C6B: 08       PUSH  A
0C6C: 7C 06 F6 LCALL 0x06F6
0C6F: 38 FD    ADD   SP,253
0C71: 20       POP   X
0C72: 7F       RET   
(0182) 
(0183) void I2Oku()
(0184) {
(0185)         status = I2CHW_1_bReadI2CStatus();  
_I2Oku:
0C73: 10       PUSH  X
0C74: 7C 07 24 LCALL 0x0724
0C77: 20       POP   X
0C78: 62 D0 01 MOV   REG[208],1
0C7B: 53 13    MOV   [status],A
(0186)         if( status & I2CHW_WR_COMPLETE )  
0C7D: 47 13 40 TST   [status],64
0C80: A0 14    JZ    0x0C95
(0187)         {
(0188) 	        I2CHW_1_ClrWrStatus();  
0C82: 10       PUSH  X
0C83: 7C 07 31 LCALL 0x0731
(0189) 	        I2CHW_1_InitWrite(rxBuffer,32);}}
0C86: 50 20    MOV   A,32
0C88: 08       PUSH  A
0C89: 50 00    MOV   A,0
0C8B: 08       PUSH  A
0C8C: 50 98    MOV   A,152
0C8E: 08       PUSH  A
0C8F: 7C 06 B8 LCALL 0x06B8
0C92: 38 FD    ADD   SP,253
0C94: 20       POP   X
0C95: 7F       RET   
(0190) 	        
(0191) void ADConv()
(0192) {
(0193) 	ADCINC12_1_GetSamples(1);
_ADConv:
0C96: 10       PUSH  X
0C97: 50 01    MOV   A,1
0C99: 7C 08 11 LCALL 0x0811
0C9C: 20       POP   X
(0194) 	
(0195) 	while (ADCINC12_1_fIsDataAvailable() == 0);
0C9D: 10       PUSH  X
0C9E: 7C 08 4D LCALL 0x084D
0CA1: 62 D0 00 MOV   REG[208],0
0CA4: 20       POP   X
0CA5: 39 00    CMP   A,0
0CA7: AF F5    JZ    0x0C9D
(0196) 	iResult =(ADCINC12_1_iGetData() + 2048)/16;
0CA9: 10       PUSH  X
0CAA: 7C 08 53 LCALL 0x0853
0CAD: 62 D0 00 MOV   REG[208],0
0CB0: 53 F5    MOV   [__r1],A
0CB2: 5A F6    MOV   [__r0],X
0CB4: 20       POP   X
0CB5: 06 F5 00 ADD   [__r1],0
0CB8: 0E F6 08 ADC   [__r0],8
0CBB: 50 00    MOV   A,0
0CBD: 08       PUSH  A
0CBE: 50 10    MOV   A,16
0CC0: 08       PUSH  A
0CC1: 51 F6    MOV   A,[__r0]
0CC3: 08       PUSH  A
0CC4: 51 F5    MOV   A,[__r1]
0CC6: 08       PUSH  A
0CC7: 7C 0C F7 LCALL __divmod_16X16_16
0CCA: 18       POP   A
0CCB: 53 F5    MOV   [__r1],A
0CCD: 18       POP   A
0CCE: 38 FE    ADD   SP,254
0CD0: 51 F5    MOV   A,[__r1]
0CD2: 62 D0 01 MOV   REG[208],1
0CD5: 53 0E    MOV   [iResult],A
(0197) 		if (iResult<=0) {iResult=0;}
0CD7: 50 00    MOV   A,0
0CD9: 3A 0E    CMP   A,[iResult]
0CDB: C0 07    JC    0x0CE3
0CDD: 62 D0 01 MOV   REG[208],1
0CE0: 55 0E 00 MOV   [iResult],0
(0198) 		if (iResult>=254) {iResult=255;}
0CE3: 62 D0 01 MOV   REG[208],1
0CE6: 3C 0E FE CMP   [iResult],254
0CE9: C0 07    JC    0x0CF1
0CEB: 62 D0 01 MOV   REG[208],1
0CEE: 55 0E FF MOV   [iResult],255
(0199) 	
(0200) 	ADCINC12_1_ClearFlag();
0CF1: 10       PUSH  X
0CF2: 7C 08 5B LCALL 0x085B
0CF5: 20       POP   X
(0201) }FILE: <library>
0CF6: 7F       RET   
__divmod_16X16_16:
0CF7: 10       PUSH  X
0CF8: 4F       MOV   X,SP
0CF9: 50 00    MOV   A,0
0CFB: 3D FB 80 CMP   [X-5],128
0CFE: C0 0D    JC    0x0D0C
0D00: 37 FC FF XOR   [X-4],255
0D03: 77 FC    INC   [X-4]
0D05: 37 FB FF XOR   [X-5],255
0D08: 0D FB    ADC   [X-5],A
0D0A: 50 C0    MOV   A,192
0D0C: 3D F9 80 CMP   [X-7],128
0D0F: C0 0E    JC    0x0D1E
0D11: 37 FA FF XOR   [X-6],255
0D14: 77 FA    INC   [X-6]
0D16: 37 F9 FF XOR   [X-7],255
0D19: 0F F9 00 ADC   [X-7],0
0D1C: 31 80    XOR   A,128
0D1E: 08       PUSH  A
0D1F: 7C 0D 82 LCALL __i_div16_block_util
0D22: 18       POP   A
0D23: 6A       RLC   A
0D24: D0 0C    JNC   0x0D31
0D26: 37 FC FF XOR   [X-4],255
0D29: 37 FB FF XOR   [X-5],255
0D2C: 77 FC    INC   [X-4]
0D2E: 0F FB 00 ADC   [X-5],0
0D31: 6A       RLC   A
0D32: D0 0C    JNC   0x0D3F
0D34: 37 FA FF XOR   [X-6],255
0D37: 37 F9 FF XOR   [X-7],255
0D3A: 77 FA    INC   [X-6]
0D3C: 0F F9 00 ADC   [X-7],0
0D3F: 20       POP   X
0D40: 70 3F    AND   F,63
0D42: 71 C0    OR    F,192
0D44: 7F       RET   
__divmod_32X32_32:
0D45: 10       PUSH  X
0D46: 4F       MOV   X,SP
0D47: 38 01    ADD   SP,1
0D49: 50 00    MOV   A,0
0D4B: 3D F9 80 CMP   [X-7],128
0D4E: C0 06    JC    0x0D55
0D50: 7C 0E 1E LCALL __i_div32_not_util
0D53: 50 C0    MOV   A,192
0D55: 3D F5 80 CMP   [X-11],128
0D58: C0 0C    JC    0x0D65
0D5A: 10       PUSH  X
0D5B: 4B       SWAP  A,X
0D5C: 11 04    SUB   A,4
0D5E: 4B       SWAP  A,X
0D5F: 7C 0E 1E LCALL __i_div32_not_util
0D62: 31 80    XOR   A,128
0D64: 20       POP   X
0D65: 08       PUSH  A
0D66: 7C 0D BB LCALL __i_div32_block_util
0D69: 18       POP   A
0D6A: 6A       RLC   A
0D6B: D0 04    JNC   0x0D70
0D6D: 7C 0E 1E LCALL __i_div32_not_util
0D70: 6A       RLC   A
0D71: D0 08    JNC   0x0D7A
0D73: 4B       SWAP  A,X
0D74: 11 04    SUB   A,4
0D76: 4B       SWAP  A,X
0D77: 7C 0E 1E LCALL __i_div32_not_util
0D7A: 38 FF    ADD   SP,255
0D7C: 20       POP   X
0D7D: 70 3F    AND   F,63
0D7F: 71 C0    OR    F,192
0D81: 7F       RET   
__i_div16_block_util:
0D82: 5D D0    MOV   A,REG[208]
0D84: 08       PUSH  A
0D85: 62 D0 00 MOV   REG[208],0
0D88: 50 00    MOV   A,0
0D8A: 53 E9    MOV   [__rY],A
0D8C: 53 EA    MOV   [__rX],A
0D8E: 55 E8 10 MOV   [__rZ],16
0D91: 66 FC    ASL   [X-4]
0D93: 6C FB    RLC   [X-5]
0D95: 6B E9    RLC   [__rY]
0D97: 6B EA    RLC   [__rX]
0D99: 51 E9    MOV   A,[__rY]
0D9B: 1B FA    SBB   A,[X-6]
0D9D: 51 EA    MOV   A,[__rX]
0D9F: 1B F9    SBB   A,[X-7]
0DA1: C0 09    JC    0x0DAB
0DA3: 53 EA    MOV   [__rX],A
0DA5: 52 FA    MOV   A,[X-6]
0DA7: 1C E9    SBB   [__rY],A
0DA9: 77 FC    INC   [X-4]
0DAB: 7A E8    DEC   [__rZ]
0DAD: BF E3    JNZ   0x0D91
0DAF: 51 E9    MOV   A,[__rY]
0DB1: 54 FA    MOV   [X-6],A
0DB3: 51 EA    MOV   A,[__rX]
0DB5: 54 F9    MOV   [X-7],A
0DB7: 18       POP   A
0DB8: 60 D0    MOV   REG[208],A
0DBA: 7F       RET   
__i_div32_block_util:
0DBB: 5D D0    MOV   A,REG[208]
0DBD: 08       PUSH  A
0DBE: 62 D0 00 MOV   REG[208],0
0DC1: 51 F6    MOV   A,[__r0]
0DC3: 08       PUSH  A
0DC4: 50 00    MOV   A,0
0DC6: 53 F6    MOV   [__r0],A
0DC8: 53 EA    MOV   [__rX],A
0DCA: 53 E9    MOV   [__rY],A
0DCC: 53 E8    MOV   [__rZ],A
0DCE: 56 00 20 MOV   [X+0],32
0DD1: 66 FC    ASL   [X-4]
0DD3: 6C FB    RLC   [X-5]
0DD5: 6C FA    RLC   [X-6]
0DD7: 6C F9    RLC   [X-7]
0DD9: 6B E8    RLC   [__rZ]
0DDB: 6B E9    RLC   [__rY]
0DDD: 6B EA    RLC   [__rX]
0DDF: 6B F6    RLC   [__r0]
0DE1: 51 E8    MOV   A,[__rZ]
0DE3: 1B F8    SBB   A,[X-8]
0DE5: 51 E9    MOV   A,[__rY]
0DE7: 1B F7    SBB   A,[X-9]
0DE9: 51 EA    MOV   A,[__rX]
0DEB: 1B F6    SBB   A,[X-10]
0DED: 51 F6    MOV   A,[__r0]
0DEF: 1B F5    SBB   A,[X-11]
0DF1: C0 11    JC    0x0E03
0DF3: 53 F6    MOV   [__r0],A
0DF5: 52 F8    MOV   A,[X-8]
0DF7: 14 E8    SUB   [__rZ],A
0DF9: 52 F7    MOV   A,[X-9]
0DFB: 1C E9    SBB   [__rY],A
0DFD: 52 F6    MOV   A,[X-10]
0DFF: 1C EA    SBB   [__rX],A
0E01: 77 FC    INC   [X-4]
0E03: 7B 00    DEC   [X+0]
0E05: BF CB    JNZ   0x0DD1
0E07: 51 E8    MOV   A,[__rZ]
0E09: 54 F8    MOV   [X-8],A
0E0B: 51 E9    MOV   A,[__rY]
0E0D: 54 F7    MOV   [X-9],A
0E0F: 51 EA    MOV   A,[__rX]
0E11: 54 F6    MOV   [X-10],A
0E13: 51 F6    MOV   A,[__r0]
0E15: 54 F5    MOV   [X-11],A
0E17: 18       POP   A
0E18: 53 F6    MOV   [__r0],A
0E1A: 18       POP   A
0E1B: 60 D0    MOV   REG[208],A
0E1D: 7F       RET   
__i_div32_not_util:
0E1E: 37 FC FF XOR   [X-4],255
0E21: 77 FC    INC   [X-4]
0E23: 37 FB FF XOR   [X-5],255
0E26: 0F FB 00 ADC   [X-5],0
0E29: 37 FA FF XOR   [X-6],255
0E2C: 0F FA 00 ADC   [X-6],0
0E2F: 37 F9 FF XOR   [X-7],255
0E32: 0F F9 00 ADC   [X-7],0
0E35: 7F       RET   
--------------------------------------------------------------------------------


PSoC Designer Version: 4.4.1184

Copyright (C) 1994 - 2001 ImageCraft
ImageCraft, 706 Colorado Ave., Suite 10-88, Palo Alto, CA 94303
info@imagecraft.com, phone (650) 493-9326 FAX (650) 493-9329
http://www.imagecraft.com
lcc source code (C) 1995, by David R. Hanson and AT&T. Reproduced by permission.
Code Compressor V1.09
ICCM8C version V1.69A
